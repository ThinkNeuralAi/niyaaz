<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sakshi.AI - Dashboard</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root { 
            /* Dark theme palette */
            --bg-primary: #0D1117;       /* page background */
            --bg-secondary: #161B22;     /* cards / sections */
            --border-color: #30363D;     /* borders */
            --text-primary: #C9D1D9;     /* main text */
            --text-secondary: #8B949E;   /* muted text */
            --accent-color: #238636;     /* primary accent (green) */
            --accent-hover: #2EA043;     /* accent hover */
        }
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0; 
            background-color: var(--bg-primary); 
            color: var(--text-primary); 
        }
        .glass-nav { 
            background: rgba(13, 17, 23, 0.85); 
            backdrop-filter: blur(10px); 
            -webkit-backdrop-filter: blur(10px); 
            border-bottom: 1px solid var(--border-color); 
        }
        .header { 
            padding: 15px 30px; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
        }
        .header-logo { 
            display: flex; 
            align-items: center; 
            gap: 12px; 
        }
        .header h1 { 
            margin: 0; 
            font-size: 1.5em; 
            font-weight: 700; 
            color: var(--text-primary); 
        }
        .container { 
            padding: 20px; 
            max-width: 1400px; 
            margin: 0 auto; 
        }
        .app-section { 
            background-color: var(--bg-secondary); 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            margin-bottom: 25px; 
        }
        .app-header { 
            padding: 15px 20px; 
            border-bottom: 1px solid var(--border-color); 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            cursor: move; 
        }
        .app-header h2 { 
            margin: 0; 
            font-size: 1.2em; 
        }
        .app-header .status { 
            font-size: 0.9em; 
            color: var(--text-secondary); 
        }
        .app-header .status .online-dot { 
            display: inline-block; 
            width: 8px; 
            height: 8px; 
            background-color: var(--accent-color); 
            border-radius: 50%; 
            margin-right: 6px; 
        }
        .app-content { 
            padding: 20px; 
        }
        .btn { 
            padding: 8px 16px; 
            cursor: pointer; 
            border: 1px solid var(--border-color); 
            background-color: #21262d; 
            color: var(--text-primary); 
            border-radius: 6px; 
            transition: background-color 0.2s; 
            text-decoration: none;
            display: inline-block;
        }
        .btn:hover { 
            background-color: var(--border-color); 
        }
        .btn-primary { 
            background-color: var(--accent-color); 
            border-color: var(--accent-color); 
            color: #fff; 
        }
        .btn-primary:hover { 
            background-color: var(--accent-hover); 
            border-color: var(--accent-hover); 
        }
        .layout-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 20px; 
        }
        .stream-box { 
            border: 1px solid var(--border-color); 
            border-radius: 6px; 
            overflow: hidden; 
            max-width: 100%; 
            position: relative; 
        }
        .stream-box img { 
            width: 100%; 
            height: auto;
            object-fit: cover;
            display: block; 
            background-color: #000; 
        }
        .stream-header, .stream-footer { 
            padding: 7px 9px; 
            background-color: #f9fafb; 
            font-weight: bold; 
        }
        .stream-header { 
            font-size: 0.8em; 
            text-align: left; 
        }
        .stream-footer { 
            font-size: 0.9em; 
            text-align: center; 
        }
        .tab-nav { 
            display: flex; 
            border-bottom: 1px solid var(--border-color); 
            flex-wrap: wrap; 
        }
        .tab-button { 
            padding: 10px 15px; 
            cursor: pointer; 
            background: transparent; 
            color: var(--text-secondary); 
            border: none; 
            border-bottom: 3px solid transparent; 
            font-size: 0.9em; 
        }
        .tab-button.active { 
            border-bottom: 3px solid var(--accent-color); 
            font-weight: bold; 
            color: var(--text-primary); 
        }
        .tab-content { 
            display: none; 
            padding-top: 15px; 
        }
        .tab-content.active { 
            display: block; 
        }
        .module-content {
            display: none;
        }
        .module-content.active {
            display: block;
        }
        .module-template {
            display: none !important;
        }
        #hidden-module-templates {
            display: none !important;
        }
        .channel-controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .channel-selector {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
        }
        .form-input {
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            min-width: 300px;
        }
        .form-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .alerts-section {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }
        .alert-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .alert-gifs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        .alert-gif-card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }
        .alert-gif-card .alert-gif {
            max-width: 100%;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .alert-gif-card .alert-info {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        .alert-gif-card .alert-message {
            font-size: 0.95em;
            color: var(--text-primary);
            margin-bottom: 10px;
            padding: 8px;
            background-color: var(--bg-primary);
            border-radius: 4px;
        }
        .alert-gif-card .alert-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        .gif-preview {
            cursor: pointer;
            position: relative;
        }
        .gif-preview:hover {
            opacity: 0.9;
        }
        .gif-preview img {
            width: 100%;
            height: auto;
            display: block;
        }
        /* Lightbox Modal Styles */
        .lightbox-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
        }
        .lightbox-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .lightbox-content {
            position: relative;
            max-width: 95%;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .lightbox-content img {
            max-width: 100%;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        .lightbox-info {
            margin-top: 20px;
            text-align: center;
            color: white;
            max-width: 800px;
        }
        .lightbox-info #lightbox-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--accent-color);
        }
        .lightbox-info #lightbox-details {
            font-size: 0.95em;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
        }
        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 35px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
            transition: transform 0.2s, color 0.2s;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .lightbox-close:hover {
            transform: rotate(90deg);
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
        }
        .lightbox-prev,
        .lightbox-next {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            z-index: 2001;
            padding: 20px;
            user-select: none;
            transition: all 0.3s;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        .lightbox-prev {
            left: 20px;
        }
        .lightbox-next {
            right: 20px;
        }
        .lightbox-prev:hover,
        .lightbox-next:hover {
            background: rgba(35, 134, 54, 0.3);
            transform: translateY(-50%) scale(1.1);
        }
        @media (max-width: 768px) {
            .lightbox-prev,
            .lightbox-next {
                font-size: 24px;
                padding: 15px;
            }
            .lightbox-prev {
                left: 10px;
            }
            .lightbox-next {
                right: 10px;
            }
            .lightbox-close {
                top: 10px;
                right: 15px;
                font-size: 32px;
            }
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .video-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }
        .pagination-info {
            font-size: 0.9em;
            color: var(--text-secondary);
        }
        .counting-line-controls, .roi-controls {
            display: none;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding: 10px;
            background-color: var(--bg-primary);
            border-radius: 6px;
        }
        .counting-line-controls.active, .roi-controls.active {
            display: flex;
        }
        .btn-group {
            display: flex;
            gap: 5px;
        }
        .btn.selected {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }
        .roi-canvas, .line-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 10;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .roi-canvas.active, .line-canvas.active {
            pointer-events: all;
        }
        #lineCanvas {
            pointer-events: all;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
        }
        .modal-content {
            background-color: var(--bg-secondary);
            margin: 5% auto;
            padding: 25px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 900px;
            border-radius: 8px;
        }
        /* Analytics Details Modal */
        #analyticsDetailsModal {
            display: none;
            position: fixed;
            z-index: 1500;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            align-items: center;
            justify-content: center;
        }
        #analyticsDetailsModal .modal-content {
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        #analyticsDetailsModal .modal-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        #analyticsDetailsModal .modal-icon {
            font-size: 2.5em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #analyticsDetailsModal .modal-icon img {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }
        #analyticsDetailsModal .modal-title {
            font-size: 1.5em;
            font-weight: 700;
            margin: 0;
        }
        #analyticsDetailsModal .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px 10px;
            transition: color 0.2s;
        }
        #analyticsDetailsModal .modal-close:hover {
            color: var(--text-primary);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .modal-header h2 {
            margin: 0;
        }
        .close-btn {
            color: var(--text-secondary);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .status-indicator {
            padding: 4px 8px;
        }
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        .analytics-card {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(35, 134, 54, 0.15) 100%);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 25px;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            text-align: center;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .analytics-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(35, 134, 54, 0.4);
            border-color: var(--accent-color);
        }
        .analytics-card-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 0;
        }
        .analytics-card-icon {
            width: 80px;
            height: 80px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        .analytics-card-icon img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .analytics-card-title {
            font-size: 1.2em;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0;
        }
        .analytics-card-stats {
            display: none; /* Hidden in tile view */
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(48, 54, 61, 0.5);
        }
        .stat-row:last-child {
            border-bottom: none;
        }
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.85em;
        }
        .stat-value {
            color: var(--accent-color);
            font-size: 1.5em;
            font-weight: 700;
        }
        .stat-value.large {
            font-size: 2em;
        }
        .analytics-card-footer {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .channel-count {
            color: var(--text-secondary);
            font-size: 0.85em;
        }
        .view-live-btn {
            background-color: var(--accent-color);
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        .view-live-btn:hover {
            background-color: var(--accent-hover);
            transform: scale(1.05);
        }
        .loading-spinner {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        .status-indicator-badge {
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }
        .status-online {
            background-color: rgba(35, 134, 54, 0.2);
            color: #2ea043;
        }
        .status-offline {
            background-color: rgba(248, 113, 113, 0.2);
            color: #f87171;
        }
        .hidden {
            display: none !important;
        }
        @media (max-width: 768px) { 
            .layout-grid { 
                grid-template-columns: 1fr; 
            }
            .video-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body class="antialiased">

<header class="glass-nav sticky top-0 z-50">
    <div class="header max-w-[1400px] mx-auto">
        <div class="header-logo">
            <img src="/static/images/sakshi-logo.png" alt="Sakshi.AI Logo" style="height: 50px; width: auto; object-fit: contain;">
        </div>
        <div style="display: flex; align-items: center; gap: 20px;">
            <span style="color: var(--text-secondary); font-size: 0.9em;">
                üë§ <strong style="color: var(--text-primary);" id="username-display">{{ user.username }}</strong>
            </span>
            <a href="/logout" style="color: #ef4444; font-size: 0.9em; text-decoration: none; font-weight: 600;">üö™ Logout</a>
        </div>
    </div>
</header>

<div class="container" id="dashboard-container">
    <!-- Analytics Overview Cards -->
    <div class="app-section">
        <div class="app-header">
            <h2>üìä Analytics Dashboard</h2>
            <div class="status">
                <span class="online-dot"></span>
                <span>All Services Online</span>
                <span style="margin-left: 15px; font-size: 0.85em; color: var(--text-secondary);" id="analytics-refresh-status">
                    Last updated: Just now
                </span>
            </div>
        </div>
        <div class="app-content">
            <div class="analytics-grid" id="analytics-cards">
                <!-- Analytics cards will be loaded here dynamically -->
            </div>
        </div>
    </div>

    <!-- Analytics Details Modal -->
    <div id="analyticsDetailsModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeAnalyticsDetails()">&times;</button>
            <div class="modal-header">
                <div id="analyticsDetailsIcon" class="modal-icon"></div>
                <h2 id="analyticsDetailsTitle" class="modal-title"></h2>
            </div>
            <div id="analyticsDetailsStats" class="analytics-card-stats" style="display: block; margin: 20px 0;"></div>
            <div id="analyticsDetailsFooter" class="analytics-card-footer"></div>
        </div>
    </div>

    <!-- Live Monitoring Modal (Hidden by default) -->
    <div id="liveMonitoringModal" class="modal">
        <div class="modal-content" style="max-width: 95%; height: 90vh;">
            <div class="modal-header">
                <h2 id="modalModuleTitle">Live Monitoring</h2>
                <span class="close-btn" onclick="closeLiveMonitoring()">&times;</span>
            </div>
            <div id="modalModuleContent" style="height: calc(100% - 80px); overflow-y: auto;">
                <!-- Live monitoring content will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Hidden Module Content Templates -->
    <div style="display: none !important;" id="hidden-module-templates">
        <!-- Queue Monitor Template -->
        <div id="QueueMonitor-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'QueueMonitor-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'QueueMonitor-reports')">Analytics & Reports</button>
            </div>
            
            <div id="QueueMonitor-live" class="tab-content active">
                <div id="qm-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="qm-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('QueueMonitor', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="qm-page-info">Page 1 of 1</span> 
                        (Showing <span id="qm-showing-count">0</span> of <span id="qm-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('QueueMonitor', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="QueueMonitor-reports" class="tab-content">
                <h3>Queue Analytics & Alert History</h3>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üö® Recent Alert Recordings</h4>
                    <div class="alert-controls">
                        <select id="alert-channel-filter" class="channel-selector">
                            <option value="">All Channels</option>
                        </select>
                        <button class="btn" onclick="loadQueueViolations()">üîÑ Refresh Violations</button>
                        <button class="btn" onclick="clearOldQueueViolations()">üóëÔ∏è Clear Old Violations</button>
                    </div>
                    
                    <div id="queue-violations-grid" class="alert-gifs-grid">
                        <!-- Queue violations will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- People Counter Template -->
      <!--  <div id="PeopleCounter-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'PeopleCounter-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'PeopleCounter-reports')">Analytics & Reports</button>
            </div>
            
            <div id="PeopleCounter-live" class="tab-content active">
                <div id="pc-video-grid" class="video-grid"> -->
                    <!-- Video streams will be added here dynamically -->
                <!-- </div>
                <div id="pc-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('PeopleCounter', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="pc-page-info">Page 1 of 1</span> 
                        (Showing <span id="pc-showing-count">0</span> of <span id="pc-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('PeopleCounter', 1)">Next ‚ñ∂</button>
                </div>
            </div>
        
            <div id="PeopleCounter-reports" class="tab-content">
                <h3>Footfall Analytics & Reports</h3>
                
                <div style="margin-bottom: 20px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <div>
                        <label for="pc-report-period" style="margin-right: 8px; font-weight: 500;">Period:</label>
                        <select id="pc-report-period" class="channel-selector">
                            <option value="24hours">Last 24 Hours (Hourly)</option>
                            <option value="7days" selected>Last 7 Days</option>
                            <option value="30days">Last 30 Days</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-primary" onclick="loadFootfallReport()">üìä Load Report</button>
                    <button class="btn" onclick="refreshFootfallReport()">üîÑ Refresh</button>
                </div>
                
                <div id="pc-reports-content" style="min-height: 300px;">
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        <p>üëÜ Click "Load Report" to view analytics</p>
                    </div>
                </div>
                
                <div id="pc-chart-container" style="display: none; margin-top: 30px;">
                    <canvas id="pc-footfall-chart" style="max-height: 400px;"></canvas>
                </div>
            </div>
        </div>

    <!--    <!-- Bag Detection Template -->
     <!--   <div id="BagDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'BagDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'BagDetection-reports')">Analytics & Reports</button>
            </div>
            
            <div id="BagDetection-live" class="tab-content active">
                <div id="bd-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                <!-- </div>
                <div id="bd-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('BagDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="bd-page-info">Page 1 of 1</span> 
                        (Showing <span id="bd-showing-count">0</span> of <span id="bd-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('BagDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="BagDetection-reports" class="tab-content">
                <h3>Unattended Bag Alerts & Reports</h3>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üéí Recent Bag Alerts</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadBagAlerts()">üîÑ Refresh Alerts</button>
                    </div>
                    <div id="bag-alerts-grid" class="alert-gifs-grid">
                        <!-- Bag alerts will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Heatmap Template -->
    <!--    <div id="Heatmap-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'Heatmap-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'Heatmap-reports')">Analytics & Reports</button>
            </div>
            
            <div id="Heatmap-live" class="tab-content active">
                <div id="hm-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
             <!--   <div id="hm-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('Heatmap', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="hm-page-info">Page 1 of 1</span> 
                        (Showing <span id="hm-showing-count">0</span> of <span id="hm-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('Heatmap', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="Heatmap-reports" class="tab-content">
                <h3>Heatmap Analytics & Snapshots</h3>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üî• Recent Heatmap Snapshots</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadHeatmapSnapshots()">üîÑ Refresh Snapshots</button>
                    </div>
                    <div id="heatmap-snapshots-grid" class="alert-gifs-grid">
                        <!-- Heatmap snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Cash Detection Template -->
        <div id="CashDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'CashDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'CashDetection-reports')">Analytics & Reports</button>
            </div>
            
            <div id="CashDetection-live" class="tab-content active">
                <div id="cd-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="cd-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('CashDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="cd-page-info">Page 1 of 1</span> 
                        (Showing <span id="cd-showing-count">0</span> of <span id="cd-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('CashDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="CashDetection-reports" class="tab-content">
                <h3>Cash Detection Analytics & Alerts</h3>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üí∞ Recent Cash Detection Snapshots</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadCashSnapshots()">üîÑ Refresh Snapshots</button>
                        <button class="btn" onclick="exportCashDetectionExcel(event)" style="background: linear-gradient(135deg, #238636 0%, #2EA043 100%); color: white; border: none;">
                            üìä Download Excel Summary
                        </button>
                    </div>
                    <div id="cash-snapshots-grid" class="alert-gifs-grid">
                        <!-- Cash snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Fall Detection Template -->
    <!--    <div id="FallDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'FallDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'FallDetection-reports')">Analytics & Reports</button>
            </div>
            
            <div id="FallDetection-live" class="tab-content active">
                <div id="fd-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
            <!--   <div id="fd-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('FallDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="fd-page-info">Page 1 of 1</span> 
                        (Showing <span id="fd-showing-count">0</span> of <span id="fd-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('FallDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="FallDetection-reports" class="tab-content">
                <h3>Fall Detection Analytics & Alerts</h3>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üöë Recent Fall Detection Snapshots</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadFallSnapshots()">üîÑ Refresh Snapshots</button>
                    </div>
                    <div id="fall-snapshots-grid" class="alert-gifs-grid">
                        <!-- Fall snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Dress Code Monitoring Template (analytics only) -->
       <div id="DressCodeMonitoring-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'DressCodeMonitoring-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'DressCodeMonitoring-reports')">Violation Reports</button>
            </div>
        
            <div id="DressCodeMonitoring-live" class="tab-content active">
                <div id="dcm-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="dcm-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('DressCodeMonitoring', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="dcm-page-info">Page 1 of 1</span> 
                        (Showing <span id="dcm-showing-count">0</span> of <span id="dcm-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('DressCodeMonitoring', 1)">Next ‚ñ∂</button>
                </div>
            </div>
        
            <div id="DressCodeMonitoring-reports" class="tab-content">
                <h3>üëî Dress Code Compliance Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="dcm-total-violations">0</div>
                        <div class="stat-label">Total Violations (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="dcm-compliance-rate">100%</div>
                        <div class="stat-label">Compliance Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="dcm-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üëî Recent Dress Code Violations</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadDressCodeAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn" onclick="clearOldDressCodeAlerts()">üóëÔ∏è Clear Old Alerts</button>
                    </div>
                    <div id="dresscode-alerts-grid" class="alert-gifs-grid">
                        <!-- Dress code violation snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Table Cleanliness Monitor Template -->
        <div id="TableServiceMonitor-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'TableServiceMonitor-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'TableServiceMonitor-reports')">Violation Reports</button>
            </div>
        
            <div id="TableServiceMonitor-live" class="tab-content active">
                <div id="tsm-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="tsm-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('TableServiceMonitor', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="tsm-page-info">Page 1 of 1</span> 
                        (Showing <span id="tsm-showing-count">0</span> of <span id="tsm-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('TableServiceMonitor', 1)">Next ‚ñ∂</button>
                </div>
            </div>
        
            <div id="TableServiceMonitor-reports" class="tab-content">
                <h3>üßπ Table Cleanliness Violation Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="tsm-total-violations">0</div>
                        <div class="stat-label">Total Violations (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="tsm-avg-unclean-time">0.0 min</div>
                        <div class="stat-label">Avg Unclean Time (7d)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="tsm-max-unclean-time">0.0 min</div>
                        <div class="stat-label">Max Unclean Time (7d)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="tsm-avg-reset-time">0.0 min</div>
                        <div class="stat-label">Avg Reset Time (7d)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="tsm-max-reset-time">0.0 min</div>
                        <div class="stat-label">Max Reset Time (7d)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="tsm-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üçΩÔ∏è Recent Table Service Violations</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadTableServiceViolations()">üîÑ Refresh Violations</button>
                        <button class="btn" onclick="clearOldTableServiceViolations()">üóëÔ∏è Clear Old Violations</button>
                    </div>
                    <div id="table-service-violations-grid" class="alert-gifs-grid">
                        <!-- Table service violation snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Unauthorized Entry Monitor Template -->
        <div id="UnauthorizedEntryMonitor-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'UnauthorizedEntryMonitor-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'UnauthorizedEntryMonitor-reports')">Alert History</button>
            </div>

            <div id="UnauthorizedEntryMonitor-live" class="tab-content active">
                <div id="uem-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="uem-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('UnauthorizedEntryMonitor', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="uem-page-info">Page 1 of 1</span> 
                        (Showing <span id="uem-showing-count">0</span> of <span id="uem-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('UnauthorizedEntryMonitor', 1)">Next ‚ñ∂</button>
                </div>
            </div>

            <div id="UnauthorizedEntryMonitor-reports" class="tab-content">
                <h3>üö® Unauthorized Entry Alert History</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="uem-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="uem-today-alerts">0</div>
                        <div class="stat-label">Today's Alerts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="uem-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üö® Recent Unauthorized Entry Alerts</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadUnauthorizedEntryAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn" onclick="exportUnauthorizedEntryExcel()">üìä Export Excel Report</button>
                        <button class="btn" onclick="clearOldUnauthorizedEntryAlerts()">üóëÔ∏è Clear Old Alerts (7+ days)</button>
                    </div>
                    <div id="unauthorized-entry-alerts-grid" class="alert-gifs-grid">
                        <!-- Unauthorized entry alert GIFs will be loaded here -->
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading alert history...
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Service Discipline Template -->
        <div id="ServiceDisciplineMonitor-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'ServiceDisciplineMonitor-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'ServiceDisciplineMonitor-reports')">Reports</button>
            </div>

            <div id="ServiceDisciplineMonitor-live" class="tab-content active">
                <div style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px;">
                    <button class="btn btn-primary" onclick="openServiceDisciplineRoiModal()">‚öôÔ∏è Configure Table ROIs</button>
                    <span style="margin-left: 10px; color: var(--text-secondary); font-size: 0.9em;">
                        Click to configure table regions for service discipline monitoring
                    </span>
                </div>
                <div id="sdm-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="sdm-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('ServiceDisciplineMonitor', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="sdm-page-info">Page 1 of 1</span> 
                        (Showing <span id="sdm-showing-count">0</span> of <span id="sdm-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('ServiceDisciplineMonitor', 1)">Next ‚ñ∂</button>
                </div>
            </div>

            <div id="ServiceDisciplineMonitor-reports" class="tab-content">
                <h3>üïí Service Discipline Reports</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="sdm-max-order-wait">0.0 min</div>
                        <div class="stat-label">Max Order Wait (7d)</div>
                        <div class="stat-description" style="font-size: 0.75em; color: var(--text-secondary); margin-top: 4px;">Time to collect order</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="sdm-max-service-wait">0.0 min</div>
                        <div class="stat-label">Max Service Wait (7d)</div>
                        <div class="stat-description" style="font-size: 0.75em; color: var(--text-secondary); margin-top: 4px;">Time to deliver food</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="sdm-max-wait">0.0 min</div>
                        <div class="stat-label">Max Total Wait (7d)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="sdm-alerts-7d">0</div>
                        <div class="stat-label">Alerts (7d)</div>
                    </div>
                </div>
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üïí Recent Service Discipline Alerts</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadServiceDisciplineAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn btn-danger" onclick="clearAllServiceDisciplineData()" style="margin-left: 10px;">üóëÔ∏è Clear All Data</button>
                    </div>
                    <div id="service-discipline-alerts-grid" class="alert-gifs-grid">
                        <!-- Service discipline alerts will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- PPE Monitoring Template -->
        <div id="PPEMonitoring-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'PPEMonitoring-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'PPEMonitoring-reports')">Violation Reports</button>
            </div>
        
            <div id="PPEMonitoring-live" class="tab-content active">
                <div id="ppe-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="ppe-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('PPEMonitoring', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="ppe-page-info">Page 1 of 1</span> 
                        (Showing <span id="ppe-showing-count">0</span> of <span id="ppe-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('PPEMonitoring', 1)">Next ‚ñ∂</button>
                </div>
            </div>
        
            <div id="PPEMonitoring-reports" class="tab-content">
                <h3>üõ°Ô∏è PPE Compliance Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="ppe-total-alerts">0</div>
                        <div class="stat-label">Total Alerts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="ppe-today-alerts">0</div>
                        <div class="stat-label">Today's Alerts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="ppe-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üõ°Ô∏è Recent PPE Violations</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadPPEAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn" onclick="clearOldPPEAlerts()">üóëÔ∏è Clear Old Alerts</button>
                    </div>
                    <div id="ppe-alerts-grid" class="alert-gifs-grid">
                        <!-- PPE violation snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Mopping Detection Template -->
   <!--     <div id="MoppingDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'MoppingDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'MoppingDetection-reports')">Detection History</button>
            </div>
            
            <div id="MoppingDetection-live" class="tab-content active">
                <div id="mopping-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
          <!--<div id="mopping-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('MoppingDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="mopping-page-info">Page 1 of 1</span> 
                        (Showing <span id="mopping-showing-count">0</span> of <span id="mopping-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('MoppingDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="MoppingDetection-reports" class="tab-content">
                <h3>üßπ Mopping Activity Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="mopping-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="mopping-total-detections">0</div>
                        <div class="stat-label">Total Detections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="mopping-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üßπ Recent Mopping Detections</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadMoppingSnapshots()">üîÑ Refresh Snapshots</button>
                        <button class="btn" onclick="clearOldMoppingSnapshots()">üóëÔ∏è Clear Old Snapshots</button>
                    </div>
                    <div id="mopping-snapshots-grid" class="alert-gifs-grid">
                        <!-- Mopping detection snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Smoking Detection Template (analytics only) -->
        <div id="SmokingDetection-template" class="module-template">
            <h3 class="analytics-card-title" style="display: none;">Smoke & Fire Detection</h3>
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'SmokingDetection-reports')">Detection History</button>
            </div>
            
            <div id="SmokingDetection-reports" class="tab-content active">
                <h3>Smoke & Fire Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="smoking-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="smoking-total-detections">0</div>
                        <div class="stat-label">Total Detections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="smoking-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üî• Recent Smoke & Fire Detections</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadSmokingSnapshots()">üîÑ Refresh Snapshots</button>
                        <button class="btn" onclick="clearOldSmokingSnapshots()">üóëÔ∏è Clear Old Snapshots</button>
                    </div>
                    <div id="smoking-snapshots-grid" class="alert-gifs-grid">
                        <!-- Smoke & Fire detection snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Smoking Detection Template -->
        <div id="PersonSmokingDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'PersonSmokingDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'PersonSmokingDetection-reports')">Alert History</button>
            </div>
            
            <div id="PersonSmokingDetection-live" class="tab-content active">
                <div id="psmoking-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="psmoking-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('PersonSmokingDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="psmoking-page-info">Page 1 of 1</span> 
                        (Showing <span id="psmoking-showing-count">0</span> of <span id="psmoking-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('PersonSmokingDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="PersonSmokingDetection-reports" class="tab-content">
                <h3>üö¨ Person Smoking Detection Alert History</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="psmoking-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="psmoking-today-alerts">0</div>
                        <div class="stat-label">Today's Alerts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="psmoking-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üö¨ Recent Smoking Alerts</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadPersonSmokingAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn" onclick="clearOldPersonSmokingAlerts()">üóëÔ∏è Clear Old Alerts (7+ days)</button>
                    </div>
                    <div id="person-smoking-alerts-grid" class="alert-gifs-grid">
                        <!-- Smoking alert GIFs will be loaded here -->
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading alert history...
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Material Theft / Misuse Template -->
        <div id="MaterialTheftMonitor-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'MaterialTheftMonitor-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'MaterialTheftMonitor-reports')">Alert History</button>
            </div>
            
            <div id="MaterialTheftMonitor-live" class="tab-content active">
                <div style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px;">
                    <button class="btn" onclick="openMaterialTheftRoiModal()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        üìê Configure Monitoring Area (ROI)
                    </button>
                    <span style="margin-left: 10px; color: var(--text-secondary); font-size: 0.9em;">
                        Click to draw the monitoring area around the weighing machine
                    </span>
                </div>
                <div id="mtm-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="mtm-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('MaterialTheftMonitor', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="mtm-page-info">Page 1 of 1</span> 
                        (Showing <span id="mtm-showing-count">0</span> of <span id="mtm-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('MaterialTheftMonitor', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="MaterialTheftMonitor-reports" class="tab-content">
                <h3>üì¶ Material Theft / Misuse Alerts</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="mtm-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="mtm-today-alerts">0</div>
                        <div class="stat-label">Today's Alerts</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="mtm-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üì¶ Recent Material Theft Alerts</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadMaterialTheftAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn" onclick="clearOldMaterialTheftAlerts()">üóëÔ∏è Clear Old Alerts (7+ days)</button>
                    </div>
                    <div id="mtm-alerts-grid" class="alert-gifs-grid">
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading alert history...
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Crowd Detection Template -->
        <div id="CrowdDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'CrowdDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'CrowdDetection-reports')">Detection History</button>
            </div>
            
            <div id="CrowdDetection-live" class="tab-content active">
                <div style="margin-bottom: 15px;">
                    <button class="btn btn-primary" onclick="openCrowdRoiModal()">‚öôÔ∏è Configure ROI</button>
                </div>
                <div id="crowd-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
                <div id="crowd-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('CrowdDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="crowd-page-info">Page 1 of 1</span> 
                        (Showing <span id="crowd-showing-count">0</span> of <span id="crowd-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('CrowdDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="CrowdDetection-reports" class="tab-content">
                <h3>üë• Crowd Detection Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="crowd-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="crowd-current-crowd">0</div>
                        <div class="stat-label">Current Crowd</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="crowd-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üë• Recent Crowd Alerts</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadCrowdAlerts()">üîÑ Refresh Alerts</button>
                        <button class="btn" onclick="clearOldCrowdAlerts()">üóëÔ∏è Clear Old Alerts</button>
                    </div>
                    <div id="crowd-alerts-grid" class="alert-gifs-grid">
                        <!-- Crowd detection alert GIFs will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Phone Usage Detection Template -->
   <!--     <div id="PhoneUsageDetection-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'PhoneUsageDetection-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'PhoneUsageDetection-reports')">Detection History</button>
            </div>
            
            <div id="PhoneUsageDetection-live" class="tab-content active">
                <div id="phone-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
        <!--        <div id="phone-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('PhoneUsageDetection', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="phone-page-info">Page 1 of 1</span> 
                        (Showing <span id="phone-showing-count">0</span> of <span id="phone-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('PhoneUsageDetection', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="PhoneUsageDetection-reports" class="tab-content">
                <h3>üì± Phone Usage Detection Reports</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="phone-total-alerts">0</div>
                        <div class="stat-label">Total Alerts (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="phone-total-detections">0</div>
                        <div class="stat-label">Total Detections</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="phone-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üì± Recent Phone Usage Detections</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadPhoneSnapshots()">üîÑ Refresh Snapshots</button>
                        <button class="btn" onclick="clearOldPhoneSnapshots()">üóëÔ∏è Clear Old Snapshots</button>
                    </div>
                    <div id="phone-snapshots-grid" class="alert-gifs-grid">
                        <!-- Phone detection snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Restricted Area Monitor Template -->
    <!--    <div id="RestrictedAreaMonitor-template" class="module-template">
            <div class="tab-nav">
                <button class="tab-button active" onclick="switchLiveTab(event, 'RestrictedAreaMonitor-live')">Live Monitoring</button>
                <button class="tab-button" onclick="switchLiveTab(event, 'RestrictedAreaMonitor-reports')">Violation Reports</button>
            </div>
            
            <div id="RestrictedAreaMonitor-live" class="tab-content active">
                <div id="restricted-video-grid" class="video-grid">
                    <!-- Video streams will be added here dynamically -->
                </div>
          <!--      <div id="restricted-video-pagination" class="video-pagination" style="display: none;">
                    <button class="btn" onclick="changeVideoPage('RestrictedAreaMonitor', -1)">‚óÄ Previous</button>
                    <span class="pagination-info">
                        <span id="restricted-page-info">Page 1 of 1</span> 
                        (Showing <span id="restricted-showing-count">0</span> of <span id="restricted-total-count">0</span> channels)
                    </span>
                    <button class="btn" onclick="changeVideoPage('RestrictedAreaMonitor', 1)">Next ‚ñ∂</button>
                </div>
            </div>
            
            <div id="RestrictedAreaMonitor-reports" class="tab-content">
                <h3>üö® Restricted Area Violations</h3>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="restricted-total-alerts">0</div>
                        <div class="stat-label">Total Violations (7 days)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="restricted-unauthorized-entries">0</div>
                        <div class="stat-label">Unauthorized Entries</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="restricted-active-channels">0</div>
                        <div class="stat-label">Active Channels</div>
                    </div>
                </div>
                
                <div class="alerts-section" style="margin-top: 30px;">
                    <h4>üö® Recent Violations</h4>
                    <div class="alert-controls">
                        <button class="btn" onclick="loadRestrictedAreaSnapshots()">üîÑ Refresh</button>
                        <button class="btn" onclick="clearOldRestrictedAreaSnapshots()">üóëÔ∏è Clear Old Snapshots</button>
                    </div>
                    <div id="restricted-snapshots-grid" class="alert-gifs-grid">
                        <!-- Violation snapshots will be loaded here -->
                    </div>
                </div>
            </div>
        </div>

    </div>
    <!-- Original Module Content (kept for backwards compatibility) -->
 <!--   <div style="display: none;" id="original-modules">
        <!-- People Counter Module -->
      <!--  <div id="PeopleCounter-module" class="module-content">
            <div class="tab-nav">
                <button class="tab-button active" onclick="openTab(event, 'PeopleCounter')">Live Monitoring</button>
                <button class="tab-button" onclick="openTab(event, 'PeopleCounterReports')">Analytics & Reports</button>
            </div>
                
                <div id="QueueMonitor" class="tab-content active">
                    <!-- Channel controls removed - channels auto-load from config -->
                    
           <!--         <div id="qm-video-grid" class="video-grid">
                        <!-- Video streams will be added here dynamically -->
                    </div>
         <!--          <div id="qm-video-pagination" class="video-pagination" style="display: none;">
                        <button class="btn" onclick="changeVideoPage('QueueMonitor', -1)">‚óÄ Previous</button>
                        <span class="pagination-info">
                            <span id="qm-page-info">Page 1 of 1</span> 
                            (Showing <span id="qm-showing-count">0</span> of <span id="qm-total-count">0</span> channels)
                        </span>
                        <button class="btn" onclick="changeVideoPage('QueueMonitor', 1)">Next ‚ñ∂</button>
                    </div>
                </div>
                
                <div id="QueueMonitorReports" class="tab-content">
                    <h3>Queue Analytics & Alert History</h3>
                    <p>Select a channel to view queue performance and alerts.</p>
                    
                    <!-- Alert GIFs Section -->
                 <!--   <div class="alerts-section" style="margin-top: 30px;">
                        <h4>üö® Recent Alert Recordings</h4>
                        <div class="alert-controls">
                            <select id="alert-channel-filter" class="channel-selector">
                                <option value="">All Channels</option>
                            </select>
                            <button class="btn" onclick="loadQueueViolations()">üîÑ Refresh Violations</button>
                            <button class="btn" onclick="clearOldQueueViolations()">üóëÔ∏è Clear Old Violations</button>
                        </div>
                        
                        <div id="queue-violations-grid" class="alert-gifs-grid">
                            <!-- Queue violations will be loaded here -->
                        </div>
                    </div>
                    
                    <div id="qm-reports-content">
                        <!-- Reports content will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Bag Detection Module -->
            <div id="BagDetection-module" class="module-content">
                <div class="tab-nav" style="border-top: 1px solid var(--border-color); padding-top: 10px;">
                    <button class="tab-button active" onclick="openTab(event, 'BagDetection')">Live Monitoring</button>
                    <button class="tab-button" onclick="openTab(event, 'BagDetectionReports')">Analytics & Alerts</button>
                    <button class="tab-button" onclick="openTab(event, 'BagDetectionSettings')">Settings</button>
                </div>
                
                <div id="BagDetection" class="tab-content active">
                    <!-- Channel controls removed - channels auto-load from config -->
                    
                    <div class="info-box" style="margin: 20px 0;">
                        <strong>‚ÑπÔ∏è Unattended Baggage Detection:</strong>
                        <ul style="margin: 10px 0 0 20px; font-size: 0.9em;">
                            <li>Detects bags (backpack, handbag, suitcase) and tracks their movement</li>
                            <li>Identifies bags left stationary without nearby owners for extended periods</li>
                            <li>Automatically records 4-second GIF when unattended bag is detected</li>
                            <li>Alerts shown in real-time with bag location and duration</li>
                            <li>Adjustable proximity threshold, time threshold, and alert cooldown</li>
                        </ul>
                    </div>
                    
                    <div id="bd-video-grid" class="video-grid">
                        <!-- Video streams will be added here dynamically -->
                    </div>
                    <div id="bd-video-pagination" class="video-pagination" style="display: none;">
                        <button class="btn" onclick="changeVideoPage('BagDetection', -1)">‚óÄ Previous</button>
                        <span class="pagination-info">
                            <span id="bd-page-info">Page 1 of 1</span> 
                            (Showing <span id="bd-showing-count">0</span> of <span id="bd-total-count">0</span> channels)
                        </span>
                        <button class="btn" onclick="changeVideoPage('BagDetection', 1)">Next ‚ñ∂</button>
                    </div>
                </div>
                
                <div id="BagDetectionReports" class="tab-content">
                    <h3>Unattended Baggage Alerts - All Channels</h3>
                    
                    <div class="filter-controls" style="margin-bottom: 20px;">
                        <button class="btn" onclick="loadBagAlerts()">üîÑ Refresh</button>
                        <button class="btn" onclick="clearOldBagAlerts()">üóëÔ∏è Clear Old Alerts (7+ days)</button>
                    </div>
                    
                    <div id="bag-alerts-grid" class="alert-gifs-grid">
                        <!-- Alert GIFs will be displayed here -->
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading alerts...
                        </p>
                    </div>
                </div>
                
                <div id="BagDetectionSettings" class="tab-content">
                    <h3>Detection Settings</h3>
                    <div style="max-width: 600px;">
                        <div class="setting-group">
                            <label><strong>Time Threshold (seconds):</strong></label>
                            <input type="number" id="bd-time-threshold" value="20" min="5" max="300" step="5" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Minimum time a bag must be stationary to trigger alert</small>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 20px;">
                            <label><strong>Proximity Threshold (pixels):</strong></label>
                            <input type="number" id="bd-proximity-threshold" value="120" min="50" max="300" step="10" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Maximum distance between bag and person to consider them together</small>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 20px;">
                            <label><strong>Alert Cooldown (seconds):</strong></label>
                            <input type="number" id="bd-alert-cooldown" value="60" min="30" max="300" step="10" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Minimum time between repeated alerts for the same bag</small>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 20px;">
                            <label><strong>Confidence Threshold:</strong></label>
                            <input type="number" id="bd-confidence" value="0.35" min="0.1" max="0.9" step="0.05" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Minimum detection confidence (lower = more detections but more false positives)</small>
                        </div>
                        
                        <button class="btn btn-primary" onclick="saveBagSettings()" style="margin-top: 20px;">Save Settings</button>
                    </div>
                </div>
            </div>

            <!-- Heatmap Module -->
            <div id="Heatmap-module" class="module-content">
                <div class="tab-nav" style="border-top: 1px solid var(--border-color); padding-top: 10px;">
                    <button class="tab-button active" onclick="openTab(event, 'Heatmap')">Live Heatmap</button>
                    <button class="tab-button" onclick="openTab(event, 'HeatmapSnapshots')">Snapshots</button>
                    <button class="tab-button" onclick="openTab(event, 'HeatmapSettings')">Settings</button>
                </div>
            
                <div id="Heatmap" class="tab-content active">
                    <!-- Channel controls removed - channels auto-load from config -->
                    
                    <div class="info-box" style="margin: 20px 0;">
                        <strong>‚ÑπÔ∏è Activity Heatmap:</strong>
                        <ul style="margin: 10px 0 0 20px; font-size: 0.9em;">
                            <li>Visualizes movement patterns and high-activity zones</li>
                            <li>Warmer colors (red/yellow) indicate higher activity areas</li>
                            <li>Cooler colors (blue/green) indicate lower activity areas</li>
                            <li>Automatic snapshots saved every 30 seconds</li>
                            <li>Useful for analyzing customer behavior and traffic patterns</li>
                        </ul>
                    </div>
                    
                    <div id="hm-video-grid" class="video-grid">
                        <!-- Video streams will be added here dynamically -->
                    </div>
                    <div id="hm-video-pagination" class="video-pagination" style="display: none;">
                        <button class="btn" onclick="changeVideoPage('Heatmap', -1)">‚óÄ Previous</button>
                        <span class="pagination-info">
                            <span id="hm-page-info">Page 1 of 1</span> 
                            (Showing <span id="hm-showing-count">0</span> of <span id="hm-total-count">0</span> channels)
                        </span>
                        <button class="btn" onclick="changeVideoPage('Heatmap', 1)">Next ‚ñ∂</button>
                    </div>
                </div>
                
                <div id="HeatmapSnapshots" class="tab-content">
                    <h3>Heatmap Snapshots - All Channels</h3>
                    
                    <div class="filter-controls" style="margin-bottom: 20px;">
                        <button class="btn" onclick="loadHeatmapSnapshots()">üîÑ Refresh</button>
                        <button class="btn" onclick="clearOldHeatmapSnapshots()">üóëÔ∏è Clear Old Snapshots (7+ days)</button>
                    </div>
                    
                    <div id="heatmap-snapshots-grid" class="alert-gifs-grid">
                        <!-- Heatmap snapshots will be displayed here -->
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading snapshots...
                        </p>
                    </div>
                </div>
                
                <div id="HeatmapSettings" class="tab-content">
                    <h3>Heatmap Configuration</h3>
                    <div style="max-width: 600px;">
                        <div class="setting-group">
                            <label><strong>Decay Rate:</strong></label>
                            <input type="number" id="hm-decay-rate" value="0.95" min="0.8" max="0.99" step="0.01" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>How quickly the heatmap fades (higher = slower fade)</small>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 20px;">
                            <label><strong>Snapshot Interval (seconds):</strong></label>
                            <input type="number" id="hm-snapshot-interval" value="30" min="10" max="300" step="10" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Time between automatic snapshots</small>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 20px;">
                            <label><strong>Heatmap Intensity:</strong></label>
                            <input type="number" id="hm-intensity" value="0.6" min="0.3" max="1.0" step="0.1" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Opacity of heatmap overlay on video</small>
                        </div>
                        
                        <button class="btn btn-primary" onclick="saveHeatmapSettings()" style="margin-top: 20px;">Save Settings</button>
                    </div>
                </div>
            </div>

            <!-- Cash Detection Module -->
            <div id="CashDetection-module" class="module-content">
                <div class="tab-nav" style="border-top: 1px solid var(--border-color); padding-top: 10px;">
                    <button class="tab-button active" onclick="openTab(event, 'CashDetection')">Live Detection</button>
                    <button class="tab-button" onclick="openTab(event, 'CashDetectionSnapshots')">Detection History</button>
                    <button class="tab-button" onclick="openTab(event, 'CashDetectionSettings')">Settings</button>
                </div>
                
                <div id="CashDetection" class="tab-content active">
                    <!-- Channel controls removed - channels auto-load from config -->
                    
                    <div class="info-box" style="margin: 20px 0;">
                        <strong>‚ÑπÔ∏è Cash Detection:</strong>
                        <ul style="margin: 10px 0 0 20px; font-size: 0.9em;">
                            <li>Automatically detects cash/money in video frames using AI</li>
                            <li>Captures snapshot immediately when cash is detected</li>
                            <li>Triggers real-time alerts with detection confidence</li>
                            <li>Stores detection history with timestamps for audit trail</li>
                            <li>Configurable detection threshold and alert cooldown period</li>
                        </ul>
                    </div>
                    
                    <div id="cd-video-grid" class="video-grid">
                        <!-- Video streams will be added here dynamically -->
                    </div>
                    <div id="cd-video-pagination" class="video-pagination" style="display: none;">
                        <button class="btn" onclick="changeVideoPage('CashDetection', -1)">‚óÄ Previous</button>
                        <span class="pagination-info">
                            <span id="cd-page-info">Page 1 of 1</span> 
                            (Showing <span id="cd-showing-count">0</span> of <span id="cd-total-count">0</span> channels)
                        </span>
                        <button class="btn" onclick="changeVideoPage('CashDetection', 1)">Next ‚ñ∂</button>
                    </div>
                </div>
                
                <div id="CashDetectionSnapshots" class="tab-content">
                    <h3>üíµ Cash Detection History - All Channels</h3>
                    
                    <div class="filter-controls" style="margin-bottom: 20px;">
                        <button class="btn" onclick="loadCashSnapshots()">üîÑ Refresh</button>
                        <button class="btn" onclick="clearOldCashSnapshots()">üóëÔ∏è Clear Old Snapshots (7+ days)</button>
                    </div>
                    
                    <div id="cash-snapshots-grid" class="alert-gifs-grid">
                        <!-- Cash snapshots will be displayed here -->
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading detection history...
                        </p>
                    </div>
                </div>
                
                <div id="CashDetectionSettings" class="tab-content">
                    <h3>Detection Configuration</h3>
                    <div style="max-width: 600px;">
                        <div class="setting-group">
                            <label><strong>Confidence Threshold:</strong></label>
                            <input type="number" id="cd-confidence" value="0.50" min="0.1" max="0.95" step="0.05" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Minimum confidence for cash detection (higher = fewer false positives)</small>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 20px;">
                            <label><strong>Alert Cooldown (seconds):</strong></label>
                            <input type="number" id="cd-alert-cooldown" value="10" min="5" max="60" step="5" style="width: 100%; padding: 8px; margin-top: 5px;">
                            <small>Minimum time between consecutive alerts</small>
                        </div>
                        
                        <button class="btn btn-primary" onclick="saveCashDetectionSettings()" style="margin-top: 20px;">Save Settings</button>
                    </div>
                </div>
            </div>

            <!-- Fall Detection Module -->
            <div id="FallDetection-module" class="module-content">
                <div class="tab-nav" style="border-top: 1px solid var(--border-color); padding-top: 10px;">
                    <button class="tab-button active" onclick="openTab(event, 'FallDetection')">Live Detection</button>
                    <button class="tab-button" onclick="openTab(event, 'FallDetectionSnapshots')">Detection History</button>
                </div>
                
                <div id="FallDetection" class="tab-content active">
                    <!-- Channel controls removed - channels auto-load from config -->
                    
                    <div class="info-box" style="margin: 20px 0; background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444;">
                        <strong>üö® Fall Detection:</strong>
                        <ul style="margin: 10px 0 0 20px; font-size: 0.9em;">
                            <li>Automatically detects when a person falls down using AI</li>
                            <li>Analyzes body orientation (height vs width ratio)</li>
                            <li>Triggers emergency alerts after 2 seconds of continuous fall detection</li>
                            <li>Captures snapshot with bounding box for immediate assessment</li>
                            <li>Stores fall event history with timestamps and duration</li>
                            <li>Ideal for elderly care, hospitals, warehouses, and public safety</li>
                        </ul>
                    </div>
                    
                    <div id="fd-video-grid" class="video-grid">
                        <!-- Video streams will be added here dynamically -->
                    </div>
                    <div id="fd-video-pagination" class="video-pagination" style="display: none;">
                        <button class="btn" onclick="changeVideoPage('FallDetection', -1)">‚óÄ Previous</button>
                        <span class="pagination-info">
                            <span id="fd-page-info">Page 1 of 1</span> 
                            (Showing <span id="fd-showing-count">0</span> of <span id="fd-total-count">0</span> channels)
                        </span>
                        <button class="btn" onclick="changeVideoPage('FallDetection', 1)">Next ‚ñ∂</button>
                    </div>
                </div>
                
                <div id="FallDetectionSnapshots" class="tab-content">
                    <h3>üö® Fall Detection History - All Channels</h3>
                    
                    <div class="filter-controls" style="margin-bottom: 20px;">
                        <button class="btn" onclick="loadFallSnapshots()">üîÑ Refresh</button>
                        <button class="btn" onclick="clearOldFallSnapshots()">üóëÔ∏è Clear Old Snapshots (7+ days)</button>
                    </div>
                    
                    <div id="fall-snapshots-grid" class="alert-gifs-grid">
                        <!-- Fall snapshots will be displayed here -->
                        <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                            Loading detection history...
                        </p>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>

<!-- ROI Editor Modal -->
<div id="roiModal" class="modal">
    <div class="modal-content" style="max-width: 95%; max-height: 95vh;">
        <div class="modal-header">
            <h2>Configure Queue Areas</h2>
            <span class="close-btn" onclick="closeRoiModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <div id="roiInstructions" style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px; border-left: 4px solid #3b82f6;">
                <strong>Drawing Queue Area (Yellow):</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Click to add points and create polygon boundaries</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Areas are shown as <strong>outline borders only</strong> (no fill)</li>
                    <li>Need at least 3 points to form a complete area</li>
                </ul>
            </div>
            
            <!-- Real-time ROI Information -->
            <div style="margin-bottom: 15px; padding: 8px; background-color: rgba(34, 197, 94, 0.1); border-radius: 5px; border-left: 4px solid #22c55e;">
                <strong>Area Status:</strong>
                <div id="roiInfo" style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                    Queue Area: 0 points | Counter Area: 0 points
                </div>
            </div>
            
            <div style="position: relative; display: inline-block;">
                <img id="roiImage" style="max-width: 100%; height: auto;">
                <canvas id="roiCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div style="margin-top: 20px;">
                <div class="btn-group">
                    <button class="btn selected" onclick="setRoiMode('main')">Queue Area (Yellow)</button>
                    <button class="btn" onclick="setRoiMode('secondary')">Counter Area (Cyan)</button>
                </div>
                <div style="margin-top: 10px;">
                    <div class="btn-group">
                        <button class="btn" onclick="createRectangleRoi()">Rectangle</button>
                        <button class="btn" onclick="createCircleRoi()">Circle</button>
                        <button class="btn" onclick="clearCurrentRoi()">Clear Current</button>
                        <button class="btn" onclick="clearAllRoi()">Clear All</button>
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="saveRoi()">Save Configuration</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Counting Line Editor Modal -->
<div id="lineModal" class="modal">
    <div class="modal-content" style="max-width: 95%; max-height: 95vh;">
        <div class="modal-header">
            <h2>Configure Counting Line</h2>
            <span class="close-btn" onclick="closeLineModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <div style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px; border-left: 4px solid #3b82f6;">
                <strong>Instructions:</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Drag the <span style="color: #ff0000; font-weight: bold;">red START point</span> and <span style="color: #0000ff; font-weight: bold;">blue END point</span> to adjust line position and length</li>
                    <li>Click and drag the <span style="color: #00ff00; font-weight: bold;">green line</span> itself to move the entire line</li>
                    <li>The line can be positioned at any angle and length within the video frame</li>
                    <li>People crossing the line in either direction will be counted</li>
                </ul>
            </div>
            
            <!-- Real-time Line Information -->
            <div style="margin-bottom: 15px; padding: 8px; background-color: rgba(34, 197, 94, 0.1); border-radius: 5px; border-left: 4px solid #22c55e;">
                <strong>Line Properties:</strong>
                <div id="lineInfo" style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                    Length: 100.0% | Angle: 90.0¬∞
                </div>
            </div>
            
            <div style="position: relative; display: inline-block;">
                <img id="lineImage" style="max-width: 100%; height: auto;">
                <canvas id="lineCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div style="margin-top: 20px;">
                <div class="btn-group">
                    <button class="btn selected" onclick="setLineOrientation('vertical')">Vertical Preset</button>
                    <button class="btn" onclick="setLineOrientation('horizontal')">Horizontal Preset</button>
                    <button class="btn" onclick="setLineDiagonal()">Diagonal Preset</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn" onclick="resetLineToCenter()">Reset to Center</button>
                    <button class="btn" onclick="flipLineDirection()">Flip Direction</button>
                    <button class="btn" onclick="extendLine()">Extend Line</button>
                    <button class="btn" onclick="shortenLine()">Shorten Line</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="saveLine()">Save Line Position</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Service Discipline Table ROI Editor Modal -->
<div id="serviceDisciplineRoiModal" class="modal">
    <div class="modal-content" style="max-width: 95%; max-height: 95vh;">
        <div class="modal-header">
            <h2>Configure Table ROIs for Service Discipline</h2>
            <span class="close-btn" onclick="closeServiceDisciplineRoiModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <div id="sdmRoiInstructions" style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px; border-left: 4px solid #3b82f6;">
                <strong>Instructions:</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Select a channel and enter a table ID (e.g., "table_1", "table_2")</li>
                    <li>Click on the image to add points and create a polygon around the table</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Need at least 3 points to form a complete polygon</li>
                    <li>Each table needs its own ROI configured separately</li>
                </ul>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Select Channel:</label>
                <select id="sdmRoiChannelSelect" class="channel-selector" onchange="loadServiceDisciplineRoiChannel()" style="width: 200px; padding: 8px;">
                    <option value="">Select Channel...</option>
                </select>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Table ID:</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="sdmRoiTableId" placeholder="e.g., table_1, table_2" style="padding: 8px; width: 200px; border-radius: 4px; border: 1px solid var(--border-color);">
                    <button class="btn" onclick="loadTableRoi()">Load Table</button>
                    <button class="btn" onclick="createNewTableRoi()">New Table</button>
                </div>
            </div>
            
            <div id="sdmRoiInfo" style="margin-bottom: 15px; padding: 8px; background-color: rgba(34, 197, 94, 0.1); border-radius: 5px; border-left: 4px solid #22c55e;">
                <strong>Table Status:</strong>
                <div style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                    No table selected
                </div>
            </div>
            
            <div style="position: relative; display: inline-block;">
                <img id="sdmRoiImage" style="max-width: 100%; height: auto;">
                <canvas id="sdmRoiCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div style="margin-top: 20px;">
                <div class="btn-group">
                    <button class="btn" onclick="clearCurrentTableRoi()">Clear Current Table</button>
                    <button class="btn" onclick="deleteCurrentTableRoi()">Delete Table</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="saveServiceDisciplineTableRoi()">Save Table ROI</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Material Theft Monitor ROI Configuration Modal -->
<div id="materialTheftRoiModal" class="modal">
    <div class="modal-content" style="max-width: 95%; max-height: 95vh;">
        <div class="modal-header">
            <h2>Configure Monitoring Area (ROI) for Material Theft</h2>
            <span class="close-btn" onclick="closeMaterialTheftRoiModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <div id="mtmRoiInstructions" style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px; border-left: 4px solid #3b82f6;">
                <strong>Instructions:</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Select a channel to configure the monitoring area</li>
                    <li>Click on the video feed to add points and create a polygon around the weighing machine area</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Need at least 3 points to form a complete polygon</li>
                    <li>The coordinates will be displayed below - you can copy them if needed</li>
                </ul>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Select Channel:</label>
                <select id="mtmRoiChannelSelect" class="channel-selector" onchange="loadMaterialTheftRoiChannel()" style="width: 200px; padding: 8px;">
                    <option value="">Select Channel...</option>
                </select>
            </div>
            
            <div id="mtmRoiInfo" style="margin-bottom: 15px; padding: 8px; background-color: rgba(34, 197, 94, 0.1); border-radius: 5px; border-left: 4px solid #22c55e;">
                <strong>ROI Status:</strong>
                <div style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                    No channel selected
                </div>
                <div id="mtmRoiCoordinates" style="font-family: monospace; font-size: 0.85em; margin-top: 8px; color: var(--text-secondary); word-break: break-all;">
                    Coordinates will appear here as you draw...
                </div>
            </div>
            
            <div style="position: relative; display: inline-block;">
                <img id="mtmRoiImage" style="max-width: 100%; height: auto;">
                <canvas id="mtmRoiCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div style="margin-top: 20px;">
                <div class="btn-group">
                    <button class="btn" onclick="clearMaterialTheftRoi()">Clear Points</button>
                    <button class="btn" onclick="loadMaterialTheftRoi()">Load Current ROI</button>
                    <button class="btn" onclick="reloadMaterialTheftRoiFromConfig()" style="background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);">üîÑ Reload from Config</button>
                    <button class="btn" onclick="resetMaterialTheftBackground()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">üîÑ Reset Background Model</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="saveMaterialTheftRoi()">üíæ Save ROI Configuration</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Crowd Detection ROI Configuration Modal -->
<div id="crowdRoiModal" class="modal">
    <div class="modal-content" style="max-width: 95%; max-height: 95vh;">
        <div class="modal-header">
            <h2>Configure Monitoring Area (ROI) for Crowd Detection</h2>
            <span class="close-btn" onclick="closeCrowdRoiModal()">&times;</span>
        </div>
        <div style="padding: 20px;">
            <div id="crowdRoiInstructions" style="margin-bottom: 15px; padding: 10px; background-color: rgba(59, 130, 246, 0.1); border-radius: 5px; border-left: 4px solid #3b82f6;">
                <strong>Instructions:</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Select a channel to configure the monitoring area</li>
                    <li>Click on the video feed to add points and create a polygon around the area to monitor</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Need at least 3 points to form a complete polygon</li>
                    <li>The coordinates will be displayed below - you can copy them if needed</li>
                </ul>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Select Channel:</label>
                <select id="crowdRoiChannelSelect" class="channel-selector" onchange="loadCrowdRoiChannel()" style="width: 200px; padding: 8px;">
                    <option value="">Select Channel...</option>
                </select>
            </div>
            
            <div id="crowdRoiInfo" style="margin-bottom: 15px; padding: 8px; background-color: rgba(34, 197, 94, 0.1); border-radius: 5px; border-left: 4px solid #22c55e;">
                <strong>ROI Status:</strong>
                <div style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                    No channel selected
                </div>
                <div id="crowdRoiCoordinates" style="font-family: monospace; font-size: 0.85em; margin-top: 8px; color: var(--text-secondary); word-break: break-all;">
                    Coordinates will appear here as you draw...
                </div>
            </div>
            
            <div style="position: relative; display: inline-block;">
                <img id="crowdRoiImage" style="max-width: 100%; height: auto;">
                <canvas id="crowdRoiCanvas" style="position: absolute; top: 0; left: 0; cursor: crosshair;"></canvas>
            </div>
            <div style="margin-top: 20px;">
                <div class="btn-group">
                    <button class="btn" onclick="clearCrowdRoi()">Clear Points</button>
                    <button class="btn" onclick="loadCrowdRoi()">Load Current ROI</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" onclick="saveCrowdRoi()">üíæ Save ROI Configuration</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Global variables
    const socket = io(`http://${window.location.hostname}:5000`);
    let activeChannels = {
        'QueueMonitor': {},
        'DressCodeMonitoring': {},
        'PPEMonitoring': {},
        'CashDetection': {},
        'SmokingDetection': {},
        'CrowdDetection': {}
    };
    let sharedChannels = {};  // Track which channels are shared across modules
    
    // Video pagination state
    // Note: browsers limit concurrent persistent HTTP connections to the same host (typically ~6).
    // To avoid hitting that limit we lazy-load image streams only for the currently visible page
    // and default streamsPerPage to 6 which fits most browser limits.
    let videoPagination = {
        'QueueMonitor': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'DressCodeMonitoring': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'PPEMonitoring': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'CashDetection': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'SmokingDetection': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'CrowdDetection': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'TableServiceMonitor': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'ServiceDisciplineMonitor': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'FallDetection': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'UnauthorizedEntryMonitor': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] },
        'MaterialTheftMonitor': { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] }
    };
    
    // Auto-refresh for hourly report
    let reportRefreshInterval = null;
    
    // ROI Editor state
    let roiState = {
        currentApp: null,
        currentChannel: null,
        currentMode: 'main',
        points: { main: [], secondary: [] },
        canvas: null,
        ctx: null,
        imageLoaded: false,
        isDragging: false,
        dragPointIndex: -1,
        isDrawing: false,
        hoverPointIndex: -1,
        hoverMode: null
    };
    
    // Line Editor state  
    let lineState = {
        currentApp: null,
        currentChannel: null,
        orientation: 'vertical',
        line: { start: {x: 0.5, y: 0}, end: {x: 0.5, y: 1} },
        isDragging: false,
        dragPoint: null, // 'start', 'end', or 'line' (entire line)
        canvas: null,
        ctx: null,
        imageLoaded: false
    };

    // Global user role variable
    let userRole = '{{ user.role }}';
    let isAdmin = userRole === 'admin';
    
    // Auto-refresh interval for analytics dashboard
    let analyticsRefreshInterval = null;

    // Initialize dashboard
    document.addEventListener('DOMContentLoaded', function() {
        // Load analytics cards first
        loadAnalyticsCards();
        
        // Set up auto-refresh for analytics dashboard every 60 seconds (1 minute)
        analyticsRefreshInterval = setInterval(() => {
            console.log('üîÑ Auto-refreshing analytics dashboard...');
            loadAnalyticsCards();
        }, 60000); // 60000ms = 1 minute
        
        // Hide channel selectors for non-admin users
        if (!isAdmin) {
            hideChannelSelectorsForUser();
        }
        
        loadAvailableChannels();
        // Removed auto-loading of channels - videos only load when "View Live" is clicked
        // loadActiveChannels(); // Auto-load channels that are already running
        loadAlertGifs();
        loadCashSnapshots();  // Load cash detection snapshots
        loadSmokingSnapshots();  // Load smoke/fire detection snapshots
        setupSocketListeners();
        
        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }
    });

    // Analytics Dashboard Functions
    async function loadAnalyticsCards() {
        const analyticsContainer = document.getElementById('analytics-cards');
        if (!analyticsContainer) {
            console.error('‚ùå Analytics container not found in DOM');
            return;
        }
        analyticsContainer.innerHTML = '<div class="loading-spinner">‚è≥ Loading Analytics...</div>';
        
        const modules = [
            { name: 'QueueMonitor', icon: '/static/images/icons/queue.png', title: 'Queue & Wait Time' },
            { name: 'DressCodeMonitoring', icon: '/static/images/icons/uniform.png', title: 'Uniform Compliance' },
            { name: 'PPEMonitoring', icon: '/static/images/icons/ppe.png', title: 'PPE Compliance' },
            { name: 'CashDetection', icon: '/static/images/icons/cash.png', title: 'Cash Drawer Monitoring' },
            { name: 'TableServiceMonitor', icon: '/static/images/icons/clean.jpg', title: 'Table Cleanliness' },
            { name: 'ServiceDisciplineMonitor', icon: '/static/images/icons/table_service.jpg', title: 'Service Discipline' },
            { name: 'UnauthorizedEntryMonitor', icon: '/static/images/icons/un.png', title: 'Unauthorized Entry' },
            { name: 'MaterialTheftMonitor', icon: '/static/images/icons/theft.jpg', title: 'Material Theft / Misuse' },
            // Move these to bottom
            { name: 'FallDetection', icon: '/static/images/icons/fall.jpg', title: 'Fall Detection' },
            { name: 'SmokingDetection', icon: '/static/images/icons/smoking.jpg', title: 'Smoke & Fire Detection' },
            { name: 'PersonSmokingDetection', icon: '/static/images/icons/cig.jpg', title: 'Smoking Detection' },
            { name: 'CrowdDetection', icon: '/static/images/icons/crowd.jpg', title: 'Crowd Detection' },
        ];
        
        try {
            const cardsHTML = [];
            
            for (const module of modules) {
                try {
                    const response = await fetch(`/api/get_module_analytics/${module.name}`);
                    const data = await response.json();
                    
                    console.log(`üìä ${module.name} analytics response:`, data);
                    
                    if (data.success && data.analytics) {
                        const card = createAnalyticsCard(module, data.analytics);
                        cardsHTML.push(card);
                    } else {
                        console.warn(`‚ö†Ô∏è ${module.name} analytics failed or missing:`, data);
                        // Still create a card with default/empty values so module is visible
                        const defaultAnalytics = {
                            current_queue_count: 0,
                            current_counter_count: 0,
                            total_alerts_7days: 0,
                            active_channels: 0
                        };
                        const card = createAnalyticsCard(module, defaultAnalytics);
                        cardsHTML.push(card);
                    }
                } catch (err) {
                    console.error(`‚ùå Error loading ${module.name}:`, err);
                    // Create card with error state so module is still visible
                    const errorAnalytics = {
                        current_queue_count: 0,
                        current_counter_count: 0,
                        total_alerts_7days: 0,
                        active_channels: 0,
                        error: 'Failed to load'
                    };
                    const card = createAnalyticsCard(module, errorAnalytics);
                    cardsHTML.push(card);
                }
            }
            
            analyticsContainer.innerHTML = cardsHTML.join('');
            
            // Update refresh status
            updateRefreshStatus();
        } catch (error) {
            console.error('Error loading analytics cards:', error);
            console.error('Error stack:', error.stack);
            if (analyticsContainer) {
                analyticsContainer.innerHTML = '<div class="loading-spinner">‚ùå Error loading analytics: ' + (error.message || 'Unknown error') + '</div>';
            }
        }
    }
    
    function updateRefreshStatus() {
        const statusElement = document.getElementById('analytics-refresh-status');
        if (statusElement) {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            statusElement.textContent = `Last updated: ${timeString} ‚Ä¢ Auto-refresh: 1 min`;
        }
    }
    
    function createAnalyticsCard(module, analytics) {
        let statsHTML = '';
        
        // Create stats based on module type
        if (module.name === 'PeopleCounter') {
            // Show daily breakdown if available
            let dailyBreakdown = '';
            if (analytics.daily_data && analytics.daily_data.length > 0) {
                dailyBreakdown = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                dailyBreakdown += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üìÖ Last 7 Days:</div>';
                
                // Show last 3 days in the card for brevity
                const recentDays = analytics.daily_data.slice(-3);
                recentDays.forEach(day => {
                    const date = new Date(day.date);
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    dailyBreakdown += `
                        <div style="display: flex; justify-content: space-between; font-size: 0.8em; padding: 3px 0; color: var(--text-secondary);">
                            <span>${dateStr}</span>
                            <span>IN: ${day.in_count} | OUT: ${day.out_count}</span>
                        </div>
                    `;
                });
                dailyBreakdown += '</div>';
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üë• Total IN (Today)</span>
                    <span class="stat-value">${analytics.total_in || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üö∂ Total OUT (Today)</span>
                    <span class="stat-value">${analytics.total_out || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìà Net Count</span>
                    <span class="stat-value">${analytics.net_count || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚è∞ Peak Hour (Today)</span>
                    <span class="stat-value" style="font-size: 0.9em; color: #4CAF50;">
                        ${analytics.peak_hour || 'N/A'}
                        ${analytics.peak_hour_traffic > 0 ? `<span style="font-size: 0.75em; color: var(--text-secondary);"> (${analytics.peak_hour_traffic} people)</span>` : ''}
                    </span>
                </div>
                ${dailyBreakdown}
            `;
        } else if (module.name === 'QueueMonitor') {
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">‚è±Ô∏è Queue Now</span>
                    <span class="stat-value large">${analytics.current_queue_count || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üßÆ Counter Now</span>
                    <span class="stat-value">${analytics.current_counter_count || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7d)</span>
                    <span class="stat-value">${analytics.total_alerts_7days || 0}</span>
                </div>
            `;
        } else if (module.name === 'Heatmap') {
            // Enhanced heatmap analytics with channel comparison
            const channelDetails = analytics.channel_details || [];
            const mostCrowdedNow = analytics.most_crowded_now;
            const historicalData = analytics.historical_data || {};
            
            let channelComparisonHTML = '';
            if (channelDetails.length > 0) {
                channelComparisonHTML = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                channelComparisonHTML += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üìä Channel Comparison (Now):</div>';
                
                // Show top 3 channels by hotspot count
                const topChannels = channelDetails.slice(0, 3);
                topChannels.forEach((ch, index) => {
                    const icon = index === 0 ? 'ü•á' : (index === 1 ? 'ü•à' : 'ü•â');
                    const barWidth = channelDetails.length > 0 ? (ch.current_hotspots / Math.max(...channelDetails.map(c => c.current_hotspots || 1))) * 100 : 0;
                    channelComparisonHTML += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${ch.current_hotspots > 0 ? '#ff6b6b' : 'var(--text-secondary)'};">
                                    ${ch.current_hotspots} hotspot${ch.current_hotspots !== 1 ? 's' : ''}
                                </span>
                            </div>
                            <div style="background: rgba(255,255,255,0.1); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="background: linear-gradient(90deg, #4CAF50, #ff6b6b); height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                });
                channelComparisonHTML += '</div>';
            }
            
            let historicalInsight = '';
            if (historicalData.most_crowded_channel) {
                const mcc = historicalData.most_crowded_channel;
                historicalInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Insights:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üèÜ Most Crowded: <strong style="color: #ff6b6b;">${mcc.channel_id}</strong><br>
                            üìä Total Hotspots: ${mcc.total_hotspots} | Avg: ${mcc.avg_hotspots}/hour<br>
                            üîù Peak: ${mcc.max_hotspots} hotspots in single snapshot
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üî• Active Hotspots</span>
                    <span class="stat-value large">${analytics.current_hotspots || 0}</span>
                </div>
                ${mostCrowdedNow ? `
                <div class="stat-row">
                    <span class="stat-label">üéØ Most Crowded Now</span>
                    <span class="stat-value" style="font-size: 0.9em; color: #ff6b6b;">${mostCrowdedNow.channel_id}</span>
                </div>
                ` : ''}
                ${channelComparisonHTML}
                ${historicalInsight}
            `;
        } else if (module.name === 'BagDetection') {
            // Enhanced bag detection analytics with risk assessment
            const channelDetails = analytics.channel_details || [];
            const mostRiskyNow = analytics.most_risky_now;
            const historicalData = analytics.historical_data || {};
            const dailyTrend = historicalData.daily_trend || [];
            
            let riskAssessment = '';
            if (channelDetails.length > 0) {
                riskAssessment = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                riskAssessment += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">‚ö†Ô∏è Risk Assessment by Channel:</div>';
                
                // Show top 3 riskiest channels
                const topRisky = channelDetails.slice(0, 3);
                topRisky.forEach((ch, index) => {
                    const icon = index === 0 ? 'üî¥' : (index === 1 ? 'üü°' : 'üü¢');
                    const riskLevel = ch.total_alerts > 5 ? 'High' : (ch.total_alerts > 2 ? 'Medium' : 'Low');
                    const riskColor = ch.total_alerts > 5 ? '#ff6b6b' : (ch.total_alerts > 2 ? '#ffa500' : '#4CAF50');
                    
                    riskAssessment += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${riskColor};">
                                    ${ch.total_alerts} alert${ch.total_alerts !== 1 ? 's' : ''} | ${riskLevel}
                                </span>
                            </div>
                            ${ch.longest_unattended > 0 ? `
                            <div style="font-size: 0.7em; color: var(--text-secondary); margin-left: 20px;">
                                ‚è±Ô∏è Longest: ${ch.longest_unattended}s | üìä Peak bags: ${ch.peak_bags}
                            </div>
                            ` : ''}
                        </div>
                    `;
                });
                riskAssessment += '</div>';
            }
            
            let trendInsight = '';
            if (dailyTrend.length > 0) {
                const recentDays = dailyTrend.slice(-3);
                const totalRecent = recentDays.reduce((sum, day) => sum + day.count, 0);
                const avgPerDay = (totalRecent / recentDays.length).toFixed(1);
                
                trendInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Trend:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üìä Total Alerts: ${historicalData.total_alerts || 0}<br>
                            üìâ Daily Average: ${avgPerDay} alerts/day<br>
                            ${historicalData.most_risky_channel ? `üéØ Highest Risk: <strong style="color: #ff6b6b;">${historicalData.most_risky_channel.channel_id}</strong> (${historicalData.most_risky_channel.alert_count} alerts)` : ''}
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7d)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üëú Bags Tracked Now</span>
                    <span class="stat-value">${analytics.current_bags_tracked || 0}</span>
                </div>
                ${analytics.current_unattended_bags > 0 ? `
                <div class="stat-row">
                    <span class="stat-label">‚ö†Ô∏è Unattended Now</span>
                    <span class="stat-value" style="color: #ff6b6b;">${analytics.current_unattended_bags}</span>
                </div>
                ` : ''}
                ${riskAssessment}
                ${trendInsight}
            `;
        } else if (module.name === 'ServiceDisciplineMonitor') {
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üìù Avg Order Wait (min)</span>
                    <span class="stat-value large">${(((analytics.avg_order_wait_time || 0) / 60)).toFixed(1)}</span>
                    <div style="font-size: 0.7em; color: var(--text-secondary); margin-top: 2px;">Time to collect order</div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìù Max Order Wait (min)</span>
                    <span class="stat-value">${(((analytics.max_order_wait_time || 0) / 60)).toFixed(1)}</span>
                </div>
                <div class="stat-row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <span class="stat-label">üçΩÔ∏è Avg Service Wait (min)</span>
                    <span class="stat-value large">${(((analytics.avg_service_wait_time || 0) / 60)).toFixed(1)}</span>
                    <div style="font-size: 0.7em; color: var(--text-secondary); margin-top: 2px;">Time to deliver food</div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üçΩÔ∏è Max Service Wait (min)</span>
                    <span class="stat-value">${(((analytics.max_service_wait_time || 0) / 60)).toFixed(1)}</span>
                </div>
                <div class="stat-row" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <span class="stat-label">üö® Alerts (7d)</span>
                    <span class="stat-value">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üü¢ Active Channels</span>
                    <span class="stat-value">${analytics.active_channels || 0}</span>
                </div>
            `;
        } else if (module.name === 'CashDetection') {
            // Enhanced cash detection analytics with activity analysis
            const channelDetails = analytics.channel_details || [];
            const mostActiveNow = analytics.most_active_now;
            const historicalData = analytics.historical_data || {};
            const peakHour = analytics.peak_hour;
            const hourlyDist = historicalData.hourly_distribution || [];
            
            let activityAnalysis = '';
            if (channelDetails.length > 0) {
                activityAnalysis = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                activityAnalysis += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üìä Activity by Channel:</div>';
                
                // Show top 3 most active channels
                const topActive = channelDetails.slice(0, 3);
                topActive.forEach((ch, index) => {
                    const icon = index === 0 ? 'üí∞' : (index === 1 ? 'üíµ' : 'üí¥');
                    const activityLevel = ch.total_detections > 100 ? 'Very High' : (ch.total_detections > 50 ? 'High' : 'Moderate');
                    const activityColor = ch.total_detections > 100 ? '#4CAF50' : (ch.total_detections > 50 ? '#ffa500' : '#2196F3');
                    
                    activityAnalysis += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${activityColor};">
                                    ${ch.total_detections} detections | ${activityLevel}
                                </span>
                            </div>
                            ${ch.avg_confidence > 0 ? `
                            <div style="font-size: 0.7em; color: var(--text-secondary); margin-left: 20px;">
                                ‚úì Confidence: ${(ch.avg_confidence * 100).toFixed(0)}% avg | ${(ch.highest_confidence * 100).toFixed(0)}% peak
                            </div>
                            ` : ''}
                        </div>
                    `;
                });
                activityAnalysis += '</div>';
            }
            
            let peakHourInsight = '';
            if (peakHour) {
                const hour24 = peakHour.hour;
                const hour12 = hour24 > 12 ? hour24 - 12 : (hour24 === 0 ? 12 : hour24);
                const ampm = hour24 >= 12 ? 'PM' : 'AM';
                const hourStr = `${hour12}:00 ${ampm}`;
                
                peakHourInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Insights:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            ‚è∞ Peak Hour: <strong style="color: #4CAF50;">${hourStr}</strong> (${peakHour.count} detections)<br>
                            üì∏ Total Snapshots: ${historicalData.total_snapshots || 0}<br>
                            ${historicalData.most_active_channel ? `üéØ Busiest: <strong style="color: #4CAF50;">${historicalData.most_active_channel.channel_id}</strong> (${historicalData.most_active_channel.snapshot_count} snapshots)` : ''}
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üì∏ Snapshots (7d)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üí∞ Total Detections</span>
                    <span class="stat-value">${analytics.total_detections_7days || 0}</span>
                </div>
                ${analytics.current_detections > 0 ? `
                <div class="stat-row">
                    <span class="stat-label">üî¥ Detecting Now</span>
                    <span class="stat-value" style="color: #4CAF50;">${analytics.current_detections}</span>
                </div>
                ` : ''}
                ${activityAnalysis}
                ${peakHourInsight}
            `;
        } else if (module.name === 'FallDetection') {
            // Enhanced Fall Detection analytics
            const channelDetails = analytics.channel_details || [];
            const mostRiskyChannel = analytics.most_risky_channel;
            const responseCategories = analytics.response_categories || {};
            const historicalData = analytics.historical_data || {};
            
            let severityAnalysis = '';
            if (channelDetails.length > 0) {
                severityAnalysis = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                severityAnalysis += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">‚ö†Ô∏è Severity by Channel:</div>';
                
                // Show top 3 channels by incident count
                const topChannels = channelDetails.slice(0, 3);
                topChannels.forEach((ch, index) => {
                    const severityIcon = ch.severity === 'High' ? 'üî¥' : (ch.severity === 'Medium' ? 'üü°' : 'üü¢');
                    const severityColor = ch.severity === 'High' ? '#ff6b6b' : (ch.severity === 'Medium' ? '#ffa500' : '#4CAF50');
                    
                    severityAnalysis += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${severityIcon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${severityColor};">
                                    ${ch.fall_count} incident${ch.fall_count !== 1 ? 's' : ''} | ${ch.severity}
                                </span>
                            </div>
                            ${ch.avg_duration > 0 ? `
                            <div style="font-size: 0.7em; color: var(--text-secondary); margin-left: 20px;">
                                ‚è±Ô∏è Avg Duration: ${ch.avg_duration}s
                            </div>
                            ` : ''}
                        </div>
                    `;
                });
                severityAnalysis += '</div>';
            }
            
            let responseTimeAnalysis = '';
            const totalResponses = responseCategories.quick + responseCategories.delayed + responseCategories.critical;
            if (totalResponses > 0) {
                responseTimeAnalysis = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">‚è±Ô∏è Response Time Analysis:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üü¢ Quick (&lt;30s): <strong style="color: #4CAF50;">${responseCategories.quick}</strong> (${((responseCategories.quick/totalResponses)*100).toFixed(0)}%)<br>
                            üü° Delayed (30-60s): <strong style="color: #ffa500;">${responseCategories.delayed}</strong> (${((responseCategories.delayed/totalResponses)*100).toFixed(0)}%)<br>
                            üî¥ Critical (&gt;60s): <strong style="color: #ff6b6b;">${responseCategories.critical}</strong> (${((responseCategories.critical/totalResponses)*100).toFixed(0)}%)
                        </div>
                    </div>
                `;
            }
            
            let historicalInsight = '';
            if (historicalData.most_incidents_channel) {
                const mic = historicalData.most_incidents_channel;
                historicalInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìä 7-Day Summary:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            ${analytics.peak_hour !== 'N/A' ? `‚è∞ Peak Hour: <strong style="color: #4CAF50;">${analytics.peak_hour}</strong> (${analytics.peak_hour_count} falls)<br>` : ''}
                            üèÜ Most Incidents: <strong style="color: #ff6b6b;">${mic.channel_id}</strong> (${mic.fall_count} falls)<br>
                            ‚è±Ô∏è Longest Fall: ${analytics.max_fall_duration}s | Avg: ${analytics.avg_fall_duration}s
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Falls (7 days)</span>
                    <span class="stat-value large">${analytics.total_falls_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Today's Falls</span>
                    <span class="stat-value">${analytics.today_falls || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚è±Ô∏è Avg Duration</span>
                    <span class="stat-value" style="font-size: 0.9em; color: ${analytics.avg_fall_duration > 30 ? '#ff6b6b' : '#4CAF50'};">
                        ${analytics.avg_fall_duration || 0}s
                    </span>
                </div>
                ${severityAnalysis}
                ${responseTimeAnalysis}
                ${historicalInsight}
            `;
        } else if (module.name === 'MoppingDetection') {
            // Enhanced Mopping Detection analytics
            const channelDetails = analytics.channel_details || [];
            const mostActiveChannel = analytics.most_active_channel;
            const historicalData = analytics.historical_data || {};
            
            let activityAnalysis = '';
            if (channelDetails.length > 0) {
                activityAnalysis = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                activityAnalysis += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üßπ Activity by Channel:</div>';
                
                // Show top 3 most active channels
                const topActive = channelDetails.slice(0, 3);
                topActive.forEach((ch, index) => {
                    const icon = index === 0 ? 'üßπ' : (index === 1 ? 'üßΩ' : 'ü´ß');
                    const activityLevel = ch.total_detections > 50 ? 'High' : (ch.total_detections > 20 ? 'Moderate' : 'Low');
                    const activityColor = ch.total_detections > 50 ? '#4CAF50' : (ch.total_detections > 20 ? '#2196F3' : 'var(--text-secondary)');
                    
                    activityAnalysis += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${activityColor};">
                                    ${ch.total_detections} detections | ${activityLevel}
                                </span>
                            </div>
                        </div>
                    `;
                });
                activityAnalysis += '</div>';
            }
            
            let historicalInsight = '';
            if (historicalData.most_active_channel) {
                const mac = historicalData.most_active_channel;
                historicalInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Insights:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üèÜ Most Active: <strong style="color: #4CAF50;">${mac.channel_id}</strong> (${mac.alert_count} alerts)<br>
                            üì∏ Total Snapshots: ${historicalData.total_snapshots || 0}<br>
                            ${analytics.peak_hour !== 'N/A' ? `‚è∞ Peak Hour: <strong style="color: #4CAF50;">${analytics.peak_hour}</strong>` : ''}
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7 days)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Today's Alerts</span>
                    <span class="stat-value">${analytics.today_alerts || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üßπ Total Detections</span>
                    <span class="stat-value">${analytics.total_detections_7days || 0}</span>
                </div>
                ${activityAnalysis}
                ${historicalInsight}
            `;
        } else if (module.name === 'PersonSmokingDetection') {
            // Smoking Detection analytics (cigarette smoking)
            const channelDetails = analytics.channel_details || [];
            const mostActiveChannel = analytics.most_active_channel;
            const totalAlerts = analytics.total_alerts_7days || 0;
            const todayAlerts = analytics.today_alerts || 0;
            const currentDetections = analytics.current_detections || 0;
            
            let activityAnalysis = '';
            if (channelDetails.length > 0) {
                activityAnalysis = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                activityAnalysis += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;"> Activity by Channel:</div>';
                
                const topActive = channelDetails.slice(0, 3);
                topActive.forEach((ch, index) => {
                    const icon = index === 0 ? 'üö¨' : (index === 1 ? '‚ö†Ô∏è' : 'üìπ');
                    const activityLevel = ch.total_alerts > 10 ? 'High' : (ch.total_alerts > 5 ? 'Moderate' : 'Low');
                    const activityColor = ch.total_alerts > 10 ? '#ff6b6b' : (ch.total_alerts > 5 ? '#ffa500' : 'var(--text-secondary)');
                    
                    activityAnalysis += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${activityColor};">
                                    ${ch.total_alerts} alerts | ${activityLevel}
                                </span>
                            </div>
                        </div>
                    `;
                });
                activityAnalysis += '</div>';
            }
            
            let historicalInsight = '';
            if (mostActiveChannel) {
                historicalInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Insights:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üèÜ Most Active: <strong style="color: #ff6b6b;">${mostActiveChannel.channel_id}</strong> (${mostActiveChannel.total_alerts} alerts)<br>
                            üìä Total Alerts: ${totalAlerts}<br>
                            üëÅÔ∏è Current Detections: ${currentDetections}
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö¨ Alerts (7 days)</span>
                    <span class="stat-value large">${totalAlerts}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Today's Alerts</span>
                    <span class="stat-value">${todayAlerts}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üëÅÔ∏è Current Detections</span>
                    <span class="stat-value">${currentDetections}</span>
                </div>
                ${activityAnalysis}
                ${historicalInsight}
            `;
        } else if (module.name === 'SmokingDetection') {
            // Enhanced Smoking Detection analytics (Smoke & Fire)
            const channelDetails = analytics.channel_details || [];
            const mostActiveChannel = analytics.most_active_channel;
            const historicalData = analytics.historical_data || {};
            
            let activityAnalysis = '';
            if (channelDetails.length > 0) {
                activityAnalysis = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                activityAnalysis += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üö¨ Activity by Channel:</div>';
                
                // Show top 3 most active channels
                const topActive = channelDetails.slice(0, 3);
                topActive.forEach((ch, index) => {
                    const icon = index === 0 ? '' : (index === 1 ? '' : '‚ö†Ô∏è');
                    const activityLevel = ch.total_detections > 50 ? 'High' : (ch.total_detections > 20 ? 'Moderate' : 'Low');
                    const activityColor = ch.total_detections > 50 ? '#ff6b6b' : (ch.total_detections > 20 ? '#ffa500' : 'var(--text-secondary)');
                    
                    activityAnalysis += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${activityColor};">
                                    ${ch.total_detections} detections | ${activityLevel}
                                </span>
                            </div>
                        </div>
                    `;
                });
                activityAnalysis += '</div>';
            }
            
            let historicalInsight = '';
            if (historicalData.most_active_channel) {
                const mac = historicalData.most_active_channel;
                historicalInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Insights:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üèÜ Most Active: <strong style="color: #ff6b6b;">${mac.channel_id}</strong> (${mac.total_alerts} alerts)<br>
                            üì∏ Total Snapshots: ${historicalData.total_snapshots || 0}<br>
                            ${analytics.peak_hour !== 'N/A' ? `‚è∞ Peak Hour: <strong style="color: #ff6b6b;">${analytics.peak_hour}</strong>` : ''}
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7 days)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Today's Alerts</span>
                    <span class="stat-value">${analytics.today_alerts || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label"> Total Detections</span>
                    <span class="stat-value">${analytics.total_detections_7days || 0}</span>
                </div>
                ${activityAnalysis}
                ${historicalInsight}
            `;
        } else if (module.name === 'CrowdDetection') {
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üë• Crowd Now</span>
                    <span class="stat-value large">${analytics.current_crowd_count || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7d)</span>
                    <span class="stat-value">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìä Threshold</span>
                    <span class="stat-value">${analytics.crowd_threshold || 5}</span>
                </div>
            `;
        } else if (module.name === 'PhoneUsageDetection') {
            // Enhanced Phone Usage Detection analytics
            const channelDetails = analytics.channel_details || [];
            const mostActiveChannel = analytics.most_active_channel;
            const historicalData = analytics.historical_data || {};
            
            let activityAnalysis = '';
            if (channelDetails.length > 0) {
                activityAnalysis = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                activityAnalysis += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üì± Activity by Channel:</div>';
                
                // Show top 3 most active channels
                const topActive = channelDetails.slice(0, 3);
                topActive.forEach((ch, index) => {
                    const icon = index === 0 ? 'üì±' : (index === 1 ? 'üìµ' : '‚ö†Ô∏è');
                    const activityLevel = ch.total_detections > 50 ? 'High' : (ch.total_detections > 20 ? 'Moderate' : 'Low');
                    const activityColor = ch.total_detections > 50 ? '#ff6b6b' : (ch.total_detections > 20 ? '#ffa500' : 'var(--text-secondary)');
                    
                    activityAnalysis += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${ch.channel_id}</span>
                                <span style="font-weight: 600; color: ${activityColor};">
                                    ${ch.total_detections} detections | ${activityLevel}
                                </span>
                            </div>
                        </div>
                    `;
                });
                activityAnalysis += '</div>';
            }
            
            let historicalInsight = '';
            if (historicalData.most_active_channel) {
                const mac = historicalData.most_active_channel;
                historicalInsight = `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; font-weight: 600;">üìà 7-Day Insights:</div>
                        <div style="font-size: 0.75em; color: var(--text-secondary); line-height: 1.5;">
                            üèÜ Most Active: <strong style="color: #ff6b6b;">${mac.channel_id}</strong> (${mac.total_alerts} alerts)<br>
                            üì∏ Total Snapshots: ${historicalData.total_snapshots || 0}<br>
                            ${analytics.peak_hour !== 'N/A' ? `‚è∞ Peak Hour: <strong style="color: #ff6b6b;">${analytics.peak_hour}</strong>` : ''}
                        </div>
                    </div>
                `;
            }
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7 days)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Today's Alerts</span>
                    <span class="stat-value">${analytics.today_alerts || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üì± Total Detections</span>
                    <span class="stat-value">${analytics.total_detections_7days || 0}</span>
                </div>
                ${activityAnalysis}
                ${historicalInsight}
            `;
        } else if (module.name === 'PPEMonitoring') {
            // PPE Monitoring analytics
            const totalAlerts = analytics.total_alerts || 0;
            const todayAlerts = analytics.today_alerts || 0;
            const activeChannels = analytics.active_channels || 0;
            const totalViolations = analytics.total_violations || 0;
            
            statsHTML = `
                <div class="stat-item">
                    <div class="stat-label">Total Alerts</div>
                    <div class="stat-value">${totalAlerts}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Today's Alerts</div>
                    <div class="stat-value">${todayAlerts}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Violations</div>
                    <div class="stat-value">${totalViolations}</div>
                </div>
            `;
        } else if (module.name === 'DressCodeMonitoring') {
            // Enhanced Dress Code Monitoring analytics
            const violationTypes = analytics.violation_types || {};
            const uniformColors = analytics.uniform_colors || {};
            const totalViolations = analytics.total_violations || 0;
            
            // Violation type breakdown
            let violationBreakdown = '';
            const violationEntries = Object.entries(violationTypes);
            if (violationEntries.length > 0) {
                violationBreakdown = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                violationBreakdown += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">‚ö†Ô∏è Violation Breakdown:</div>';
                
                // Sort by count and show top 3
                violationEntries.sort((a, b) => b[1] - a[1]);
                const topViolations = violationEntries.slice(0, 3);
                
                topViolations.forEach(([type, count], index) => {
                    const icon = index === 0 ? 'üî¥' : (index === 1 ? 'üü†' : 'üü°');
                    const percentage = totalViolations > 0 ? ((count / totalViolations) * 100).toFixed(1) : 0;
                    const barWidth = violationEntries.length > 0 ? (count / Math.max(...violationEntries.map(v => v[1]))) * 100 : 0;
                    
                    // Format violation type name (remove underscores, capitalize)
                    const formattedType = type.split('_').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                    
                    violationBreakdown += `
                        <div style="margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75em; color: var(--text-secondary); margin-bottom: 2px;">
                                <span>${icon} ${formattedType}</span>
                                <span style="font-weight: 600; color: #ff6b6b;">
                                    ${count} (${percentage}%)
                                </span>
                            </div>
                            <div style="background: rgba(255,255,255,0.1); height: 6px; border-radius: 3px; overflow: hidden;">
                                <div style="background: linear-gradient(90deg, #ffa500, #ff6b6b); height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    `;
                });
                violationBreakdown += '</div>';
            }
            
            // Uniform color distribution
            let colorDistribution = '';
            const colorEntries = Object.entries(uniformColors);
            if (colorEntries.length > 0) {
                colorDistribution = '<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">';
                colorDistribution += '<div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üëî Uniform Colors Detected:</div>';
                
                // Sort by count and show all
                colorEntries.sort((a, b) => b[1] - a[1]);
                const totalColorDetections = colorEntries.reduce((sum, [, count]) => sum + count, 0);
                
                colorDistribution += '<div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;">';
                colorEntries.forEach(([color, count]) => {
                    const percentage = totalColorDetections > 0 ? ((count / totalColorDetections) * 100).toFixed(0) : 0;
                    
                    // Color badge mapping
                    const colorEmojis = {
                        'red': 'üî¥',
                        'blue': 'üîµ',
                        'green': 'üü¢',
                        'yellow': 'üü°',
                        'black': '‚ö´',
                        'white': '‚ö™',
                        'orange': 'üü†',
                        'purple': 'üü£',
                        'brown': 'üü§',
                        'grey': '‚ö™',
                        'gray': '‚ö™',
                        'pink': 'ü©∑'
                    };
                    
                    const emoji = colorEmojis[color.toLowerCase()] || '‚ö™';
                    
                    colorDistribution += `
                        <div style="background: rgba(255,255,255,0.1); padding: 4px 10px; border-radius: 12px; font-size: 0.7em; display: inline-flex; align-items: center; gap: 4px;">
                            <span>${emoji}</span>
                            <span style="color: var(--text-secondary); font-weight: 600;">${color}</span>
                            <span style="color: #4CAF50; margin-left: 4px;">${percentage}%</span>
                        </div>
                    `;
                });
                colorDistribution += '</div>';
                colorDistribution += '</div>';
            }
            
            // Compliance insights
            let complianceInsights = '';
            const complianceRate = totalViolations > 0 ? 
                Math.max(0, 100 - (totalViolations / (analytics.active_channels || 1) * 10)).toFixed(1) : 100;
            const complianceColor = complianceRate >= 90 ? '#4CAF50' : (complianceRate >= 70 ? '#ffa500' : '#ff6b6b');
            
            complianceInsights = `
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px; font-weight: 600;">üìä Compliance Rate:</div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">
                        <div style="flex: 1; background: rgba(255,255,255,0.1); height: 20px; border-radius: 10px; overflow: hidden; position: relative;">
                            <div style="background: linear-gradient(90deg, ${complianceColor}, ${complianceColor}cc); height: 100%; width: ${complianceRate}%; transition: width 0.5s;"></div>
                            <span style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.7em; font-weight: 700; color: white; text-shadow: 0 0 4px rgba(0,0,0,0.8);">
                                ${complianceRate}%
                            </span>
                        </div>
                    </div>
                    <div style="font-size: 0.7em; color: var(--text-secondary); margin-top: 4px;">
                        ${complianceRate >= 90 ? '‚úÖ Excellent compliance!' : 
                          complianceRate >= 70 ? '‚ö†Ô∏è Moderate violations detected' : 
                          'üö® High violation rate - action needed'}
                    </div>
                </div>
            `;
            
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">‚ö†Ô∏è Total Violations (7d)</span>
                    <span class="stat-value large">${totalViolations}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìã Violation Types</span>
                    <span class="stat-value">${Object.keys(violationTypes).length || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üé® Uniform Colors</span>
                    <span class="stat-value">${Object.keys(uniformColors).length || 0}</span>
                </div>
                ${violationBreakdown}
                ${colorDistribution}
                ${complianceInsights}
            `;
        } else if (module.name === 'TableServiceMonitor') {
            // Table Cleanliness analytics
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7 days)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚è±Ô∏è Avg Unclean Time (min)</span>
                    <span class="stat-value">${(((analytics.avg_unclean_time || 0) / 60)).toFixed(1)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚è≥ Max Unclean Time (min)</span>
                    <span class="stat-value">${(((analytics.max_unclean_time || 0) / 60)).toFixed(1)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚è±Ô∏è Avg Reset Time (min)</span>
                    <span class="stat-value">${(((analytics.avg_reset_time || 0) / 60)).toFixed(1)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚è≥ Max Reset Time (min)</span>
                    <span class="stat-value">${(((analytics.max_reset_time || 0) / 60)).toFixed(1)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üü¢ Active Channels</span>
                    <span class="stat-value">${analytics.active_channels || 0}</span>
                </div>
            `;
        } else if (module.name === 'MaterialTheftMonitor') {
            // Material Theft / Misuse analytics
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üì¶ Alerts (7 days)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìÖ Today's Alerts</span>
                    <span class="stat-value">${analytics.today_alerts || 0}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üìπ Active Channels</span>
                    <span class="stat-value">${analytics.active_channels || 0}</span>
                </div>
            `;
        } else {
            // For other alert-based modules (Grooming Detection)
            statsHTML = `
                <div class="stat-row">
                    <span class="stat-label">üö® Alerts (7 days)</span>
                    <span class="stat-value large">${analytics.total_alerts_7days || 0}</span>
                </div>
            `;
        }
        
        const channelText = analytics.active_channels === 1 ? 'channel' : 'channels';
        
        // Store analytics data in a global object for easy access
        if (!window.analyticsData) {
            window.analyticsData = {};
        }
        window.analyticsData[module.name] = {
            title: module.title,
            icon: module.icon,
            statsHTML: statsHTML,
            activeChannels: analytics.active_channels || 0,
            channelText: channelText
        };
        
        // Check if icon is an image path or emoji
        const isImage = module.icon && (module.icon.endsWith('.png') || module.icon.endsWith('.jpg') || module.icon.endsWith('.jpeg') || module.icon.endsWith('.svg') || module.icon.startsWith('/static/'));
        const bgStyle = isImage 
            ? `style="background-image: linear-gradient(rgba(13,17,23,0.82), rgba(13,17,23,0.82)), url('${module.icon}'); background-size: cover; background-position: center;"`
            : '';
        
        return `
            <div class="analytics-card" ${bgStyle} onclick="openAnalyticsDetails('${module.name}')">
                <div class="analytics-card-header">
                    <h3 class="analytics-card-title">${module.title}</h3>
                </div>
                <div class="analytics-card-footer">
                    <span class="channel-count">üìπ ${analytics.active_channels || 0} ${channelText} active</span>
                </div>
            </div>
        `;
    }
    
    function openAnalyticsDetails(moduleName) {
        const modal = document.getElementById('analyticsDetailsModal');
        const modalTitle = document.getElementById('analyticsDetailsTitle');
        const modalIcon = document.getElementById('analyticsDetailsIcon');
        const modalStats = document.getElementById('analyticsDetailsStats');
        const modalFooter = document.getElementById('analyticsDetailsFooter');
        
        if (!modal) {
            console.error('Analytics details modal not found');
            return;
        }
        
        // Get data from global object
        const data = window.analyticsData && window.analyticsData[moduleName];
        if (!data) {
            console.error('Analytics data not found for:', moduleName);
            return;
        }
        
        // Set modal content
        if (modalIcon) modalIcon.innerHTML = '';
        if (modalTitle) modalTitle.textContent = data.title;
        if (modalStats) modalStats.innerHTML = data.statsHTML;
        if (modalFooter) {
            modalFooter.innerHTML = `
                <span class="channel-count">üìπ ${data.activeChannels} ${data.channelText} active</span>
                <button class="view-live-btn" onclick="event.stopPropagation(); closeAnalyticsDetails(); openLiveMonitoring('${moduleName}')">
                    üëÅÔ∏è View Live
                </button>
            `;
        }
        
        // Show modal
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
    }
    
    function closeAnalyticsDetails() {
        const modal = document.getElementById('analyticsDetailsModal');
        if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = '';
        }
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
        const modal = document.getElementById('analyticsDetailsModal');
        if (event.target === modal) {
            closeAnalyticsDetails();
        }
    }
    
    function openLiveMonitoring(moduleName) {
        const modal = document.getElementById('liveMonitoringModal');
        const modalTitle = document.getElementById('modalModuleTitle');
        const modalContent = document.getElementById('modalModuleContent');
        
        // Prevent multiple initializations
        if (modal.dataset.currentModule === moduleName && modal.style.display === 'block') {
            console.log('Modal already open for this module, skipping re-initialization');
            return;
        }
        
        // Stop any existing streams before loading new content
        stopAllStreamsInModal();
        
        // Clear existing content to prevent duplicates
        modalContent.innerHTML = '';
        
        // Get module template or module content
        const template = document.getElementById(`${moduleName}-template`);
        const moduleContent = document.getElementById(`${moduleName}-module`);
        
        if (template) {
            modalTitle.textContent = template.querySelector('.analytics-card-title')?.textContent || moduleName;
            modalContent.innerHTML = template.innerHTML;
            modal.dataset.currentModule = moduleName; // Mark which module is currently open
            modal.style.display = 'block';
            
            // Load module-specific data when modal opens
            if (moduleName === 'SmokingDetection') {
                updateSmokeFireStats();
                loadSmokingSnapshots();
            } else if (moduleName === 'PersonSmokingDetection') {
                updatePersonSmokingStats();
                loadPersonSmokingAlerts();
            }
            
            // Initialize the module's live monitoring
            initializeLiveModule(moduleName);
        } else if (moduleContent) {
            // Use existing module content (for modules like FallDetection that don't have templates)
            modalTitle.textContent = moduleContent.querySelector('h2')?.textContent || moduleName + ' Live Monitoring';
            modalContent.innerHTML = moduleContent.innerHTML;
            modal.dataset.currentModule = moduleName;
            modal.style.display = 'block';
            
            // Initialize the module's live monitoring
            initializeLiveModule(moduleName);
        } else {
            // Fallback: show basic message
            modalTitle.textContent = moduleName + ' Live Monitoring';
            modalContent.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <p>Live monitoring view for ${moduleName}</p>
                    <p style="color: var(--text-secondary); margin-top: 10px;">Module content loading...</p>
                </div>
            `;
            modal.dataset.currentModule = moduleName;
            modal.style.display = 'block';
        }
    }
    
    function closeLiveMonitoring() {
        const modal = document.getElementById('liveMonitoringModal');
        const modalContent = document.getElementById('modalModuleContent');
        
        // Stop any active streams when closing
        stopAllStreamsInModal();
        
        // Clear the modal content and reset the current module marker
        if (modalContent) {
            modalContent.innerHTML = '';
        }
        if (modal) {
            modal.dataset.currentModule = '';
            modal.style.display = 'none';
        }
    }
    
    // Track initialization to prevent duplicates
    let moduleInitializationInProgress = {};
    
    function initializeLiveModule(moduleName) {
        // Prevent duplicate initialization
        if (moduleInitializationInProgress[moduleName]) {
            console.log(`‚è≠Ô∏è Initialization already in progress for ${moduleName}, skipping`);
            return;
        }
        
        // Load the appropriate module content
        console.log('Initializing live module:', moduleName);
        moduleInitializationInProgress[moduleName] = true;
        
        // Load active channels - this will populate the video grids
        setTimeout(() => {
            // The grid IDs in templates use the module prefix
            const gridMap = {
                'QueueMonitor': 'qm-video-grid',
                'DressCodeMonitoring': 'dcm-video-grid',
                'PPEMonitoring': 'ppe-video-grid',
                'CashDetection': 'cd-video-grid',
                'SmokingDetection': 'smoking-video-grid',
                'CrowdDetection': 'crowd-video-grid',
                'TableServiceMonitor': 'tsm-video-grid',
                'ServiceDisciplineMonitor': 'sdm-video-grid',
                'FallDetection': 'fd-video-grid',
                'UnauthorizedEntryMonitor': 'uem-video-grid',
                'MaterialTheftMonitor': 'mtm-video-grid',
            };
            
            const gridId = gridMap[moduleName];
            if (gridId) {
                // Verify grid exists before loading channels
                const grid = document.getElementById(gridId);
                console.log(`üîç Checking for grid ${gridId}:`, grid ? 'FOUND' : 'NOT FOUND');
                
                if (grid) {
                    // Clear existing video streams in the grid before adding new ones
                    grid.innerHTML = '';
                    // Trigger loading of active channels for this module
                    loadActiveChannelsForModule(moduleName);
                } else {
                    console.error(`‚ùå Grid ${gridId} not found in DOM. Modal content may not be loaded yet.`);
                    // Try again with longer delay
                    setTimeout(() => {
                        const retryGrid = document.getElementById(gridId);
                        if (retryGrid) {
                            console.log(`‚úÖ Grid ${gridId} found on retry`);
                            retryGrid.innerHTML = ''; // Clear before adding
                            loadActiveChannelsForModule(moduleName);
                        } else {
                            console.error(`‚ùå Grid ${gridId} still not found after retry`);
                            moduleInitializationInProgress[moduleName] = false;
                        }
                    }, 300);
                }
            } else {
                moduleInitializationInProgress[moduleName] = false;
            }
        }, 100);
    }
    
    function loadActiveChannelsForModule(moduleName) {
        // Load only the active channels for this specific module
        console.log('üîç Loading active channels for:', moduleName);
        
        fetch('/api/get_active_channels')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Backend returns active_channels; keep fallback to data.channels for compatibility
                    const allChannels = data.active_channels || data.channels || [];
                    
                    // Debug: Log all channels and their modules
                    console.log(`üìä All channels from backend:`, allChannels);
                    allChannels.forEach(ch => {
                        console.log(`  - ${ch.channel_id}: modules=`, ch.active_modules || ch.modules);
                    });
                    
                    // Normalize modules list (can be array or object keys)
                    const moduleChannels = allChannels.filter(ch => {
                        const rawModules = ch.active_modules || ch.modules || [];
                        const modulesList = Array.isArray(rawModules) ? rawModules : Object.keys(rawModules);
                        const hasModule = modulesList.includes(moduleName);
                        if (!hasModule && rawModules.length > 0) {
                            console.log(`  ‚ö†Ô∏è ${ch.channel_id} has modules [${modulesList.join(', ')}] but not ${moduleName}`);
                        }
                        return hasModule;
                    });
                    
                    console.log(`‚úÖ Found ${moduleChannels.length} active channels for ${moduleName}:`, moduleChannels);
                    
                    // Add video streams for each channel (only if not already added)
                    // Use a Set to track channels we're adding in this batch to prevent duplicates
                    const channelsBeingAdded = new Set();
                    moduleChannels.forEach(channel => {
                        const streamBoxId = `stream-box-${moduleName}-${channel.channel_id}`;
                        const existingStream = document.getElementById(streamBoxId);
                        
                        // Check both DOM and our tracking set
                        if (!existingStream && !channelsBeingAdded.has(channel.channel_id)) {
                            channelsBeingAdded.add(channel.channel_id);
                            console.log(`üìπ Adding video stream for ${moduleName}/${channel.channel_id}`);
                            addVideoStream(moduleName, channel.channel_id, false, []);
                        } else {
                            console.log(`‚è≠Ô∏è Video stream already exists for ${moduleName}/${channel.channel_id}, skipping`);
                        }
                    });
                    
                    // Mark initialization as complete
                    moduleInitializationInProgress[moduleName] = false;
                    
                    // Force update pagination to ensure streams are visible
                    console.log(`üìä Updating pagination for ${moduleName}`);
                    setTimeout(() => {
                        updateVideoPagination(moduleName);
                    }, 500);
                    
                    // If no channels found, try loading from channels.json as fallback
                    if (moduleChannels.length === 0) {
                        console.warn(`‚ö†Ô∏è No active channels found for ${moduleName}, trying fallback from channels.json`);
                        
                        // Immediate fallback for MaterialTheftMonitor - directly add camera_15
                        if (moduleName === 'MaterialTheftMonitor') {
                            console.log('üîß Immediate fallback: Adding camera_15 for MaterialTheftMonitor');
                            const streamBoxId = `stream-box-${moduleName}-camera_15`;
                            const existingStream = document.getElementById(streamBoxId);
                            if (!existingStream) {
                                addVideoStream(moduleName, 'camera_15', false, []);
                                setTimeout(() => {
                                    updateVideoPagination(moduleName);
                                }, 500);
                            } else {
                                console.log(`‚è≠Ô∏è Video stream already exists for ${moduleName}/camera_15, skipping fallback`);
                            }
                        }
                        
                        fetch('/api/get_configured_channels')
                            .then(response => response.json())
                            .then(channelData => {
                                if (channelData.success && channelData.channels) {
                                    const configuredChannels = channelData.channels.filter(ch => {
                                        if (!ch.modules || !Array.isArray(ch.modules)) return false;
                                        // API returns modules as array of strings (module type names)
                                        return ch.modules.includes(moduleName);
                                    });
                                    console.log(`üìã Found ${configuredChannels.length} configured channels for ${moduleName} in channels.json:`, configuredChannels);
                                    
                                    if (configuredChannels.length > 0) {
                                        configuredChannels.forEach(channel => {
                                            const streamBoxId = `stream-box-${moduleName}-${channel.channel_id}`;
                                            const existingStream = document.getElementById(streamBoxId);
                                            if (!existingStream) {
                                                console.log(`üìπ Adding video stream (fallback) for ${moduleName}/${channel.channel_id}`);
                                                addVideoStream(moduleName, channel.channel_id, false, []);
                                            } else {
                                                console.log(`‚è≠Ô∏è Video stream already exists for ${moduleName}/${channel.channel_id}, skipping fallback`);
                                            }
                                        });
                                        setTimeout(() => {
                                            updateVideoPagination(moduleName);
                                        }, 500);
                                    }
                                }
                            })
                            .catch(err => {
                                console.error('‚ùå Error loading channels.json fallback:', err);
                                // Last resort: manually add camera_15 for MaterialTheftMonitor if module name matches
                                if (moduleName === 'MaterialTheftMonitor') {
                                    console.log('üîß Last resort: Adding camera_15 for MaterialTheftMonitor');
                                    const streamBoxId = `stream-box-${moduleName}-camera_15`;
                                    const existingStream = document.getElementById(streamBoxId);
                                    if (!existingStream) {
                                        addVideoStream(moduleName, 'camera_15', false, []);
                                        setTimeout(() => {
                                            updateVideoPagination(moduleName);
                                        }, 500);
                                    } else {
                                        console.log(`‚è≠Ô∏è Video stream already exists for ${moduleName}/camera_15, skipping last resort`);
                                    }
                                }
                            });
                    }
                } else {
                    console.error('‚ùå Failed to load active channels:', data);
                    moduleInitializationInProgress[moduleName] = false;
                }
            })
            .catch(error => {
                console.error('‚ùå Error loading active channels:', error);
                moduleInitializationInProgress[moduleName] = false;
            });
    }
    
    function stopAllStreamsInModal() {
        // Stop all video streams in the modal
        const modalContent = document.getElementById('modalModuleContent');
        const images = modalContent.querySelectorAll('img');
        images.forEach(img => {
            img.src = ''; // Stop streaming
        });
    }
    
    function loadChannelsForModule(moduleName) {
        // Legacy function - kept for compatibility
        loadActiveChannelsForModule(moduleName);
    }
    
    function switchLiveTab(evt, tabId) {
        // Auto-load alerts when reports tab is opened
        if (tabId === 'CrowdDetection-reports') {
            loadCrowdAlerts();
            updateCrowdStats();
        }
        // Similar to existing openTab function but for modal tabs
        const modal = document.getElementById('modalModuleContent');
        const tabs = modal.querySelectorAll('.tab-content');
        const buttons = modal.querySelectorAll('.tab-button');
        
        tabs.forEach(tab => tab.classList.remove('active'));
        buttons.forEach(btn => btn.classList.remove('active'));
        
        document.getElementById(tabId)?.classList.add('active');
        evt.currentTarget.classList.add('active');
        
        // Load alerts when switching to reports tab
        if (tabId === 'PPEMonitoring-reports') {
            loadPPEAlerts();
            updatePPEStats();
        } else if (tabId === 'QueueMonitor-reports') {
            loadQueueViolations();
        } else if (tabId === 'CrowdDetection-reports') {
            loadCrowdAlerts();
        } else if (tabId === 'DressCodeMonitoring-reports') {
            loadDressCodeAlerts();
            updateDressCodeStats();
        } else if (tabId === 'TableServiceMonitor-reports') {
            loadTableServiceViolations();
            updateTableServiceStats();
        } else if (tabId === 'ServiceDisciplineMonitor-reports') {
            // Load alerts when Reports tab is opened
            loadServiceDisciplineAlerts();
            // Also update stats
            updateServiceDisciplineStats([]); // Will be updated when alerts load
        }
    }

    // Hide channel selectors and start/stop buttons for regular users
    function hideChannelSelectorsForUser() {
        // Hide channel selectors in Live Monitoring tabs
        const selectors = [
            'pc-channel-selector',
            'qm-channel-selector',
            'bd-channel-selector',
            'hm-channel-selector',
            'cd-channel-selector',
            'fd-channel-selector',
            'gd-channel-selector'
        ];
        
        selectors.forEach(id => {
            const element = document.getElementById(id);
            if (element && element.parentElement) {
                element.parentElement.style.display = 'none';
            }
        });
        
        // Hide start/stop buttons in all Live Monitoring tabs
        const startButtons = document.querySelectorAll('[onclick^="start"]');
        const stopButtons = document.querySelectorAll('[onclick^="stop"]');
        
        startButtons.forEach(btn => {
            if (btn.textContent.includes('Start')) {
                btn.style.display = 'none';
            }
        });
        
        stopButtons.forEach(btn => {
            if (btn.textContent.includes('Stop')) {
                btn.style.display = 'none';
            }
        });
    }

    // Socket.IO connection handlers
    socket.on('connect', () => {
        console.log('‚úÖ Connected to Sakshi.AI');
    });

    socket.on('disconnect', () => {
        console.warn('‚ö†Ô∏è Disconnected from Sakshi.AI');
    });

    // Real-time data handlers
    socket.on('count_update', (data) => {
        updatePeopleCountDisplay(data);
    });

    socket.on('queue_update', (data) => {
        updateQueueDisplay(data);
    });

    socket.on('queue_alert', (data) => {
        showQueueAlert(data);
        // Reload violations if on QueueMonitor reports tab
        if (document.getElementById('QueueMonitor-reports')?.classList.contains('active')) {
            loadQueueViolations();
        }
    });

    socket.on('ppe_alert', (data) => {
        showPPEAlert(data);
        // Reload alerts if on PPE reports tab
        if (document.getElementById('PPEMonitoring-reports')?.classList.contains('active')) {
            loadPPEAlerts();
            updatePPEStats();
        }
    });
    
    socket.on('ppe_update', (data) => {
        // Real-time updates from PPE monitoring
        // Could update live stats if needed
    });

    socket.on('crowd_update', (data) => {
        updateCrowdDisplay(data);
    });

    socket.on('crowd_alert', (data) => {
        showCrowdAlert(data);
    });

    socket.on('bag_detection_update', (data) => {
        updateBagDetectionDisplay(data);
    });

    // WebSocket video frame handler
    socket.on('video_frame', (data) => {
        const imgId = `stream-img-${data.app_name}-${data.channel_id}`;
        const img = document.getElementById(imgId);
        if (!img) {
            // Log missing image element periodically to avoid spam
            if (Math.random() < 0.01) { // 1% chance to log
                console.warn(`‚ö†Ô∏è Image element not found: ${imgId} for ${data.app_name}/${data.channel_id}`);
            }
            return;
        }
        
        if (!data.frame || data.frame.length === 0) {
            console.warn(`‚ö†Ô∏è Empty frame data received for ${data.app_name}/${data.channel_id}`);
            return;
        }
        
        img.src = `data:image/jpeg;base64,${data.frame}`;
        
        // Redraw ROI/counting line after image loads (important for proper canvas sizing)
        img.onload = function() {
                if (data.app_name === 'QueueMonitor') {
                    const canvas = document.getElementById(`roi-canvas-${data.channel_id}`);
                    if (canvas && canvas.dataset.roiLoaded === 'true') {
                        // ROI already loaded, just redraw it
                        if (canvas.roiConfig) {
                            drawROIOnCanvas(canvas, img, canvas.roiConfig);
                        }
                    } else if (canvas && !canvas.dataset.roiLoading) {
                        // Load ROI for the first time
                        canvas.dataset.roiLoading = 'true';
                        loadAndDrawROI(data.app_name, data.channel_id);
                    }
                } else if (data.app_name === 'PeopleCounter') {
                    const canvas = document.getElementById(`line-canvas-${data.channel_id}`);
                    if (canvas && canvas.dataset.lineLoaded === 'true') {
                        // Line already loaded, just redraw it
                        if (canvas.lineConfig) {
                            drawLineOnCanvas(canvas, img, canvas.lineConfig);
                        }
                    } else if (canvas && !canvas.dataset.lineLoading) {
                        // Load line for the first time
                        canvas.dataset.lineLoading = 'true';
                        loadAndDrawCountingLine(data.app_name, data.channel_id);
                    }
                }
            };
        
        // Update status indicator
        const status = document.getElementById(`status-${data.app_name}-${data.channel_id}`);
        if (status) {
            status.textContent = 'Live';
            status.className = 'status-indicator status-online';
            
            // Clear any pending timeout since we received a frame
            const streamBox = document.getElementById(`stream-box-${data.app_name}-${data.channel_id}`);
            if (streamBox && streamBox.dataset.timeoutId) {
                clearTimeout(parseInt(streamBox.dataset.timeoutId));
                delete streamBox.dataset.timeoutId;
            }
        }
        
        // Update FPS display
        const fpsElement = document.getElementById(`fps-${data.app_name}-${data.channel_id}`);
        if (fpsElement && data.fps !== undefined) {
            fpsElement.textContent = `${Math.round(data.fps)} FPS`;
        }
        
        // Update FPS display in header
        if (data.fps !== undefined) {
            const fpsElement = document.getElementById(`fps-${data.app_name}-${data.channel_id}`);
            if (fpsElement) {
                fpsElement.textContent = `${data.fps} FPS`;
            }
        }
    });

    socket.on('stream_subscribed', (data) => {
        console.log(`‚úÖ Subscribed to ${data.app_name}/${data.channel_id}`);
        const status = document.getElementById(`status-${data.app_name}-${data.channel_id}`);
        if (status) {
            status.textContent = 'Connected';
            status.className = 'status-indicator status-online';
        }
    });

    socket.on('stream_error', (data) => {
        console.error('Stream error:', data.error);
        const { app_name, channel_id, error } = data;
        
        // Update status indicator for the specific channel
        const statusEl = document.getElementById(`status-${app_name}-${channel_id}`);
        if (statusEl) {
            statusEl.textContent = 'Error';
            statusEl.className = 'status-indicator status-offline';
        }
        
        // Show error notification to user
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f87171;
            color: white;
            padding: 15px 20px;
            border-radius: 6px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 400px;
            font-size: 14px;
        `;
        errorDiv.innerHTML = `
            <strong>‚ö†Ô∏è Video Stream Error</strong><br>
            <div style="margin-top: 8px; font-size: 13px;">
                <strong>Channel:</strong> ${channel_id}<br>
                <strong>Module:</strong> ${app_name}<br>
                <div style="margin-top: 5px;">${error || 'Unable to load video stream'}</div>
            </div>
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 18px; cursor: pointer; margin-top: -5px;">&times;</button>
        `;
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (errorDiv.parentElement) {
                errorDiv.remove();
            }
        }, 10000);
    });

    function setupSocketListeners() {
        // Additional socket listeners can be added here
    }

    // Load available video channels (both RTSP and video files)
    async function loadAvailableChannels() {
        try {
            const response = await fetch('/api/get_channels/PeopleCounter');
            const channels = await response.json();
            
            // These selectors no longer exist since channels auto-load, but keep for alert filter
            const alertFilter = document.getElementById('alert-channel-filter');
            
            // Only populate alert filter if it exists
            if (alertFilter) {
                alertFilter.innerHTML = '<option value="">All Channels</option>';
            }
            
            // Add channels to alert filter only
            channels.forEach(channel => {
                const displayName = channel.type === 'rtsp' ? 
                    `üìπ ${channel.name}` : 
                    `üé¨ ${channel.name}`;
                
                if (alertFilter) {
                    const option = new Option(displayName, channel.id);
                    alertFilter.add(option);
                }
            });
            
        } catch (error) {
            console.error('Failed to load channels:', error);
        }
    }

    // Auto-load active channels that are already running
    async function loadActiveChannels() {
        try {
            const response = await fetch('/api/get_active_channels');
            const result = await response.json();
            
            if (!result.success) {
                console.log('No active channels or error fetching:', result.error);
                return;
            }
            
            const activeChannels = result.active_channels || [];
            console.log(`Loading ${activeChannels.length} active channels...`);
            
            // Group channels by module type
            const channelsByModule = {};
            activeChannels.forEach(channel => {
                channel.modules.forEach(moduleName => {
                    if (!channelsByModule[moduleName]) {
                        channelsByModule[moduleName] = [];
                    }
                    channelsByModule[moduleName].push(channel);
                });
            });
            
            // Add video streams for each module
            for (const [moduleName, channels] of Object.entries(channelsByModule)) {
                channels.forEach(channel => {
                    const streamBoxId = `stream-box-${moduleName}-${channel.channel_id}`;
                    const existingStream = document.getElementById(streamBoxId);
                    
                    if (!existingStream) {
                        const isShared = channel.modules.length > 1;
                        const activeModules = channel.modules;
                        
                        // Add video stream to the grid
                        addVideoStream(moduleName, channel.channel_id, isShared, activeModules);
                        
                        console.log(`Added stream for ${moduleName}: ${channel.channel_id}`);
                    } else {
                        console.log(`‚è≠Ô∏è Stream already exists for ${moduleName}/${channel.channel_id}, skipping`);
                    }
                });
            }
            
            // Update pagination for all modules that have channels
            Object.keys(channelsByModule).forEach(module => {
                updateVideoPagination(module);
            });
            
        } catch (error) {
            console.error('Failed to load active channels:', error);
        }
    }

    // Alert GIF Management Functions
    async function loadAlertGifs() {
        try {
            const channelFilter = document.getElementById('alert-channel-filter').value;
            // Filter by queue_alert type to only show Queue Monitor alerts
            let url = '/api/get_alert_gifs?alert_type=queue_alert&limit=20';
            if (channelFilter) {
                url += `&channel_id=${channelFilter}`;
            }
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayAlertGifs(result.alert_gifs);
            } else {
                console.error('Failed to load alert GIFs:', result.error);
            }
        } catch (error) {
            console.error('Error loading alert GIFs:', error);
        }
    }

    function displayAlertGifs(alertGifs) {
        const grid = document.getElementById('alert-gifs-grid');
        
        if (!alertGifs || alertGifs.length === 0) {
            grid.innerHTML = '<p style="color: var(--text-secondary); text-align: center; grid-column: 1 / -1;">No alert recordings found.</p>';
            return;
        }
        
        grid.innerHTML = alertGifs.map(gif => `
            <div class="alert-gif-card">
                <img src="${gif.gif_url}" alt="Alert GIF" class="alert-gif" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <div style="display: none; color: var(--text-secondary); font-style: italic;">GIF not available</div>
                
                <div class="alert-info">
                    üìÖ ${new Date(gif.created_at).toLocaleString()}<br>
                    üìπ Channel: ${gif.channel_id}<br>
                    ‚è±Ô∏è Duration: ${gif.duration_seconds}s | Frames: ${gif.frame_count}<br>
                    üíæ Size: ${gif.file_size_mb} MB
                </div>
                
                <div class="alert-message">
                    ${gif.alert_message || 'Queue Alert'}
                </div>
                
                <div class="alert-actions">
                    <button class="btn" onclick="downloadAlertGif('${gif.gif_filename}')">Download</button>
                    <button class="btn" onclick="deleteAlertGif(${gif.id})" style="background-color: #d73a49;">Delete</button>
                </div>
            </div>
        `).join('');
    }

    async function deleteAlertGif(gifId) {
        if (!confirm('Are you sure you want to delete this alert recording?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_alert_gif/${gifId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            
            if (result.success) {
                alert('Alert recording deleted successfully');
                loadAlertGifs(); // Reload the grid
            } else {
                alert(`Failed to delete alert recording: ${result.error}`);
            }
        } catch (error) {
            console.error('Error deleting alert GIF:', error);
            alert('Failed to delete alert recording');
        }
    }

    function downloadAlertGif(filename) {
        const link = document.createElement('a');
        link.href = `/static/alerts/${filename}`;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function clearOldAlerts() {
        if (!confirm('Are you sure you want to clear alert recordings older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_alerts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    days: 7,
                    alert_type: 'queue_alert'
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Successfully deleted ${result.deleted_count} old queue alerts`);
                loadAlertGifs();  // Reload the alert list
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old alerts:', error);
            alert('Failed to clear old alerts');
        }
    }

    // ============= Queue Monitor Violations Functions =============
    async function loadQueueViolations() {
        console.log('üîÑ Loading queue violations...');
        const grid = document.getElementById('queue-violations-grid');
        
        if (!grid) {
            console.error('‚ùå Queue violations grid not found in DOM');
            return;
        }
        
        // Show loading state
        grid.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading violations...</p>';
        
        try {
            const channelFilter = document.getElementById('alert-channel-filter')?.value || '';
            let url = '/api/get_queue_violations?limit=50';
            if (channelFilter) {
                url += `&channel_id=${channelFilter}`;
            }
            
            console.log('üì° Fetching from:', url);
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            console.log('üì¶ API Response:', result);
            console.log('üìä Violations data:', result.violations);
            
            if (result.success) {
                const violations = result.violations || [];
                console.log(`‚úÖ Loaded ${violations.length} queue violations`);
                
                if (violations.length > 0) {
                    console.log('üìã Sample violation:', violations[0]);
                }
                
                displayQueueViolations(violations);
            } else {
                console.error('‚ùå Failed to load queue violations:', result.error);
                grid.innerHTML = `<p style="color: var(--text-secondary); text-align: center; grid-column: 1 / -1;">Error loading violations: ${result.error || 'Unknown error'}</p>`;
            }
        } catch (error) {
            console.error('‚ùå Error loading queue violations:', error);
            console.error('Error stack:', error.stack);
            grid.innerHTML = `<p style="color: var(--text-secondary); text-align: center; grid-column: 1 / -1;">Error loading violations: ${error.message}</p>`;
        }
    }

    function displayQueueViolations(violations) {
        const grid = document.getElementById('queue-violations-grid');
        
        if (!grid) {
            console.error('‚ùå Queue violations grid not found');
            return;
        }
        
        console.log(`üìä Displaying ${violations ? violations.length : 0} violations`);
        
        if (!violations || violations.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary); grid-column: 1 / -1;">
                    <h3>‚úÖ No Violations</h3>
                    <p>No queue violations detected yet.</p>
                    <p style="font-size: 0.9em; margin-top: 10px;">Make sure QueueMonitor is running and ROIs are configured.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = violations.map(violation => {
            // Handle timestamp - support both timestamp and created_at fields
            let timestamp;
            try {
                const tsValue = violation.timestamp || violation.created_at;
                if (tsValue) {
                    timestamp = new Date(tsValue);
                    if (isNaN(timestamp.getTime())) {
                        console.warn('Invalid timestamp:', tsValue);
                        timestamp = new Date();
                    }
                } else {
                    timestamp = new Date();
                }
            } catch (e) {
                console.warn('Error parsing timestamp:', e);
                timestamp = new Date();
            }
            
            // Handle snapshot path - support both absolute and relative paths
            // Also handle Windows backslashes
            let snapshotUrl = null;
            if (violation.snapshot_path) {
                // Normalize path separators (Windows backslashes to forward slashes)
                let normalizedPath = violation.snapshot_path.replace(/\\/g, '/');
                
                if (normalizedPath.startsWith('/') || normalizedPath.startsWith('http')) {
                    snapshotUrl = normalizedPath;
                } else {
                    // Relative path - prepend /static/ if it doesn't already include it
                    if (normalizedPath.includes('static/')) {
                        snapshotUrl = `/${normalizedPath}`;
                    } else {
                        snapshotUrl = `/static/${normalizedPath}`;
                    }
                }
            }
            
            return `
                <div class="alert-gif-card">
                    <div class="gif-preview">
                        ${snapshotUrl ? `<img src="${snapshotUrl}" alt="Queue Violation" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">` : '<div style="padding: 40px; text-align: center; color: var(--text-secondary);">No snapshot</div>'}
                    </div>
                    <div class="gif-info">
                        <div class="gif-channel">
                            <strong>Channel:</strong> ${violation.channel_id}
                        </div>
                        <div class="gif-time">
                            <strong>Time:</strong> ${timestamp.toLocaleString()}
                        </div>
                        <div class="gif-message" style="color: #ef4444;">
                            <strong>Alert:</strong> ${violation.violation_message || violation.violation_type}
                        </div>
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-top: 5px;">
                            Queue: ${violation.queue_count || 0} | Counter: ${violation.counter_count || 0}
                            ${violation.wait_time_seconds ? ` | Wait: ${violation.wait_time_seconds.toFixed(1)}s` : ''}
                        </div>
                    </div>
                    <div class="gif-actions">
                        ${snapshotUrl ? `<button class="btn btn-sm" onclick="downloadQueueSnapshot('${violation.snapshot_path}')">üì• Download</button>` : ''}
                        <button class="btn btn-sm btn-danger" onclick="deleteQueueViolation(${violation.id})">üóëÔ∏è Delete</button>
                    </div>
                </div>
            `;
        }).join('');
    }

    async function deleteQueueViolation(violationId) {
        if (!confirm('Are you sure you want to delete this violation?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_queue_violation/${violationId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadQueueViolations(); // Reload the list
            } else {
                alert('Error deleting violation: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting queue violation:', error);
            alert('Failed to delete violation');
        }
    }

    function downloadQueueSnapshot(snapshotPath) {
        const fullPath = snapshotPath.startsWith('/') ? snapshotPath : `/static/${snapshotPath}`;
        const link = document.createElement('a');
        link.href = fullPath;
        link.download = snapshotPath.split('/').pop();
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    async function clearOldQueueViolations() {
        if (!confirm('Are you sure you want to clear queue violations older than 7 days?')) {
            return;
        }
        
        try {
            // This would need an endpoint to clear old violations
            // For now, just show a message
            alert('Clear old violations feature coming soon. Please delete violations manually.');
        } catch (error) {
            console.error('Error clearing old queue violations:', error);
            alert('Failed to clear old violations');
        }
    }

    // ============= Footfall Report Functions =============
    let footfallChart = null;

    // Load channel list into People Counter reports dropdown
    // Load footfall report for selected channel and period
    async function loadFootfallReport() {
        console.log('loadFootfallReport() called');
        
        let channelId = null;
        let period = null;
        
        // Get active channels from the API
        try {
            console.log('Fetching active channels from /api/get_active_channels');
            const channelsResponse = await fetch('/api/get_active_channels');
            const result = await channelsResponse.json();
            
            console.log('Active channels response:', result);
            
            if (!result.success || !result.active_channels || result.active_channels.length === 0) {
                console.error('No active channels found');
                alert('No active channels found. Please wait for channels to load or check if application is running.');
                return;
            }
            
            // Find the first channel with PeopleCounter module
            const pcChannel = result.active_channels.find(ch => ch.modules.includes('PeopleCounter'));
            
            if (!pcChannel) {
                console.error('No PeopleCounter channel found');
                alert('No active People Counter channel found. Please start a People Counter channel first.');
                return;
            }
            
            channelId = pcChannel.channel_id;
            period = document.getElementById('pc-report-period').value;
            
            console.log('Loading report for channel:', channelId, 'period:', period);
        } catch (err) {
            console.error('Error fetching channels:', err);
            alert('Error loading channels: ' + err.message);
            return;
        }
        
        // Clear any existing refresh interval
        if (reportRefreshInterval) {
            clearInterval(reportRefreshInterval);
            reportRefreshInterval = null;
        }
        
        const contentDiv = document.getElementById('pc-reports-content');
        contentDiv.innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner"></div><p>Loading report...</p></div>';
        
        try {
            const response = await fetch(`/api/get_footfall_report/${channelId}?period=${period}`);
            const report = await response.json();
            
            if (report.error) {
                throw new Error(report.error);
            }
            
            displayFootfallReport(report, channelId, period);
            
            // Auto-refresh hourly report every 60 seconds
            if (period === '24hours') {
                reportRefreshInterval = setInterval(() => {
                    const currentPeriod = document.getElementById('pc-report-period').value;
                    
                    // Only refresh if still viewing the hourly report
                    if (currentPeriod === '24hours') {
                        fetch(`/api/get_footfall_report/${channelId}?period=24hours`)
                            .then(res => res.json())
                            .then(report => {
                                if (!report.error) {
                                    displayFootfallReport(report, channelId, '24hours');
                                }
                            })
                            .catch(err => console.error('Auto-refresh error:', err));
                    } else {
                        // Stop refresh if user switched to different report
                        clearInterval(reportRefreshInterval);
                        reportRefreshInterval = null;
                    }
                }, 60000); // Refresh every 60 seconds
            }
            
        } catch (error) {
            console.error('Error loading report:', error);
            contentDiv.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;"><p>‚ùå Error: ${error.message}</p></div>`;
        }
    }

    // Display footfall report with table and chart
    function displayFootfallReport(report, channelId, period) {
        const contentDiv = document.getElementById('pc-reports-content');
        const chartContainer = document.getElementById('pc-chart-container');
        
        if (!report.data || report.data.length === 0) {
            contentDiv.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #999;">
                    <h3>üìä No Data Available</h3>
                    <p>No footfall data recorded for this period.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start the People Counter to begin recording data.</p>
                </div>
            `;
            chartContainer.style.display = 'none';
            return;
        }
        
        // Calculate totals
        let totalIn = 0, totalOut = 0;
        report.data.forEach(item => {
            totalIn += item.in_count || 0;
            totalOut += item.out_count || 0;
        });
        
        // Generate table based on period
        let tableHTML = '';
        if (period === '24hours') {
            // Get current time for "Last Updated" display
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            
            // Hourly table
            tableHTML = `
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); border: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: var(--text-primary);">üìä Hourly Footfall Report</h3>
                        <div style="display: flex; gap: 20px; align-items: center;">
                            <div style="font-size: 0.85em; color: var(--text-secondary); padding: 5px 10px; background: rgba(35, 134, 54, 0.2); border-radius: 4px; border: 1px solid var(--border-color);">
                                üîÑ Auto-refreshing every 60s<br>
                                <span style="font-size: 0.9em;">Last updated: ${timeStr}</span>
                            </div>
                            <div><strong style="color: var(--text-primary);">Total IN:</strong> <span style="color: #238636;">${totalIn}</span></div>
                            <div><strong style="color: var(--text-primary);">Total OUT:</strong> <span style="color: #da3633;">${totalOut}</span></div>
                            <div><strong style="color: var(--text-primary);">Net:</strong> <span style="color: var(--accent-color);">${totalIn - totalOut}</span></div>
                        </div>
                    </div>
                    
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                    <th style="padding: 12px; text-align: left;">Hour</th>
                                    <th style="padding: 12px; text-align: center;">Entries (IN)</th>
                                    <th style="padding: 12px; text-align: center;">Exits (OUT)</th>
                                    <th style="padding: 12px; text-align: center;">Total Traffic</th>
                                    <th style="padding: 12px; text-align: center;">Net Flow</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${report.data.map(item => `
                                    <tr style="border-bottom: 1px solid #dee2e6;">
                                        <td style="padding: 10px; font-weight: 500;">${String(item.hour).padStart(2, '0')}:00 - ${String(item.hour).padStart(2, '0')}:59</td>
                                        <td style="padding: 10px; text-align: center; color: #28a745;"><strong>${item.in_count}</strong></td>
                                        <td style="padding: 10px; text-align: center; color: #dc3545;"><strong>${item.out_count}</strong></td>
                                        <td style="padding: 10px; text-align: center;"><strong>${item.total}</strong></td>
                                        <td style="padding: 10px; text-align: center; color: ${(item.in_count - item.out_count) >= 0 ? '#007bff' : '#fd7e14'};"><strong>${item.in_count - item.out_count > 0 ? '+' : ''}${item.in_count - item.out_count}</strong></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        } else {
            // Daily table
            tableHTML = `
                <div style="background: var(--bg-secondary); border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); border: 1px solid var(--border-color);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; color: var(--text-primary);">üìä Daily Footfall Report</h3>
                        <div style="display: flex; gap: 20px;">
                            <div><strong>Total IN:</strong> <span style="color: #28a745;">${totalIn}</span></div>
                            <div><strong>Total OUT:</strong> <span style="color: #dc3545;">${totalOut}</span></div>
                            <div><strong>Net:</strong> <span style="color: #007bff;">${totalIn - totalOut}</span></div>
                        </div>
                    </div>
                    
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                    <th style="padding: 12px; text-align: left;">Date</th>
                                    <th style="padding: 12px; text-align: center;">Entries (IN)</th>
                                    <th style="padding: 12px; text-align: center;">Exits (OUT)</th>
                                    <th style="padding: 12px; text-align: center;">Total Traffic</th>
                                    <th style="padding: 12px; text-align: center;">Net Flow</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${report.data.map(item => {
                                    const date = new Date(item.date);
                                    const dateStr = date.toLocaleDateString('en-US', {weekday: 'short', month: 'short', day: 'numeric'});
                                    return `
                                        <tr style="border-bottom: 1px solid #dee2e6;">
                                            <td style="padding: 10px; font-weight: 500;">${dateStr}</td>
                                            <td style="padding: 10px; text-align: center; color: #28a745;"><strong>${item.in_count}</strong></td>
                                            <td style="padding: 10px; text-align: center; color: #dc3545;"><strong>${item.out_count}</strong></td>
                                            <td style="padding: 10px; text-align: center;"><strong>${item.total}</strong></td>
                                            <td style="padding: 10px; text-align: center; color: ${(item.in_count - item.out_count) >= 0 ? '#007bff' : '#fd7e14'};"><strong>${item.in_count - item.out_count > 0 ? '+' : ''}${item.in_count - item.out_count}</strong></td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        contentDiv.innerHTML = tableHTML;
        
        // Show and update chart
        chartContainer.style.display = 'block';
        updateFootfallChart(report, period);
    }

    // Update footfall chart
    function updateFootfallChart(report, period) {
        const ctx = document.getElementById('pc-footfall-chart');
        
        if (!ctx) return;
        
        // Destroy existing chart
        if (footfallChart) {
            footfallChart.destroy();
        }
        
        let labels, inData, outData;
        
        if (period === '24hours') {
            labels = report.data.map(item => `${String(item.hour).padStart(2, '0')}:00`);
            inData = report.data.map(item => item.in_count);
            outData = report.data.map(item => item.out_count);
        } else {
            labels = report.data.map(item => {
                const date = new Date(item.date);
                return date.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
            });
            inData = report.data.map(item => item.in_count);
            outData = report.data.map(item => item.out_count);
        }
        
        footfallChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Entries (IN)',
                        data: inData,
                        borderColor: '#28a745',
                        backgroundColor: 'rgba(40, 167, 69, 0.1)',
                        tension: 0.4,
                        fill: true
                    },
                    {
                        label: 'Exits (OUT)',
                        data: outData,
                        borderColor: '#dc3545',
                        backgroundColor: 'rgba(220, 53, 69, 0.1)',
                        tension: 0.4,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    title: {
                        display: true,
                        text: period === '24hours' ? 'Hourly Footfall Trends' : 'Daily Footfall Trends',
                        font: {size: 16}
                    },
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            }
        });
    }

    // Refresh current report
    function refreshFootfallReport() {
        // Simply reload the report for active channels
        loadFootfallReport();
    }

    // ============= Bag Detection Functions =============
    
    // Load bag detection alerts
    async function loadBagAlerts() {
        try {
            // Load all bag alerts from all channels
            const url = `/api/get_alert_gifs?alert_type=bag_unattended`;
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayBagAlerts(result.gifs);
            } else {
                console.error('Error loading bag alerts:', result.error);
            }
        } catch (error) {
            console.error('Error loading bag alerts:', error);
        }
    }
    
    // Display bag alerts in grid
    function displayBagAlerts(alerts) {
        const grid = document.getElementById('bag-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üì¶ No Alerts Yet</h3>
                    <p>No unattended baggage detected.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Bag Detection to monitor for unattended items.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => `
            <div class="alert-gif-card">
                <div class="gif-preview">
                    <img src="/static/alerts/${alert.gif_filename}" alt="Bag Alert" loading="lazy" style="cursor: pointer;" onclick="openLightboxFromImage(this)">
                </div>
                <div class="gif-info">
                    <div class="gif-channel">
                        <strong>üìπ Channel:</strong> ${alert.channel_id}
                    </div>
                    <div class="gif-time">
                        <strong>üïê Time:</strong> ${new Date(alert.created_at).toLocaleString()}
                    </div>
                    <div class="gif-message">
                        <strong>‚ö†Ô∏è Alert:</strong> ${alert.alert_message}
                    </div>
                    <div class="gif-stats">
                        <span>üìä ${alert.frame_count} frames</span>
                        <span>‚è±Ô∏è ${alert.duration_seconds}s</span>
                        <span>üíæ ${(alert.file_size / 1024 / 1024).toFixed(2)} MB</span>
                    </div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm" onclick="downloadAlertGif('${alert.gif_filename}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteBagAlert(${alert.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Delete bag alert
    async function deleteBagAlert(gifId) {
        if (!confirm('Are you sure you want to delete this alert?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_alert_gif/${gifId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadBagAlerts();
            } else {
                alert('Error deleting alert: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting alert:', error);
            alert('Failed to delete alert');
        }
    }
    
    // Clear old bag alerts
    async function clearOldBagAlerts() {
        if (!confirm('This will delete all bag alerts older than 7 days. Continue?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_alerts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    days: 7,
                    alert_type: 'bag_unattended'
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Successfully deleted ${result.deleted_count} old bag alerts`);
                loadBagAlerts();  // Reload the alert list
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old bag alerts:', error);
            alert('Failed to clear old bag alerts');
        }
    }
    
    // Open bag settings modal
    function openBagSettingsModal() {
        // Settings are in the settings tab, so just switch to it
        openTab({target: document.querySelector('[onclick*="BagDetectionSettings"]')}, 'BagDetectionSettings');
    }
    
    // Save bag detection settings
    async function saveBagSettings() {
        const settings = {
            time_threshold: parseFloat(document.getElementById('bd-time-threshold').value),
            proximity_threshold: parseFloat(document.getElementById('bd-proximity-threshold').value),
            alert_cooldown: parseFloat(document.getElementById('bd-alert-cooldown').value),
            confidence: parseFloat(document.getElementById('bd-confidence').value)
        };
        
        try {
            const response = await fetch('/api/set_bag_settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    settings: settings
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Settings saved successfully!');
            } else {
                alert('Error saving settings: ' + result.error);
            }
        } catch (error) {
            console.error('Error saving settings:', error);
            alert('Failed to save settings');
        }
    }

    // ============= Heatmap Functions =============
    
    // Load heatmap snapshots
    async function loadHeatmapSnapshots() {
        try {
            // Load all heatmap snapshots from all channels
            const url = '/api/get_heatmap_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayHeatmapSnapshots(result.snapshots);
            } else {
                console.error('Failed to load heatmap snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading heatmap snapshots:', error);
        }
    }
    
    // Display heatmap snapshots in grid
    function displayHeatmapSnapshots(snapshots) {
        const grid = document.getElementById('heatmap-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üî• No Snapshots Yet</h3>
                    <p>No heatmap snapshots available.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Heatmap to generate activity visualizations.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snapshot => `
            <div class="alert-gif-card">
                <div class="gif-preview">
                    <img src="/static/heatmaps/${snapshot.filename}" alt="Heatmap Snapshot" loading="lazy" style="cursor: pointer;" onclick="openLightboxFromImage(this)">
                </div>
                <div class="gif-info">
                    <div class="gif-channel">
                        <strong>üìπ Channel:</strong> ${snapshot.channel_id}
                    </div>
                    <div class="gif-time">
                        <strong>üïê Time:</strong> ${new Date(snapshot.created_at).toLocaleString()}
                    </div>
                    <div class="gif-stats">
                        <span>üíæ ${(snapshot.file_size / 1024).toFixed(2)} KB</span>
                    </div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm" onclick="downloadHeatmapSnapshot('${snapshot.filename}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteHeatmapSnapshot(${snapshot.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Download heatmap snapshot
    function downloadHeatmapSnapshot(filename) {
        const link = document.createElement('a');
        link.href = `/static/heatmaps/${filename}`;
        link.download = filename;
        link.click();
    }
    
    // Delete heatmap snapshot
    async function deleteHeatmapSnapshot(snapshotId) {
        if (!confirm('Are you sure you want to delete this snapshot?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_heatmap_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadHeatmapSnapshots();  // Reload the list
            } else {
                alert('Error deleting snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting snapshot:', error);
            alert('Failed to delete snapshot');
        }
    }
    
    // Clear old heatmap snapshots (7+ days)
    async function clearOldHeatmapSnapshots() {
        if (!confirm('Delete all snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_heatmap_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count} old snapshots`);
                loadHeatmapSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old heatmap snapshots:', error);
        }
    }
    
    // Capture manual heatmap snapshot
    async function captureHeatmapSnapshot() {
        const selector = document.getElementById('hm-channel-selector');
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        try {
            const response = await fetch('/api/capture_heatmap_snapshot', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Snapshot captured successfully!');
                // Switch to snapshots tab and reload
                openTab({target: document.querySelector('[onclick*="HeatmapSnapshots"]')}, 'HeatmapSnapshots');
                loadHeatmapSnapshots();
            } else {
                alert('Error capturing snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error capturing snapshot:', error);
            alert('Failed to capture snapshot');
        }
    }
    
    // Save heatmap settings
    async function saveHeatmapSettings() {
        const settings = {
            decay_rate: parseFloat(document.getElementById('hm-decay-rate').value),
            snapshot_interval: parseInt(document.getElementById('hm-snapshot-interval').value),
            intensity: parseFloat(document.getElementById('hm-intensity').value)
        };
        
        const selector = document.getElementById('hm-channel-selector');
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        try {
            const response = await fetch('/api/set_heatmap_settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId,
                    ...settings
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Settings saved successfully!');
            } else {
                alert('Error saving settings: ' + result.error);
            }
        } catch (error) {
            console.error('Error saving settings:', error);
            alert('Failed to save settings');
        }
    }

    // ============= Cash Detection Functions =============
    
    // Load cash detection snapshots
    async function loadCashSnapshots() {
        try {
            // Load all cash detection snapshots from all channels
            const url = '/api/get_cash_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayCashSnapshots(result.snapshots);
            } else {
                console.error('Failed to load cash snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading cash snapshots:', error);
        }
    }
    
    // Display cash snapshots in grid
    function displayCashSnapshots(snapshots) {
        const grid = document.getElementById('cash-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üíµ No Detections Yet</h3>
                    <p>No cash detected yet.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Cash Detection to monitor for cash/money.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snapshot => `
            <div class="alert-gif-card">
                <div class="gif-preview">
                    <img src="/static/cash_snapshots/${snapshot.snapshot_filename}" alt="Cash Detection" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">
                </div>
                <div class="gif-info">
                    <div class="gif-channel">
                        <strong>Channel:</strong> ${snapshot.channel_id}
                    </div>
                    <div class="gif-time">
                        <strong>Time:</strong> ${new Date(snapshot.created_at).toLocaleString()}
                    </div>
                    <div class="gif-message">
                        <strong>Alert:</strong> ${snapshot.alert_message}
                    </div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm" onclick="downloadCashSnapshot('${snapshot.snapshot_filename}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteCashSnapshot(${snapshot.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Download cash snapshot
    function downloadCashSnapshot(filename) {
        const link = document.createElement('a');
        link.href = `/static/cash_snapshots/${filename}`;
        link.download = filename;
        link.click();
    }
    
    // Delete cash snapshot
    async function deleteCashSnapshot(snapshotId) {
        if (!confirm('Are you sure you want to delete this detection snapshot?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_cash_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadCashSnapshots();  // Reload the list
            } else {
                alert('Error deleting snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting snapshot:', error);
            alert('Failed to delete snapshot');
        }
    }
    
    // Clear old cash snapshots (7+ days)
    async function clearOldCashSnapshots() {
        if (!confirm('Delete all cash detection snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_cash_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count} old snapshots`);
                loadCashSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old cash snapshots:', error);
        }
    }
    
    // Export cash detection data to Excel
    async function exportCashDetectionExcel(event) {
        try {
            // Get optional parameters
            const channelId = document.getElementById('cd-channel-selector')?.value || null;
            const days = prompt('Enter number of days to export (default: 30):', '30') || '30';
            
            // Build URL with parameters
            let url = `/api/export_cash_detection_excel?days=${days}`;
            if (channelId) {
                url += `&channel_id=${channelId}`;
            }
            
            // Show loading message
            const btn = event?.target || document.querySelector('button[onclick*="exportCashDetectionExcel"]');
            const originalText = btn ? btn.innerHTML : 'üìä Download Excel Summary';
            if (btn) {
                btn.innerHTML = '‚è≥ Generating Excel...';
                btn.disabled = true;
            }
            
            // Fetch and download
            const response = await fetch(url);
            
            if (response.ok) {
                const blob = await response.blob();
                const downloadUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = `cash_detection_summary_${new Date().toISOString().split('T')[0]}.xlsx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(downloadUrl);
                
                // Show success message
                alert('‚úÖ Excel file downloaded successfully!');
            } else {
                const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                alert('‚ùå Error generating Excel: ' + (error.error || 'Unknown error'));
            }
            
            // Restore button
            if (btn) {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
            
        } catch (error) {
            console.error('Error exporting Excel:', error);
            alert('‚ùå Failed to export Excel file. Please try again.');
            const btn = event?.target || document.querySelector('button[onclick*="exportCashDetectionExcel"]');
            if (btn) {
                btn.disabled = false;
            }
        }
    }
    
    // Save cash detection settings
    async function saveCashDetectionSettings() {
        const settings = {
            confidence_threshold: parseFloat(document.getElementById('cd-confidence').value),
            alert_cooldown: parseInt(document.getElementById('cd-alert-cooldown').value)
        };
        
        const selector = document.getElementById('cd-channel-selector');
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please start cash detection on a channel first');
            return;
        }
        
        try {
            const response = await fetch('/api/update_cash_detection_config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId,
                    config: settings
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Settings saved successfully!');
            } else {
                alert('Error saving settings: ' + result.error);
            }
        } catch (error) {
            console.error('Error saving settings:', error);
            alert('Failed to save settings');
        }
    }
    
    // ============= Unauthorized Entry Monitor Functions =============
    
    // Load unauthorized entry alerts
    async function loadUnauthorizedEntryAlerts() {
        try {
            console.log('üö® Loading unauthorized entry alerts...');
            const response = await fetch('/api/get_alert_gifs?alert_type=unauthorized_entry_alert&days=7&limit=50');
            const result = await response.json();
            
            console.log('üö® Unauthorized entry alerts response:', result);
            
            if (result.success) {
                // Endpoint returns 'alert_gifs' not 'alerts'
                const alerts = result.alert_gifs || result.alerts || [];
                console.log(`üö® Found ${alerts.length} unauthorized entry alerts`);
                displayUnauthorizedEntryAlerts(alerts);
                updateUnauthorizedEntryStats();
            } else {
                console.error('Failed to load unauthorized entry alerts:', result.error);
                document.getElementById('unauthorized-entry-alerts-grid').innerHTML = `
                    <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                        Error loading alerts: ${result.error || 'Unknown error'}
                    </p>
                `;
            }
        } catch (error) {
            console.error('Error loading unauthorized entry alerts:', error);
            document.getElementById('unauthorized-entry-alerts-grid').innerHTML = `
                <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                    Error loading alerts. Please try again.
                </p>
            `;
        }
    }
    
    function displayUnauthorizedEntryAlerts(alerts) {
        const grid = document.getElementById('unauthorized-entry-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>‚úÖ All Clear</h3>
                    <p>No unauthorized entry alerts detected in the last 7 days.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => {
            const gifPath = alert.gif_path || alert.snapshot_path || '';
            const timestamp = new Date(alert.timestamp || alert.created_at).toLocaleString();
            const alertData = typeof alert.alert_data === 'string' ? JSON.parse(alert.alert_data) : (alert.alert_data || {});
            const personCount = alertData.person_count || 1;
            
            return `
                <div class="alert-gif-card">
                    ${gifPath ? `
                        <div class="gif-preview">
                            <img src="/${gifPath}" alt="Unauthorized Entry Alert" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">
                        </div>
                    ` : `
                        <div class="gif-preview" style="background: #1f2937; display: flex; align-items: center; justify-content: center; min-height: 150px;">
                            <span style="color: #9ca3af;">No GIF available</span>
                        </div>
                    `}
                    <div class="gif-info">
                        <div class="gif-channel"><strong>üìπ</strong> ${alert.channel_id}</div>
                        <div class="gif-time"><strong>üïê</strong> ${timestamp}</div>
                        <div style="color: #ef4444;"><strong>üö®</strong> ${personCount} person(s) detected</div>
                        ${alert.alert_message ? `<div style="color: var(--text-secondary); font-size: 0.9em; margin-top: 5px;">${alert.alert_message}</div>` : ''}
                    </div>
                    <div class="gif-actions">
                        ${gifPath ? `
                            <button class="btn btn-sm btn-primary" onclick="downloadUnauthorizedEntryGif('${gifPath}')">üì• Download</button>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');
    }
    
    async function updateUnauthorizedEntryStats() {
        try {
            const response = await fetch('/api/get_module_analytics/UnauthorizedEntryMonitor');
            const result = await response.json();
            
            if (result.success && result.analytics) {
                const analytics = result.analytics;
                document.getElementById('uem-total-alerts').textContent = analytics.total_alerts_7days || 0;
                document.getElementById('uem-today-alerts').textContent = analytics.today_alerts || 0;
                document.getElementById('uem-active-channels').textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating unauthorized entry stats:', error);
        }
    }
    
    function downloadUnauthorizedEntryGif(gifPath) {
        try {
            const link = document.createElement('a');
            link.href = `/${gifPath}`;
            link.download = gifPath.split('/').pop();
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            console.error('Error downloading GIF:', error);
            alert('Failed to download GIF');
        }
    }
    
    async function exportUnauthorizedEntryExcel() {
        try {
            // Get parameters (optional: can add channel filter later)
            const channelId = null; // Can be set from a dropdown if needed
            const days = 30; // Default to last 30 days
            
            // Build URL with parameters
            let url = `/api/export_unauthorized_entry_excel?days=${days}`;
            if (channelId) {
                url += `&channel_id=${channelId}`;
            }
            
            // Create a temporary link and trigger download
            const link = document.createElement('a');
            link.href = url;
            link.download = `unauthorized_entry_report_${new Date().toISOString().split('T')[0]}.xlsx`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Show success message
            alert('Excel report download started. If it doesn\'t start automatically, check your browser\'s download settings.');
        } catch (error) {
            console.error('Error exporting Excel report:', error);
            alert('Failed to export Excel report: ' + (error.message || 'Unknown error'));
        }
    }
    
    async function clearOldUnauthorizedEntryAlerts() {
        if (!confirm('Delete all unauthorized entry alerts older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_alerts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    alert_type: 'unauthorized_entry_alert',
                    days: 7 
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Old alerts cleared successfully');
                loadUnauthorizedEntryAlerts();
            } else {
                alert('Error clearing alerts: ' + (result.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error clearing old alerts:', error);
            alert('Failed to clear old alerts');
        }
    }
    
    // ============= Smoking Detection Functions =============
    
    async function loadPersonSmokingAlerts() {
        try {
            console.log('üö¨ Loading smoking alerts...');
            const response = await fetch('/api/get_alert_gifs?alert_type=person_smoking_alert&days=7&limit=50');
            const result = await response.json();
            
            if (result.success) {
                const alerts = result.alert_gifs || result.alerts || [];
                console.log(`üö¨ Found ${alerts.length} smoking alerts`);
                displayPersonSmokingAlerts(alerts);
                updatePersonSmokingStats();
            } else {
                document.getElementById('person-smoking-alerts-grid').innerHTML = `
                    <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                        Error loading alerts: ${result.error || 'Unknown error'}
                    </p>
                `;
            }
        } catch (error) {
            console.error('Error loading smoking alerts:', error);
            document.getElementById('person-smoking-alerts-grid').innerHTML = `
                <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                    Error loading alerts. Please try again.
                </p>
            `;
        }
    }
    
    function displayPersonSmokingAlerts(alerts) {
        const grid = document.getElementById('person-smoking-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>‚úÖ All Clear</h3>
                    <p>No smoking alerts detected in the last 7 days.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => {
            const gifPath = alert.gif_path || alert.snapshot_path || '';
            const timestamp = new Date(alert.timestamp || alert.created_at).toLocaleString();
            const alertData = typeof alert.alert_data === 'string' ? JSON.parse(alert.alert_data) : (alert.alert_data || {});
            const detectionCount = alertData.detection_count || 1;
            
            return `
                <div class="alert-gif-card">
                    ${gifPath ? `
                        <div class="gif-preview">
                            <img src="/${gifPath}" alt="Smoking Alert" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">
                        </div>
                    ` : `
                        <div class="gif-preview" style="background: #1f2937; display: flex; align-items: center; justify-content: center; min-height: 150px;">
                            <span style="color: #9ca3af;">No GIF available</span>
                        </div>
                    `}
                    <div class="gif-info">
                        <div class="gif-channel"><strong>üìπ</strong> ${alert.channel_id}</div>
                        <div class="gif-time"><strong>üïê</strong> ${timestamp}</div>
                        <div style="color: #ef4444;"><strong>üö¨</strong> ${detectionCount} detection(s)</div>
                        ${alert.alert_message ? `<div style="color: var(--text-secondary); font-size: 0.9em; margin-top: 5px;">${alert.alert_message}</div>` : ''}
                    </div>
                    <div class="gif-actions">
                        ${gifPath ? `
                            <button class="btn btn-sm btn-primary" onclick="downloadPersonSmokingGif('${gifPath}')">üì• Download</button>
                        ` : ''}
                        <button class="btn btn-sm" onclick="deletePersonSmokingAlert(${alert.id})" style="background-color: #d73a49; color: white;">üóëÔ∏è Delete</button>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    async function updateSmokeFireStats() {
        try {
            const response = await fetch('/api/get_module_analytics/SmokingDetection');
            const result = await response.json();
            if (result.success) {
                const analytics = result.analytics || {};
                document.getElementById('smoking-total-alerts').textContent = analytics.total_alerts_7days || 0;
                document.getElementById('smoking-total-detections').textContent = analytics.total_detections_7days || analytics.total_detections || 0;
                document.getElementById('smoking-active-channels').textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating smoke & fire stats:', error);
        }
    }
    
    async function updatePersonSmokingStats() {
        try {
            const response = await fetch('/api/get_module_analytics/PersonSmokingDetection');
            const result = await response.json();
            
            if (result.success && result.analytics) {
                const analytics = result.analytics;
                document.getElementById('psmoking-total-alerts').textContent = analytics.total_alerts_7days || 0;
                document.getElementById('psmoking-today-alerts').textContent = analytics.today_alerts || 0;
                document.getElementById('psmoking-active-channels').textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating smoking stats:', error);
        }
    }
    
    async function deletePersonSmokingAlert(alertId) {
        if (!confirm('Are you sure you want to delete this smoking alert?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_alert_gif/${alertId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            
            if (result.success) {
                alert('Smoking alert deleted successfully');
                loadPersonSmokingAlerts(); // Reload the grid
            } else {
                alert(`Failed to delete alert: ${result.error}`);
            }
        } catch (error) {
            console.error('Error deleting smoking alert:', error);
            alert('Failed to delete alert');
        }
    }
    
    function downloadPersonSmokingGif(gifPath) {
        try {
            const link = document.createElement('a');
            link.href = `/${gifPath}`;
            link.download = gifPath.split('/').pop();
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            console.error('Error downloading GIF:', error);
            alert('Failed to download GIF');
        }
    }
    
    async function clearOldPersonSmokingAlerts() {
        if (!confirm('Delete all smoking alerts older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_alerts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    alert_type: 'person_smoking_alert',
                    days: 7 
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Old alerts cleared successfully');
                loadPersonSmokingAlerts();
            } else {
                alert('Error clearing alerts: ' + (result.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error clearing old alerts:', error);
            alert('Failed to clear old alerts');
        }
    }
    
    // ============= Material Theft / Misuse Functions =============
    async function loadMaterialTheftAlerts() {
        try {
            const response = await fetch('/api/get_alert_gifs?alert_type=material_theft_alert&days=7&limit=50');
            const result = await response.json();
            
            if (result.success) {
                const alerts = result.alert_gifs || result.alerts || [];
                displayMaterialTheftAlerts(alerts);
                updateMaterialTheftStats();
            } else {
                document.getElementById('mtm-alerts-grid').innerHTML = `
                    <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                        Error loading alerts: ${result.error || 'Unknown error'}
                    </p>
                `;
            }
        } catch (error) {
            console.error('Error loading material theft alerts:', error);
            document.getElementById('mtm-alerts-grid').innerHTML = `
                <p style="color: var(--text-secondary); text-align: center; padding: 40px;">
                    Error loading alerts. Please try again.
                </p>
            `;
        }
    }
    
    function displayMaterialTheftAlerts(alerts) {
        const grid = document.getElementById('mtm-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>‚úÖ All Clear</h3>
                    <p>No material theft alerts detected in the last 7 days.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => {
            const gifPath = alert.gif_path || alert.snapshot_path || '';
            const timestamp = new Date(alert.timestamp || alert.created_at).toLocaleString();
            const alertData = typeof alert.alert_data === 'string' ? JSON.parse(alert.alert_data) : (alert.alert_data || {});
            const stillFrames = alertData.still_frames || alertData.detection_count || 0;
            
            return `
                <div class="alert-gif-card">
                    ${gifPath ? `
                        <div class="gif-preview">
                            <img src="/${gifPath}" alt="Material Theft Alert" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">
                        </div>
                    ` : `
                        <div class="gif-preview" style="background: #1f2937; display: flex; align-items: center; justify-content: center; min-height: 150px;">
                            <span style="color: #9ca3af;">No GIF available</span>
                        </div>
                    `}
                    <div class="gif-info">
                        <div class="gif-channel"><strong>üìπ</strong> ${alert.channel_id}</div>
                        <div class="gif-time"><strong>üïê</strong> ${timestamp}</div>
                        <div style="color: #f59e0b;"><strong>üì¶</strong> Still frames: ${stillFrames}</div>
                        ${alert.alert_message ? `<div style="color: var(--text-secondary); font-size: 0.9em; margin-top: 5px;">${alert.alert_message}</div>` : ''}
                    </div>
                    <div class="gif-actions">
                        ${gifPath ? `
                            <button class="btn btn-sm btn-primary" onclick="downloadMaterialTheftGif('${gifPath}')">üì• Download</button>
                        ` : ''}
                        <button class="btn btn-sm btn-danger" onclick="deleteMaterialTheftAlert(${alert.id})">üóëÔ∏è Delete</button>
                    </div>
                </div>
            `;
        }).join('');
    }

    async function deleteMaterialTheftAlert(alertId) {
        if (!confirm('Delete this material theft alert?')) {
            return;
        }
        try {
            const response = await fetch(`/api/delete_alert_gif/${alertId}`, { method: 'DELETE' });
            const result = await response.json();
            if (result.success) {
                loadMaterialTheftAlerts();
            } else {
                alert('Error deleting alert: ' + (result.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error deleting material theft alert:', error);
            alert('Failed to delete alert');
        }
    }
    
    async function updateMaterialTheftStats() {
        try {
            const response = await fetch('/api/get_module_analytics/MaterialTheftMonitor');
            const result = await response.json();
            
            if (result.success && result.analytics) {
                const analytics = result.analytics;
                document.getElementById('mtm-total-alerts').textContent = analytics.total_alerts_7days || 0;
                document.getElementById('mtm-today-alerts').textContent = analytics.today_alerts || 0;
                document.getElementById('mtm-active-channels').textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating material theft stats:', error);
        }
    }
    
    function downloadMaterialTheftGif(gifPath) {
        try {
            const link = document.createElement('a');
            link.href = `/${gifPath}`;
            link.download = gifPath.split('/').pop();
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (error) {
            console.error('Error downloading GIF:', error);
            alert('Failed to download GIF');
        }
    }
    
    async function clearOldMaterialTheftAlerts() {
        if (!confirm('Delete all material theft alerts older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_alerts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    alert_type: 'material_theft_alert',
                    days: 7 
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Old alerts cleared successfully');
                loadMaterialTheftAlerts();
            } else {
                alert('Error clearing alerts: ' + (result.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error clearing old alerts:', error);
            alert('Failed to clear old alerts');
        }
    }
    // ============= Fall Detection Functions =============
    
    // Load fall detection snapshots
    async function loadFallSnapshots() {
        try {
            // Load all fall detection snapshots from all channels
            const url = '/api/get_fall_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayFallSnapshots(result.snapshots);
            } else {
                console.error('Failed to load fall snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading fall snapshots:', error);
        }
    }
    
    // Display fall snapshots in grid
    function displayFallSnapshots(snapshots) {
        const grid = document.getElementById('fall-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üö® No Fall Detections</h3>
                    <p>No person falls detected yet.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Fall Detection to monitor for emergency situations.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snapshot => `
            <div class="alert-gif-card">
                <div class="gif-preview">
                    <img src="${snapshot.snapshot_url || `/static/fall_snapshots/${snapshot.snapshot_filename}`}" alt="Fall Detection" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onerror="this.src='/static/images/placeholder.png'; this.onerror=null;" onclick="openLightboxFromImage(this)">
                </div>
                <div class="gif-info">
                    <div class="gif-channel">
                        <strong>üìπ Channel:</strong> ${snapshot.channel_id}
                    </div>
                    <div class="gif-time">
                        <strong>üïê Time:</strong> ${new Date(snapshot.created_at).toLocaleString()}
                    </div>
                    <div class="gif-message" style="color: #ef4444;">
                        <strong>üö® Alert:</strong> ${snapshot.alert_message}
                    </div>
                    <div class="gif-stats">
                        <span>‚è±Ô∏è Duration: ${snapshot.fall_duration}s</span>
                        <span>üíæ ${(snapshot.file_size / 1024).toFixed(2)} KB</span>
                    </div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm" onclick="downloadFallSnapshot('${snapshot.snapshot_url || `/static/fall_snapshots/${snapshot.snapshot_filename}`}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteFallSnapshot(${snapshot.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Download fall snapshot
    function downloadFallSnapshot(urlOrFilename) {
        const link = document.createElement('a');
        // If it's already a full URL, use it; otherwise construct the path
        if (urlOrFilename.startsWith('/static/')) {
            link.href = urlOrFilename;
            // Extract filename from path for download attribute
            const pathParts = urlOrFilename.split('/');
            link.download = pathParts[pathParts.length - 1];
        } else {
            link.href = `/static/fall_snapshots/${urlOrFilename}`;
            link.download = urlOrFilename;
        }
        link.click();
    }
    
    // Delete fall snapshot
    async function deleteFallSnapshot(snapshotId) {
        if (!confirm('Are you sure you want to delete this fall detection snapshot?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_fall_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadFallSnapshots();
            } else {
                alert('Error deleting snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting fall snapshot:', error);
        }
    }
    
    // Clear old fall snapshots
    async function clearOldFallSnapshots() {
        if (!confirm('Delete all fall detection snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_fall_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count} old snapshots`);
                loadFallSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old fall snapshots:', error);
        }
    }
    
    // Save fall detection settings
    async function saveFallDetectionSettings() {
        const settings = {
            confidence_threshold: parseFloat(document.getElementById('fd-confidence').value),
            fall_duration_threshold: parseFloat(document.getElementById('fd-fall-duration').value),
            alert_cooldown: parseInt(document.getElementById('fd-alert-cooldown').value)
        };
        
        const selector = document.getElementById('fd-channel-selector');
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please start fall detection on a channel first');
            return;
        }
        
        try {
            const response = await fetch('/api/update_fall_detection_config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId,
                    config: settings
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Settings saved successfully!');
            } else {
                alert('Error saving settings: ' + result.error);
            }
        } catch (error) {
            console.error('Error saving settings:', error);
            alert('Failed to save settings');
        }
    }

    // Mopping Detection Functions
    async function loadMoppingSnapshots() {
        try {
            // Load all mopping detection snapshots from all channels
            const url = '/api/get_mopping_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayMoppingSnapshots(result.snapshots);
            } else {
                console.error('Failed to load mopping snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading mopping snapshots:', error);
        }
    }
    
    // Display mopping snapshots in grid
    function displayMoppingSnapshots(snapshots) {
        const grid = document.getElementById('mopping-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üßπ No Mopping Detections</h3>
                    <p>No mopping activity detected yet.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Mopping Detection to monitor cleaning activities.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snap => `
            <div class="alert-card">
                <img src="${snap.snapshot_url}" alt="Mopping Detection" loading="lazy" style="cursor: pointer;" onclick="openLightboxFromImage(this)">
                <div class="alert-info">
                    <div class="alert-time">üßπ ${snap.time_formatted || new Date(snap.created_at).toLocaleString()}</div>
                    <div class="alert-channel">üìπ ${snap.channel_id}</div>
                    <div class="alert-details">${snap.alert_message || 'Mopping detected'}</div>
                    <div class="alert-stats">Detections: ${snap.detection_count || 1}</div>
                    <button class="btn-delete" onclick="deleteMoppingSnapshot(${snap.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Delete individual mopping snapshot
    async function deleteMoppingSnapshot(snapshotId) {
        console.log('üóëÔ∏è DELETE BUTTON CLICKED! Snapshot ID:', snapshotId);
        
        if (!confirm('Delete this mopping detection snapshot?')) {
            console.log('‚ùå User cancelled delete');
            return;
        }
        
        console.log('‚úì User confirmed, proceeding with delete...');
        
        try {
            console.log('üì° Sending DELETE request to:', `/api/delete_mopping_snapshot/${snapshotId}`);
            const response = await fetch(`/api/delete_mopping_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            console.log('üì® Response status:', response.status);
            const result = await response.json();
            console.log('üì¶ Response data:', result);
            
            if (result.success) {
                console.log('‚úÖ DELETE SUCCESSFUL!');
                alert('‚úÖ Snapshot deleted successfully!');
                console.log('üîÑ Reloading snapshots...');
                loadMoppingSnapshots();
            } else {
                console.error('‚ùå DELETE FAILED:', result.error);
                alert('‚ùå Error deleting snapshot: ' + (result.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('üí• EXCEPTION during delete:', error);
            alert('üí• Failed to delete snapshot. Error: ' + error.message);
        }
    }
    
    // Clear old mopping snapshots
    async function clearOldMoppingSnapshots() {
        if (!confirm('Delete all mopping detection snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_mopping_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count || 0} old snapshots`);
                loadMoppingSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old mopping snapshots:', error);
        }
    }

    // Smoking Detection Functions
    async function loadSmokingSnapshots() {
        try {
            // Load all smoking detection snapshots from all channels
            const url = '/api/get_smoking_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displaySmokingSnapshots(result.snapshots);
            } else {
                console.error('Failed to load smoking snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading smoking snapshots:', error);
        }
    }
    
    // Display smoke & fire snapshots in grid
    function displaySmokingSnapshots(snapshots) {
        const grid = document.getElementById('smoking-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üî• No Smoke & Fire Detections</h3>
                    <p>No smoke or fire events detected yet.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Smoke & Fire Detection is monitoring for safety hazards.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snap => `
            <div class="alert-card">
                <img src="/static/smoking_snapshots/${snap.snapshot_filename}" alt="Smoke & Fire Detection" loading="lazy" style="cursor: pointer;" onclick="openLightboxFromImage(this)">
                <div class="alert-info">
                    <div class="alert-time">üî• ${snap.time_formatted || new Date(snap.created_at).toLocaleString()}</div>
                    <div class="alert-channel">üìπ ${snap.channel_id}</div>
                    <div class="alert-details">${snap.alert_message || 'Smoke or Fire detected'}</div>
                    <div class="alert-stats">Detections: ${snap.detection_count || 1}</div>
                    <button class="btn-delete" onclick="deleteSmokingSnapshot(${snap.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Delete individual smoke & fire snapshot
    async function deleteSmokingSnapshot(snapshotId) {
        if (!confirm('Delete this smoke & fire detection snapshot?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_smoking_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadSmokingSnapshots();
            } else {
                alert('Error deleting snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting smoking snapshot:', error);
        }
    }
    
    // Clear old smoke & fire snapshots
    async function clearOldSmokingSnapshots() {
        if (!confirm('Delete all smoke & fire detection snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_smoking_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count || 0} old snapshots`);
                loadSmokingSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old smoking snapshots:', error);
        }
    }
    
    // ==================== Crowd Detection ROI Configuration ====================
    
    async function openCrowdRoiModal() {
        const modal = document.getElementById('crowdRoiModal');
        if (!modal) return;
        
        // Populate channel selector
        const channelSelect = document.getElementById('crowdRoiChannelSelect');
        if (channelSelect) {
            channelSelect.innerHTML = '<option value="">Loading channels...</option>';
            
            try {
                // Get all active channels
                const response = await fetch('/api/get_active_channels');
                const result = await response.json();
                
                channelSelect.innerHTML = '<option value="">Select Channel...</option>';
                
                if (result.success && result.active_channels) {
                    // Filter channels that have CrowdDetection
                    const crowdChannels = result.active_channels.filter(ch => 
                        ch.modules && ch.modules.includes('CrowdDetection')
                    );
                    
                    if (crowdChannels.length > 0) {
                        crowdChannels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.channel_id;
                            option.textContent = `${channel.channel_id}${channel.name ? ` - ${channel.name}` : ''}`;
                            channelSelect.appendChild(option);
                        });
                    } else {
                        // If no active channels, try to get from all channels
                        const allChannelsResponse = await fetch('/api/get_channels/CrowdDetection');
                        const allChannels = await allChannelsResponse.json();
                        
                        if (Array.isArray(allChannels)) {
                            allChannels.forEach(channel => {
                                const option = document.createElement('option');
                                option.value = channel.id || channel.channel_id;
                                option.textContent = channel.name || channel.id || channel.channel_id;
                                channelSelect.appendChild(option);
                            });
                        }
                    }
                } else {
                    // Fallback: try to get from all channels
                    const allChannelsResponse = await fetch('/api/get_channels/CrowdDetection');
                    const allChannels = await allChannelsResponse.json();
                    
                    if (Array.isArray(allChannels)) {
                        allChannels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id || channel.channel_id;
                            option.textContent = channel.name || channel.id || channel.channel_id;
                            channelSelect.appendChild(option);
                        });
                    }
                }
                
                if (channelSelect.options.length === 1) {
                    channelSelect.innerHTML = '<option value="">No channels available</option>';
                }
            } catch (error) {
                console.error('Error loading channels:', error);
                channelSelect.innerHTML = '<option value="">Error loading channels</option>';
            }
        }
        
        modal.style.display = 'block';
    }
    
    function closeCrowdRoiModal() {
        const modal = document.getElementById('crowdRoiModal');
        if (modal) {
            modal.style.display = 'none';
            crowdRoiState.currentChannel = null;
            crowdRoiState.points = [];
            crowdRoiState.imageLoaded = false;
        }
    }
    
    function loadCrowdRoiChannel() {
        const channelSelect = document.getElementById('crowdRoiChannelSelect');
        const channelId = channelSelect.value;
        
        if (!channelId) {
            crowdRoiState.currentChannel = null;
            return;
        }
        
        crowdRoiState.currentChannel = channelId;
        
        // Load video feed
        const image = document.getElementById('crowdRoiImage');
        const canvas = document.getElementById('crowdRoiCanvas');
        
        if (image && canvas) {
            crowdRoiState.canvas = canvas;
            crowdRoiState.ctx = canvas.getContext('2d');
            
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.style.width = image.offsetWidth + 'px';
                canvas.style.height = image.offsetHeight + 'px';
                crowdRoiState.imageLoaded = true;
                drawCrowdRoi();
                setupCrowdRoiInteraction();
            };
            
            image.src = `/video_feed/CrowdDetection/${channelId}?t=${Date.now()}`;
        }
        
        // Load existing ROI
        loadCrowdRoi();
    }
    
    async function loadCrowdRoi() {
        const channelId = crowdRoiState.currentChannel;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        try {
            const response = await fetch(`/api/get_crowd_roi/${channelId}`);
            const result = await response.json();
            
            if (result.success && result.roi_points && result.roi_points.length > 0) {
                // Convert normalized coordinates to pixel coordinates if needed
                if (result.roi_points[0] && typeof result.roi_points[0] === 'object' && 'x' in result.roi_points[0]) {
                    // Normalized coordinates - convert to pixels
                    const canvas = crowdRoiState.canvas;
                    if (canvas) {
                        crowdRoiState.points = result.roi_points.map(p => [
                            p.x * canvas.width,
                            p.y * canvas.height
                        ]);
                    } else {
                        crowdRoiState.points = result.roi_points.map(p => [p.x, p.y]);
                    }
                } else {
                    // Already in pixel coordinates
                    crowdRoiState.points = result.roi_points;
                }
                updateCrowdRoiInfo();
                if (crowdRoiState.imageLoaded) {
                    drawCrowdRoi();
                }
            } else {
                crowdRoiState.points = [];
                updateCrowdRoiInfo();
                if (crowdRoiState.imageLoaded) {
                    drawCrowdRoi();
                }
            }
        } catch (error) {
            console.error('Error loading ROI:', error);
            crowdRoiState.points = [];
            updateCrowdRoiInfo();
        }
    }
    
    function drawCrowdRoi() {
        if (!crowdRoiState.ctx || !crowdRoiState.imageLoaded) return;
        
        const ctx = crowdRoiState.ctx;
        const canvas = crowdRoiState.canvas;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (crowdRoiState.points.length > 0) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            
            ctx.beginPath();
            ctx.moveTo(crowdRoiState.points[0][0], crowdRoiState.points[0][1]);
            for (let i = 1; i < crowdRoiState.points.length; i++) {
                ctx.lineTo(crowdRoiState.points[i][0], crowdRoiState.points[i][1]);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw points
            crowdRoiState.points.forEach((point, index) => {
                ctx.fillStyle = index === crowdRoiState.hoverPointIndex ? '#ffff00' : '#00ff00';
                ctx.beginPath();
                ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
    }
    
    function setupCrowdRoiInteraction() {
        const canvas = crowdRoiState.canvas;
        if (!canvas) return;
        
        canvas.onmousedown = function(e) {
            if (!crowdRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Check if clicking on existing point
            let clickedPointIndex = -1;
            crowdRoiState.points.forEach((point, index) => {
                const dist = Math.hypot(mx - point[0], my - point[1]);
                if (dist < 10) {
                    clickedPointIndex = index;
                }
            });
            
            if (clickedPointIndex >= 0) {
                crowdRoiState.isDragging = true;
                crowdRoiState.dragPointIndex = clickedPointIndex;
            } else {
                // Add new point
                crowdRoiState.points.push([mx, my]);
                drawCrowdRoi();
                updateCrowdRoiInfo();
            }
        };
        
        canvas.onmousemove = function(e) {
            if (!crowdRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            if (crowdRoiState.isDragging && crowdRoiState.dragPointIndex >= 0) {
                crowdRoiState.points[crowdRoiState.dragPointIndex] = [mx, my];
                drawCrowdRoi();
                updateCrowdRoiInfo();
            } else {
                // Check hover
                let hoverIndex = -1;
                crowdRoiState.points.forEach((point, index) => {
                    const dist = Math.hypot(mx - point[0], my - point[1]);
                    if (dist < 10) {
                        hoverIndex = index;
                    }
                });
                
                if (hoverIndex !== crowdRoiState.hoverPointIndex) {
                    crowdRoiState.hoverPointIndex = hoverIndex;
                    drawCrowdRoi();
                }
                
                canvas.style.cursor = hoverIndex >= 0 ? 'move' : 'crosshair';
            }
        };
        
        canvas.onmouseup = function() {
            crowdRoiState.isDragging = false;
            crowdRoiState.dragPointIndex = -1;
        };
        
        canvas.onmouseleave = function() {
            crowdRoiState.isDragging = false;
            crowdRoiState.dragPointIndex = -1;
            crowdRoiState.hoverPointIndex = -1;
            drawCrowdRoi();
        };
        
        canvas.ondblclick = function(e) {
            if (!crowdRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Find and remove closest point
            let removeIndex = -1;
            let minDist = Infinity;
            crowdRoiState.points.forEach((point, index) => {
                const px = point[0];
                const py = point[1];
                const dist = Math.hypot(mx - px, my - py);
                if (dist < minDist && dist < 10) {
                    minDist = dist;
                    removeIndex = index;
                }
            });
            
            if (removeIndex >= 0) {
                crowdRoiState.points.splice(removeIndex, 1);
                drawCrowdRoi();
                updateCrowdRoiInfo();
            }
        };
    }
    
    function updateCrowdRoiInfo() {
        const infoDiv = document.getElementById('crowdRoiInfo');
        const coordsDiv = document.getElementById('crowdRoiCoordinates');
        if (!infoDiv) return;
        
        const channelId = crowdRoiState.currentChannel || 'None';
        const pointCount = crowdRoiState.points.length;
        
        infoDiv.innerHTML = `
            <strong>ROI Status:</strong>
            <div style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                Channel: ${channelId}<br>
                Points: ${pointCount} ${pointCount >= 3 ? '‚úì' : '(need at least 3)'}
            </div>
        `;
        
        if (coordsDiv && crowdRoiState.points.length > 0) {
            // Convert to normalized coordinates for display
            const canvas = crowdRoiState.canvas;
            let normalizedPoints = [];
            if (canvas) {
                normalizedPoints = crowdRoiState.points.map(p => ({
                    x: (p[0] / canvas.width).toFixed(6),
                    y: (p[1] / canvas.height).toFixed(6)
                }));
            } else {
                normalizedPoints = crowdRoiState.points;
            }
            const coords = JSON.stringify(normalizedPoints, null, 2);
            coordsDiv.innerHTML = `<strong>Coordinates (normalized):</strong><br><pre style="margin: 5px 0; font-size: 0.8em; max-height: 150px; overflow: auto;">${coords}</pre>`;
        } else if (coordsDiv) {
            coordsDiv.innerHTML = 'Coordinates will appear here as you draw...';
        }
    }
    
    function clearCrowdRoi() {
        crowdRoiState.points = [];
        if (crowdRoiState.imageLoaded) {
            drawCrowdRoi();
        }
        updateCrowdRoiInfo();
    }
    
    async function saveCrowdRoi() {
        if (!crowdRoiState.currentChannel) {
            alert('Please select a channel first');
            return;
        }
        
        if (crowdRoiState.points.length < 3) {
            alert('At least 3 points are required to form a polygon');
            return;
        }
        
        try {
            // Convert pixel coordinates to normalized coordinates
            const canvas = crowdRoiState.canvas;
            let normalizedPoints = [];
            if (canvas) {
                normalizedPoints = crowdRoiState.points.map(p => ({
                    x: p[0] / canvas.width,
                    y: p[1] / canvas.height
                }));
            } else {
                normalizedPoints = crowdRoiState.points;
            }
            
            const response = await fetch(`/api/set_crowd_roi/${crowdRoiState.currentChannel}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    roi_points: normalizedPoints
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`ROI saved successfully for ${crowdRoiState.currentChannel}!`);
                // Refresh the image to show updated ROI
                const image = document.getElementById('crowdRoiImage');
                if (image) {
                    image.src = `/video_feed/CrowdDetection/${crowdRoiState.currentChannel}?t=${Date.now()}`;
                }
            } else {
                alert(`Error saving ROI: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error saving ROI:', error);
            alert('Failed to save ROI configuration');
        }
    }

    // ==================== Crowd Detection Functions ====================
    
    async function updateCrowdStats() {
        try {
            const response = await fetch('/api/get_module_analytics/CrowdDetection');
            const result = await response.json();
            
            if (result.success && result.analytics) {
                const analytics = result.analytics;
                document.getElementById('crowd-total-alerts').textContent = analytics.total_alerts_7days || 0;
                document.getElementById('crowd-current-crowd').textContent = analytics.current_crowd_count || 0;
                document.getElementById('crowd-active-channels').textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating crowd stats:', error);
        }
    }
    
    async function loadCrowdAlerts() {
        try {
            const response = await fetch('/api/get_alert_gifs?alert_type=crowd_alert&limit=50&days=7');
            const result = await response.json();
            
            if (result.success) {
                displayCrowdAlerts(result.alert_gifs || result.alerts || []);
                // Update stats after loading alerts
                updateCrowdStats();
            } else {
                console.error('Failed to load crowd alerts:', result.error);
            }
        } catch (error) {
            console.error('Error loading crowd alerts:', error);
        }
    }
    
    function displayCrowdAlerts(alerts) {
        const grid = document.getElementById('crowd-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üë• No Crowd Alerts</h3>
                    <p>No crowd alerts detected yet.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => {
            const hasGif = alert.gif_filename && alert.gif_filename.length > 0;
            const gifUrl = hasGif ? `/static/alerts/${alert.gif_filename}` : 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="150"%3E%3Crect fill="%23ccc" width="200" height="150"/%3E%3Ctext x="50%25" y="50%25" text-anchor="middle" dy=".3em" fill="%23999"%3ENo GIF%3C/text%3E%3C/svg%3E';
            const alertData = alert.alert_data || {};
            
            return `
            <div class="alert-card">
                <img src="${gifUrl}" alt="Crowd Alert" loading="lazy" ${hasGif ? 'style="cursor: pointer;" onclick="openLightboxFromImage(this)"' : ''}>
                <div class="alert-info">
                    <div class="alert-time">üë• ${new Date(alert.created_at).toLocaleString()}</div>
                    <div class="alert-channel">üìπ ${alert.channel_id}</div>
                    <div class="alert-details">${alert.alert_message || 'Crowd detected'}</div>
                    <div class="alert-stats">
                        Crowd Count: ${alertData.crowd_count || alertData.raw_count || 'N/A'} | 
                        Long-stay: ${alertData.long_stay_count || 'N/A'} | 
                        Threshold: ${alertData.threshold || 'N/A'}
                    </div>
                    <button class="btn-delete" onclick="deleteCrowdAlert(${alert.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
            `;
        }).join('');
    }
    
    async function deleteCrowdAlert(alertId) {
        if (!confirm('Delete this crowd alert?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_alert_gif/${alertId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadCrowdAlerts();
            } else {
                alert('Error deleting alert: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting crowd alert:', error);
        }
    }
    
    async function clearOldCrowdAlerts() {
        if (!confirm('Delete all crowd alerts older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_alert_gifs', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ alert_type: 'crowd_alert', days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count || 0} old alerts`);
                loadCrowdAlerts();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old crowd alerts:', error);
        }
    }

    // ==================== Service Discipline Functions ====================
    
    async function loadServiceDisciplineAlerts() {
        try {
            // Fetch all violations, then filter to include only service discipline violations
            // This includes violations with waiting_time > 0 or violation_type = 'service_discipline'
            const response = await fetch('/api/get_table_service_violations?limit=100&days=7');
            const result = await response.json();
            
            if (result.success) {
                const allViolations = result.violations || [];
                
                // Filter to include ONLY service discipline violations:
                // 1. Must have a table_id (service discipline violations are table-specific)
                // 2. Must be explicitly marked as service_discipline in alert_data
                // 3. Must NOT be queue-related violations (exclude queue violations that might have been incorrectly saved)
                const serviceDisciplineViolations = allViolations.filter(violation => {
                    // Must have a table_id - service discipline violations are always table-specific
                    if (!violation.table_id) {
                        return false;
                    }
                    
                    // Check alert_data for violation type
                    if (violation.alert_data) {
                        try {
                            const alertData = typeof violation.alert_data === 'string' 
                                ? JSON.parse(violation.alert_data) 
                                : violation.alert_data;
                            
                            // Must be explicitly marked as service_discipline
                            if (alertData?.violation_type === 'service_discipline' || 
                                alertData?.violation_type === 'order_wait' ||
                                alertData?.violation_type === 'service_wait') {
                                // Exclude queue-related violations
                                const violationMessage = alertData?.violation_message || alertData?.message || '';
                                if (violationMessage.toLowerCase().includes('queue') || 
                                    violationMessage.toLowerCase().includes('staff at counter')) {
                                    return false;
                                }
                                return true;
                            }
                        } catch (e) {
                            // Continue to next check
                        }
                    }
                    
                    // If no alert_data, check if it has order_wait_time or service_wait_time
                    // (these are specific to service discipline, not queue monitoring)
                    if (violation.order_wait_time !== null && violation.order_wait_time !== undefined) {
                        return true;
                    }
                    if (violation.service_wait_time !== null && violation.service_wait_time !== undefined) {
                        return true;
                    }
                    
                    return false;
                });
                
                console.log(`‚úÖ Found ${serviceDisciplineViolations.length} service discipline violations (filtered from ${allViolations.length} total)`);
                displayServiceDisciplineAlerts(serviceDisciplineViolations);
                updateServiceDisciplineStats(serviceDisciplineViolations);
            } else {
                console.error('Failed to load service discipline alerts:', result.error);
                document.getElementById('service-discipline-alerts-grid').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        <p>Error loading alerts: ${result.error}</p>
                    </div>
                `;
            }
        } catch (error) {
            console.error('Error loading service discipline alerts:', error);
            document.getElementById('service-discipline-alerts-grid').innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <p>Error loading alerts. Please try again.</p>
                </div>
            `;
        }
    }
    
    function displayServiceDisciplineAlerts(violations) {
        const grid = document.getElementById('service-discipline-alerts-grid');
        
        if (!violations || violations.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üïí No Service Discipline Violations</h3>
                    <p>No violations detected in the last 7 days.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = violations.map(violation => {
            // Handle snapshot path - normalize Windows backslashes and construct URL
            let snapshotUrl = '/static/icon.png';
            if (violation.snapshot_path) {
                // Normalize path separators (Windows backslashes to forward slashes)
                let normalizedPath = violation.snapshot_path.replace(/\\/g, '/');
                
                // Remove leading/trailing slashes
                normalizedPath = normalizedPath.replace(/^\/+|\/+$/g, '');
                
                // Remove 'static/' prefix if present (to avoid double prefix)
                if (normalizedPath.toLowerCase().startsWith('static/')) {
                    normalizedPath = normalizedPath.substring(7);
                }
                
                // Construct URL - path should already be relative to static/
                if (normalizedPath.startsWith('http://') || normalizedPath.startsWith('https://')) {
                    snapshotUrl = normalizedPath;
                } else if (normalizedPath.startsWith('/')) {
                    snapshotUrl = normalizedPath;
                } else {
                    snapshotUrl = `/static/${normalizedPath}`;
                }
            }
            
            // Debug: log the snapshot URL for troubleshooting
            console.log('Service Discipline Violation:', {
                id: violation.id,
                snapshot_path: violation.snapshot_path,
                snapshotUrl: snapshotUrl
            });
            
            const timestamp = violation.timestamp || violation.created_at || new Date().toISOString();
            const waitTime = violation.waiting_time || 0; // seconds
            const orderWaitTime = violation.order_wait_time || null; // seconds
            const serviceWaitTime = violation.service_wait_time || null; // seconds
            
            const waitTimeMin = waitTime / 60.0;
            const orderWaitTimeMin = orderWaitTime ? (orderWaitTime / 60.0) : null;
            const serviceWaitTimeMin = serviceWaitTime ? (serviceWaitTime / 60.0) : null;
            
            const thresholdSec = 120;
            const thresholdMin = thresholdSec / 60.0;
            const waitTimeColor = waitTime > 180 ? '#ef4444' : (waitTime > thresholdSec ? '#f59e0b' : '#22c55e');
            const exceededBy = waitTime - thresholdSec; // seconds
            const exceededByMin = exceededBy / 60.0;
            const exceededByColor = exceededBy > 0 ? '#ef4444' : '#22c55e';
            
            // Color coding for order and service wait times
            const orderWaitColor = orderWaitTime && orderWaitTime > 60 ? '#ef4444' : (orderWaitTime && orderWaitTime > 30 ? '#f59e0b' : '#22c55e');
            const serviceWaitColor = serviceWaitTime && serviceWaitTime > 300 ? '#ef4444' : (serviceWaitTime && serviceWaitTime > 180 ? '#f59e0b' : '#22c55e');
            
            return `
            <div class="alert-gif-card" style="border-left: 4px solid ${waitTimeColor};">
                <div class="gif-preview">
                    <img src="${snapshotUrl}" alt="Service Discipline Violation" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer; min-height: 150px; object-fit: cover;" onclick="openLightboxFromImage(this)" onerror="this.src='/static/icon.png'; this.onerror=null; console.error('Failed to load image:', '${snapshotUrl}');">
                </div>
                <div class="gif-info">
                    <div class="gif-channel"><strong>üìπ Channel:</strong> ${violation.channel_id}</div>
                    <div class="gif-time"><strong>üïê Time:</strong> ${new Date(timestamp).toLocaleString()}</div>
                    <div style="color: #f59e0b;"><strong>üçΩÔ∏è Table:</strong> ${violation.table_id || 'Unknown'}</div>
                    
                    ${orderWaitTime !== null ? `
                    <div style="color: ${orderWaitColor}; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <strong>üìù Order Wait Time:</strong> ${orderWaitTimeMin.toFixed(1)} min
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-top: 2px;">Time from customer sits to order taken</div>
                    </div>
                    ` : ''}
                    
                    ${serviceWaitTime !== null ? `
                    <div style="color: ${serviceWaitColor}; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <strong>üçΩÔ∏è Service Wait Time:</strong> ${serviceWaitTimeMin.toFixed(1)} min
                        <div style="font-size: 0.85em; color: var(--text-secondary); margin-top: 2px;">Time from order taken to food served</div>
                    </div>
                    ` : ''}
                    
                    <div style="color: ${waitTimeColor}; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <strong>‚è±Ô∏è Total Wait Time:</strong> ${waitTimeMin.toFixed(1)} min
                    </div>
                    <div style="color: ${exceededByColor}; font-size: 0.9em; margin-top: 4px;">
                        <strong>Threshold:</strong> ${thresholdMin.toFixed(1)} min | <strong>Exceeded by:</strong> ${exceededBy > 0 ? '+' : ''}${exceededByMin.toFixed(1)} min
                    </div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm btn-primary" onclick="downloadServiceDisciplineSnapshot(${violation.id}, '${violation.snapshot_path || snapshotUrl}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteServiceDisciplineViolation(${violation.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `;
        }).join('');
    }
    
    function updateServiceDisciplineStats(violations) {
        if (!violations || violations.length === 0) {
            document.getElementById('sdm-max-order-wait').textContent = '0.0 min';
            document.getElementById('sdm-max-service-wait').textContent = '0.0 min';
            document.getElementById('sdm-max-wait').textContent = '0.0 min';
            document.getElementById('sdm-alerts-7d').textContent = '0';
            return;
        }
        
        // Calculate stats separately for order wait time and service wait time
        // Filter out unrealistic/outlier values (e.g., > 1 hour = 3600s)
        const maxReasonableWait = 3600; // 1 hour maximum
        
        // Calculate max order wait time (time from customer sits to order taken)
        const orderWaitTimes = violations
            .map(v => v.order_wait_time)
            .filter(w => w !== null && w !== undefined && w > 0 && w <= maxReasonableWait);
        const maxOrderWait = orderWaitTimes.length > 0 ? Math.max(...orderWaitTimes) : 0;
        
        // Calculate max service wait time (time from order taken to food served)
        const serviceWaitTimes = violations
            .map(v => v.service_wait_time)
            .filter(w => w !== null && w !== undefined && w > 0 && w <= maxReasonableWait);
        const maxServiceWait = serviceWaitTimes.length > 0 ? Math.max(...serviceWaitTimes) : 0;
        
        // Calculate max total wait time
        const totalWaitTimes = violations
            .map(v => v.waiting_time || 0)
            .filter(w => w > 0 && w <= maxReasonableWait);
        const maxTotalWait = totalWaitTimes.length > 0 ? Math.max(...totalWaitTimes) : 0;
        
        // Update display
        document.getElementById('sdm-max-order-wait').textContent = `${(maxOrderWait / 60).toFixed(1)} min`;
        document.getElementById('sdm-max-service-wait').textContent = `${(maxServiceWait / 60).toFixed(1)} min`;
        document.getElementById('sdm-max-wait').textContent = `${(maxTotalWait / 60).toFixed(1)} min`;
        document.getElementById('sdm-alerts-7d').textContent = violations.length;
    }
    
    function downloadServiceDisciplineSnapshot(violationId, snapshotPath) {
        const url = snapshotPath.startsWith('/') ? snapshotPath : `/static/${snapshotPath}`;
        const link = document.createElement('a');
        link.href = url;
        link.download = snapshotPath.split('/').pop() || 'service_discipline_violation.jpg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    async function deleteServiceDisciplineViolation(violationId) {
        if (!confirm('Delete this service discipline violation?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/delete_table_service_violation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ violation_id: violationId })
            });
            
            const result = await response.json();
            if (result.success) {
                loadServiceDisciplineAlerts();
            } else {
                alert('Error deleting violation: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting service discipline violation:', error);
            alert('Error deleting violation. Please try again.');
        }
    }
    
    async function clearAllServiceDisciplineData() {
        if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL service discipline data!\n\nThis action cannot be undone. Are you sure?')) {
            return;
        }
        
        if (!confirm('Are you absolutely sure? This will permanently delete all service discipline violations and orders.')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_all_table_service_violations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`‚úÖ Successfully deleted ${result.deleted_count} service discipline records`);
                loadServiceDisciplineAlerts();
            } else {
                alert('Error clearing data: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing service discipline data:', error);
            alert('Error clearing data. Please try again.');
        }
    }
    
    // Alias for backward compatibility
    function loadServiceDisciplineViolations() {
        loadServiceDisciplineAlerts();
    }
    
    // ==================== Service Discipline ROI Configuration ====================
    
    let sdmRoiState = {
        currentChannel: null,
        currentTableId: null,
        points: [],
        canvas: null,
        ctx: null,
        imageLoaded: false,
        isDragging: false,
        dragPointIndex: -1,
        hoverPointIndex: -1
    };
    
    async function openServiceDisciplineRoiModal() {
        const modal = document.getElementById('serviceDisciplineRoiModal');
        if (!modal) return;
        
        // Populate channel selector
        const channelSelect = document.getElementById('sdmRoiChannelSelect');
        if (channelSelect) {
            channelSelect.innerHTML = '<option value="">Loading channels...</option>';
            
            try {
                // Get all active channels
                const response = await fetch('/api/get_active_channels');
                const result = await response.json();
                
                channelSelect.innerHTML = '<option value="">Select Channel...</option>';
                
                if (result.success && result.active_channels) {
                    // Filter channels that have ServiceDisciplineMonitor
                    const sdmChannels = result.active_channels.filter(ch => 
                        ch.modules && ch.modules.includes('ServiceDisciplineMonitor')
                    );
                    
                    if (sdmChannels.length > 0) {
                        sdmChannels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.channel_id;
                            option.textContent = `${channel.channel_id}${channel.name ? ` - ${channel.name}` : ''}`;
                            channelSelect.appendChild(option);
                        });
                    } else {
                        // If no active channels, try to get from all channels
                        const allChannelsResponse = await fetch('/api/get_channels/ServiceDisciplineMonitor');
                        const allChannels = await allChannelsResponse.json();
                        
                        if (Array.isArray(allChannels)) {
                            allChannels.forEach(channel => {
                                const option = document.createElement('option');
                                option.value = channel.id || channel.channel_id;
                                option.textContent = channel.name || channel.id || channel.channel_id;
                                channelSelect.appendChild(option);
                            });
                        }
                    }
                } else {
                    // Fallback: try to get from all channels
                    const allChannelsResponse = await fetch('/api/get_channels/ServiceDisciplineMonitor');
                    const allChannels = await allChannelsResponse.json();
                    
                    if (Array.isArray(allChannels)) {
                        allChannels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id || channel.channel_id;
                            option.textContent = channel.name || channel.id || channel.channel_id;
                            channelSelect.appendChild(option);
                        });
                    }
                }
                
                if (channelSelect.options.length === 1) {
                    channelSelect.innerHTML = '<option value="">No channels available</option>';
                }
            } catch (error) {
                console.error('Error loading channels:', error);
                channelSelect.innerHTML = '<option value="">Error loading channels</option>';
            }
        }
        
        modal.style.display = 'block';
    }
    
    function closeServiceDisciplineRoiModal() {
        const modal = document.getElementById('serviceDisciplineRoiModal');
        if (modal) {
            modal.style.display = 'none';
            sdmRoiState.currentChannel = null;
            sdmRoiState.currentTableId = null;
            sdmRoiState.points = [];
            sdmRoiState.imageLoaded = false;
        }
    }
    
    function loadServiceDisciplineRoiChannel() {
        const channelSelect = document.getElementById('sdmRoiChannelSelect');
        const channelId = channelSelect.value;
        
        if (!channelId) {
            sdmRoiState.currentChannel = null;
            return;
        }
        
        sdmRoiState.currentChannel = channelId;
        
        // Load video feed
        const image = document.getElementById('sdmRoiImage');
        const canvas = document.getElementById('sdmRoiCanvas');
        
        if (image && canvas) {
            sdmRoiState.canvas = canvas;
            sdmRoiState.ctx = canvas.getContext('2d');
            
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.style.width = image.offsetWidth + 'px';
                canvas.style.height = image.offsetHeight + 'px';
                sdmRoiState.imageLoaded = true;
                drawTableRoi();
                setupTableRoiInteraction();
            };
            
            image.src = `/video_feed/ServiceDisciplineMonitor/${channelId}?t=${Date.now()}`;
        }
    }
    
    function loadTableRoi() {
        const tableIdInput = document.getElementById('sdmRoiTableId');
        const tableId = tableIdInput.value.trim();
        const channelId = sdmRoiState.currentChannel;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        if (!tableId) {
            alert('Please enter a table ID');
            return;
        }
        
        sdmRoiState.currentTableId = tableId;
        
        // Fetch existing table ROIs
        fetch(`/api/get_service_discipline_table_rois?channel_id=${channelId}`)
            .then(response => response.json())
            .then(data => {
                if (data.success && data.table_rois && data.table_rois[tableId]) {
                    const roiInfo = data.table_rois[tableId];
                    sdmRoiState.points = roiInfo.polygon || [];
                    updateTableRoiInfo();
                    if (sdmRoiState.imageLoaded) {
                        drawTableRoi();
                    }
                } else {
                    sdmRoiState.points = [];
                    updateTableRoiInfo();
                    if (sdmRoiState.imageLoaded) {
                        drawTableRoi();
                    }
                }
            })
            .catch(error => {
                console.error('Error loading table ROI:', error);
                sdmRoiState.points = [];
                updateTableRoiInfo();
            });
    }
    
    function createNewTableRoi() {
        const tableIdInput = document.getElementById('sdmRoiTableId');
        const tableId = tableIdInput.value.trim();
        const channelId = sdmRoiState.currentChannel;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        if (!tableId) {
            alert('Please enter a table ID');
            return;
        }
        
        sdmRoiState.currentTableId = tableId;
        sdmRoiState.points = [];
        updateTableRoiInfo();
        if (sdmRoiState.imageLoaded) {
            drawTableRoi();
        }
    }
    
    function drawTableRoi() {
        if (!sdmRoiState.ctx || !sdmRoiState.imageLoaded) return;
        
        const ctx = sdmRoiState.ctx;
        const canvas = sdmRoiState.canvas;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (sdmRoiState.points.length > 0) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            
            ctx.beginPath();
            const firstPoint = sdmRoiState.points[0];
            ctx.moveTo(firstPoint.x * canvas.width, firstPoint.y * canvas.height);
            
            for (let i = 1; i < sdmRoiState.points.length; i++) {
                const point = sdmRoiState.points[i];
                ctx.lineTo(point.x * canvas.width, point.y * canvas.height);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw points
            sdmRoiState.points.forEach((point, index) => {
                const x = point.x * canvas.width;
                const y = point.y * canvas.height;
                
                ctx.fillStyle = index === sdmRoiState.hoverPointIndex ? '#ff0000' : '#00ffff';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
    }
    
    function setupTableRoiInteraction() {
        const canvas = sdmRoiState.canvas;
        if (!canvas) return;
        
        canvas.onclick = function(e) {
            if (!sdmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            sdmRoiState.points.push({x, y});
            drawTableRoi();
            updateTableRoiInfo();
        };
        
        canvas.onmousemove = function(e) {
            if (!sdmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            if (sdmRoiState.isDragging && sdmRoiState.dragPointIndex >= 0) {
                sdmRoiState.points[sdmRoiState.dragPointIndex] = {x, y};
                drawTableRoi();
                updateTableRoiInfo();
            } else {
                // Check if hovering over a point
                let found = false;
                sdmRoiState.points.forEach((point, index) => {
                    const px = point.x * canvas.width;
                    const py = point.y * canvas.height;
                    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
                    const my = (e.clientY - rect.top) * (canvas.height / rect.height);
                    
                    if (Math.hypot(mx - px, my - py) < 10) {
                        sdmRoiState.hoverPointIndex = index;
                        found = true;
                        canvas.style.cursor = 'move';
                    }
                });
                
                if (!found) {
                    sdmRoiState.hoverPointIndex = -1;
                    canvas.style.cursor = 'crosshair';
                } else {
                    drawTableRoi();
                }
            }
        };
        
        canvas.onmousedown = function(e) {
            if (!sdmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            // Check if clicking on a point
            sdmRoiState.points.forEach((point, index) => {
                const px = point.x * canvas.width;
                const py = point.y * canvas.height;
                const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
                const my = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                if (Math.hypot(mx - px, my - py) < 10) {
                    sdmRoiState.isDragging = true;
                    sdmRoiState.dragPointIndex = index;
                }
            });
        };
        
        canvas.onmouseup = function() {
            sdmRoiState.isDragging = false;
            sdmRoiState.dragPointIndex = -1;
        };
        
        canvas.ondblclick = function(e) {
            if (!sdmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = (e.clientY - rect.top) / rect.height;
            
            // Find and remove the closest point
            let minDist = Infinity;
            let removeIndex = -1;
            
            sdmRoiState.points.forEach((point, index) => {
                const px = point.x * canvas.width;
                const py = point.y * canvas.height;
                const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
                const my = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                const dist = Math.hypot(mx - px, my - py);
                if (dist < minDist && dist < 10) {
                    minDist = dist;
                    removeIndex = index;
                }
            });
            
            if (removeIndex >= 0) {
                sdmRoiState.points.splice(removeIndex, 1);
                drawTableRoi();
                updateTableRoiInfo();
            }
        };
    }
    
    function updateTableRoiInfo() {
        const infoDiv = document.getElementById('sdmRoiInfo');
        if (!infoDiv) return;
        
        const channelId = sdmRoiState.currentChannel || 'None';
        const tableId = sdmRoiState.currentTableId || 'None';
        const pointCount = sdmRoiState.points.length;
        
        infoDiv.innerHTML = `
            <strong>Table Status:</strong>
            <div style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                Channel: ${channelId}<br>
                Table ID: ${tableId}<br>
                Points: ${pointCount} ${pointCount >= 3 ? '‚úì' : '(need at least 3)'}
            </div>
        `;
    }
    
    function clearCurrentTableRoi() {
        sdmRoiState.points = [];
        if (sdmRoiState.imageLoaded) {
            drawTableRoi();
        }
        updateTableRoiInfo();
    }
    
    async function deleteCurrentTableRoi() {
        if (!sdmRoiState.currentChannel || !sdmRoiState.currentTableId) {
            alert('No table selected');
            return;
        }
        
        if (!confirm(`Delete ROI for table ${sdmRoiState.currentTableId}?`)) {
            return;
        }
        
        sdmRoiState.points = [];
        if (sdmRoiState.imageLoaded) {
            drawTableRoi();
        }
        updateTableRoiInfo();
    }
    
    async function saveServiceDisciplineTableRoi() {
        if (!sdmRoiState.currentChannel || !sdmRoiState.currentTableId) {
            alert('Please select a channel and enter a table ID');
            return;
        }
        
        if (sdmRoiState.points.length < 3) {
            alert('At least 3 points are required to form a polygon');
            return;
        }
        
        try {
            const response = await fetch('/api/set_service_discipline_table_roi', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: sdmRoiState.currentChannel,
                    table_id: sdmRoiState.currentTableId,
                    roi_points: sdmRoiState.points
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Table ROI saved successfully for ${sdmRoiState.currentTableId}!`);
                const image = document.getElementById('sdmRoiImage');
                if (image) {
                    image.src = `/video_feed/ServiceDisciplineMonitor/${sdmRoiState.currentChannel}?t=${Date.now()}`;
                }
            } else {
                alert(`Error saving table ROI: ${result.error}`);
            }
        } catch (error) {
            console.error('Error saving table ROI:', error);
            alert('Failed to save table ROI configuration');
        }
    }
    
    // ==================== Material Theft Monitor ROI Configuration ====================
    
    let mtmRoiState = {
        currentChannel: null,
        points: [],
        canvas: null,
        ctx: null,
        imageLoaded: false,
        isDragging: false,
        dragPointIndex: -1,
        hoverPointIndex: -1
    };
    
    let crowdRoiState = {
        currentChannel: null,
        points: [],
        canvas: null,
        ctx: null,
        imageLoaded: false,
        isDragging: false,
        dragPointIndex: -1,
        hoverPointIndex: -1
    };
    
    async function openMaterialTheftRoiModal() {
        const modal = document.getElementById('materialTheftRoiModal');
        if (!modal) return;
        
        // Populate channel selector
        const channelSelect = document.getElementById('mtmRoiChannelSelect');
        if (channelSelect) {
            channelSelect.innerHTML = '<option value="">Loading channels...</option>';
            
            try {
                // Get all active channels
                const response = await fetch('/api/get_active_channels');
                const result = await response.json();
                
                channelSelect.innerHTML = '<option value="">Select Channel...</option>';
                
                if (result.success && result.active_channels) {
                    // Filter channels that have MaterialTheftMonitor
                    const mtmChannels = result.active_channels.filter(ch => 
                        ch.modules && ch.modules.includes('MaterialTheftMonitor')
                    );
                    
                    if (mtmChannels.length > 0) {
                        mtmChannels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.channel_id;
                            option.textContent = `${channel.channel_id}${channel.name ? ` - ${channel.name}` : ''}`;
                            channelSelect.appendChild(option);
                        });
                    } else {
                        // If no active channels, try to get from all channels
                        const allChannelsResponse = await fetch('/api/get_channels/MaterialTheftMonitor');
                        const allChannels = await allChannelsResponse.json();
                        
                        if (Array.isArray(allChannels)) {
                            allChannels.forEach(channel => {
                                const option = document.createElement('option');
                                option.value = channel.id || channel.channel_id;
                                option.textContent = channel.name || channel.id || channel.channel_id;
                                channelSelect.appendChild(option);
                            });
                        }
                    }
                } else {
                    // Fallback: try to get from all channels
                    const allChannelsResponse = await fetch('/api/get_channels/MaterialTheftMonitor');
                    const allChannels = await allChannelsResponse.json();
                    
                    if (Array.isArray(allChannels)) {
                        allChannels.forEach(channel => {
                            const option = document.createElement('option');
                            option.value = channel.id || channel.channel_id;
                            option.textContent = channel.name || channel.id || channel.channel_id;
                            channelSelect.appendChild(option);
                        });
                    }
                }
                
                if (channelSelect.options.length === 1) {
                    channelSelect.innerHTML = '<option value="">No channels available</option>';
                }
            } catch (error) {
                console.error('Error loading channels:', error);
                channelSelect.innerHTML = '<option value="">Error loading channels</option>';
            }
        }
        
        modal.style.display = 'block';
    }
    
    function closeMaterialTheftRoiModal() {
        const modal = document.getElementById('materialTheftRoiModal');
        if (modal) {
            modal.style.display = 'none';
            mtmRoiState.currentChannel = null;
            mtmRoiState.points = [];
            mtmRoiState.imageLoaded = false;
        }
    }
    
    function loadMaterialTheftRoiChannel() {
        const channelSelect = document.getElementById('mtmRoiChannelSelect');
        const channelId = channelSelect.value;
        
        if (!channelId) {
            mtmRoiState.currentChannel = null;
            return;
        }
        
        mtmRoiState.currentChannel = channelId;
        
        // Load video feed
        const image = document.getElementById('mtmRoiImage');
        const canvas = document.getElementById('mtmRoiCanvas');
        
        if (image && canvas) {
            mtmRoiState.canvas = canvas;
            mtmRoiState.ctx = canvas.getContext('2d');
            
            image.onload = function() {
                canvas.width = image.width;
                canvas.height = image.height;
                canvas.style.width = image.offsetWidth + 'px';
                canvas.style.height = image.offsetHeight + 'px';
                mtmRoiState.imageLoaded = true;
                drawMaterialTheftRoi();
                setupMaterialTheftRoiInteraction();
            };
            
            image.src = `/video_feed/MaterialTheftMonitor/${channelId}?t=${Date.now()}`;
        }
        
        // Load existing ROI
        loadMaterialTheftRoi();
    }
    
    async function loadMaterialTheftRoi() {
        const channelId = mtmRoiState.currentChannel;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        try {
            // Try to get ROI from the module
            const response = await fetch(`/api/get_material_theft_roi/${channelId}`);
            const result = await response.json();
            
            if (result.success && result.roi_points && result.roi_points.length > 0) {
                mtmRoiState.points = result.roi_points;
                updateMaterialTheftRoiInfo();
                if (mtmRoiState.imageLoaded) {
                    drawMaterialTheftRoi();
                }
            } else {
                mtmRoiState.points = [];
                updateMaterialTheftRoiInfo();
                if (mtmRoiState.imageLoaded) {
                    drawMaterialTheftRoi();
                }
            }
        } catch (error) {
            console.error('Error loading ROI:', error);
            mtmRoiState.points = [];
            updateMaterialTheftRoiInfo();
        }
    }
    
    function drawMaterialTheftRoi() {
        if (!mtmRoiState.ctx || !mtmRoiState.imageLoaded) return;
        
        const ctx = mtmRoiState.ctx;
        const canvas = mtmRoiState.canvas;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (mtmRoiState.points.length > 0) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
            
            ctx.beginPath();
            ctx.moveTo(mtmRoiState.points[0][0], mtmRoiState.points[0][1]);
            for (let i = 1; i < mtmRoiState.points.length; i++) {
                ctx.lineTo(mtmRoiState.points[i][0], mtmRoiState.points[i][1]);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw points
            mtmRoiState.points.forEach((point, index) => {
                ctx.fillStyle = index === mtmRoiState.hoverPointIndex ? '#ffff00' : '#00ff00';
                ctx.beginPath();
                ctx.arc(point[0], point[1], 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
    }
    
    function setupMaterialTheftRoiInteraction() {
        const canvas = mtmRoiState.canvas;
        if (!canvas) return;
        
        canvas.onmousedown = function(e) {
            if (!mtmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Check if clicking on existing point
            let clickedPointIndex = -1;
            mtmRoiState.points.forEach((point, index) => {
                const dist = Math.hypot(mx - point[0], my - point[1]);
                if (dist < 10) {
                    clickedPointIndex = index;
                }
            });
            
            if (clickedPointIndex >= 0) {
                mtmRoiState.isDragging = true;
                mtmRoiState.dragPointIndex = clickedPointIndex;
            } else {
                // Add new point
                mtmRoiState.points.push([mx, my]);
                drawMaterialTheftRoi();
                updateMaterialTheftRoiInfo();
            }
        };
        
        canvas.onmousemove = function(e) {
            if (!mtmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            if (mtmRoiState.isDragging && mtmRoiState.dragPointIndex >= 0) {
                mtmRoiState.points[mtmRoiState.dragPointIndex] = [mx, my];
                drawMaterialTheftRoi();
                updateMaterialTheftRoiInfo();
            } else {
                // Check hover
                let hoverIndex = -1;
                mtmRoiState.points.forEach((point, index) => {
                    const dist = Math.hypot(mx - point[0], my - point[1]);
                    if (dist < 10) {
                        hoverIndex = index;
                    }
                });
                
                if (hoverIndex !== mtmRoiState.hoverPointIndex) {
                    mtmRoiState.hoverPointIndex = hoverIndex;
                    drawMaterialTheftRoi();
                }
                
                canvas.style.cursor = hoverIndex >= 0 ? 'move' : 'crosshair';
            }
        };
        
        canvas.onmouseup = function() {
            mtmRoiState.isDragging = false;
            mtmRoiState.dragPointIndex = -1;
        };
        
        canvas.onmouseleave = function() {
            mtmRoiState.isDragging = false;
            mtmRoiState.dragPointIndex = -1;
            mtmRoiState.hoverPointIndex = -1;
            drawMaterialTheftRoi();
        };
        
        canvas.ondblclick = function(e) {
            if (!mtmRoiState.imageLoaded) return;
            
            const rect = canvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
            const my = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Find and remove closest point
            let removeIndex = -1;
            let minDist = Infinity;
            mtmRoiState.points.forEach((point, index) => {
                const px = point[0];
                const py = point[1];
                const dist = Math.hypot(mx - px, my - py);
                if (dist < minDist && dist < 10) {
                    minDist = dist;
                    removeIndex = index;
                }
            });
            
            if (removeIndex >= 0) {
                mtmRoiState.points.splice(removeIndex, 1);
                drawMaterialTheftRoi();
                updateMaterialTheftRoiInfo();
            }
        };
    }
    
    function updateMaterialTheftRoiInfo() {
        const infoDiv = document.getElementById('mtmRoiInfo');
        const coordsDiv = document.getElementById('mtmRoiCoordinates');
        if (!infoDiv) return;
        
        const channelId = mtmRoiState.currentChannel || 'None';
        const pointCount = mtmRoiState.points.length;
        
        infoDiv.innerHTML = `
            <strong>ROI Status:</strong>
            <div style="font-family: monospace; font-size: 0.9em; margin-top: 5px;">
                Channel: ${channelId}<br>
                Points: ${pointCount} ${pointCount >= 3 ? '‚úì' : '(need at least 3)'}
            </div>
        `;
        
        if (coordsDiv && mtmRoiState.points.length > 0) {
            const coords = JSON.stringify(mtmRoiState.points, null, 2);
            coordsDiv.innerHTML = `<strong>Coordinates:</strong><br><pre style="margin: 5px 0; font-size: 0.8em; max-height: 150px; overflow: auto;">${coords}</pre>`;
        } else if (coordsDiv) {
            coordsDiv.innerHTML = 'Coordinates will appear here as you draw...';
        }
    }
    
    function clearMaterialTheftRoi() {
        mtmRoiState.points = [];
        if (mtmRoiState.imageLoaded) {
            drawMaterialTheftRoi();
        }
        updateMaterialTheftRoiInfo();
    }
    
    async function reloadMaterialTheftRoiFromConfig() {
        const channelId = mtmRoiState.currentChannel;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        try {
            const response = await fetch(`/api/reload_material_theft_roi/${channelId}`, {
                method: 'POST'
            });
            
            const result = await response.json();
            if (result.success) {
                // Update the ROI state with the reloaded points
                if (result.roi_points && result.roi_points.length > 0) {
                    mtmRoiState.points = result.roi_points;
                    updateMaterialTheftRoiInfo();
                    if (mtmRoiState.imageLoaded) {
                        drawMaterialTheftRoi();
                    }
                }
                alert(`ROI reloaded from config file for ${channelId}!`);
                // Refresh the image to show updated ROI
                const image = document.getElementById('mtmRoiImage');
                if (image) {
                    image.src = `/video_feed/MaterialTheftMonitor/${channelId}?t=${Date.now()}`;
                }
            } else {
                alert(`Error reloading ROI: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error reloading ROI from config:', error);
            alert('Failed to reload ROI from config file');
        }
    }
    
    async function resetMaterialTheftBackground() {
        const channelId = mtmRoiState.currentChannel;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }
        
        if (!confirm('Reset the background model? This will make the system relearn what the background looks like. Objects should be removed from the weighing machine before resetting.')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/reset_material_theft_background/${channelId}`, {
                method: 'POST'
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Background model reset for ${channelId}! The system will now relearn the background. Wait ~30 seconds for it to learn, then place objects on the weighing machine.`);
            } else {
                alert(`Error resetting background: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error resetting background:', error);
            alert('Failed to reset background model');
        }
    }
    
    async function saveMaterialTheftRoi() {
        if (!mtmRoiState.currentChannel) {
            alert('Please select a channel first');
            return;
        }
        
        if (mtmRoiState.points.length < 3) {
            alert('At least 3 points are required to form a polygon');
            return;
        }
        
        try {
            const response = await fetch('/api/set_roi', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    app_name: 'MaterialTheftMonitor',
                    channel_id: mtmRoiState.currentChannel,
                    roi_points: mtmRoiState.points
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`ROI saved successfully for ${mtmRoiState.currentChannel}!`);
                // Refresh the image to show updated ROI
                const image = document.getElementById('mtmRoiImage');
                if (image) {
                    image.src = `/video_feed/MaterialTheftMonitor/${mtmRoiState.currentChannel}?t=${Date.now()}`;
                }
            } else {
                alert(`Error saving ROI: ${result.error || 'Unknown error'}`);
            }
        } catch (error) {
            console.error('Error saving ROI:', error);
            alert('Failed to save ROI configuration');
        }
    }
    
    // ==================== Phone Usage Detection Functions ====================
    
    function loadPhoneSnapshots() {
        fetch('/api/get_phone_snapshots?limit=50')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayPhoneSnapshots(data.snapshots);
                }
            })
            .catch(error => console.error('Error loading phone snapshots:', error));
    }
    
    function displayPhoneSnapshots(snapshots) {
        const grid = document.getElementById('phone-snapshots-grid');
        if (!grid) return;
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No phone usage snapshots available</p>';
            return;
        }
        
        grid.innerHTML = snapshots.map(snapshot => `
            <div class="alert-gif-item">
                <img src="/static/phone_snapshots/${snapshot.snapshot_filename}" alt="Phone Detection" style="cursor: pointer;" onclick="openLightboxFromImage(this)">
                <div class="alert-gif-info">
                    <strong>üì± ${snapshot.alert_message}</strong>
                    <p>Channel: ${snapshot.channel_id}</p>
                    <p>Time: ${new Date(snapshot.created_at).toLocaleString()}</p>
                    <p>Detections: ${snapshot.detection_count}</p>
                    <button class="btn btn-danger btn-sm" onclick="deletePhoneSnapshot(${snapshot.id})">Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    function deletePhoneSnapshot(snapshotId) {
        if (!confirm('Are you sure you want to delete this phone detection snapshot?')) {
            return;
        }
        
        fetch(`/api/delete_phone_snapshot/${snapshotId}`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                loadPhoneSnapshots();
            } else {
                alert('Error deleting snapshot: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error deleting snapshot');
        });
    }
    
    function clearOldPhoneSnapshots() {
        if (!confirm('Clear snapshots older than 7 days?')) {
            return;
        }
        
        fetch('/api/clear_old_phone_snapshots', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ days: 7 })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert(data.message);
                loadPhoneSnapshots();
            } else {
                alert('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error clearing snapshots');
        });
    }

    // Grooming Detection Functions
    async function loadGroomingSnapshots() {
        try {
            // Load all grooming violation snapshots from all channels
            const url = '/api/get_grooming_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayGroomingSnapshots(result.snapshots);
            } else {
                console.error('Failed to load grooming snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading grooming snapshots:', error);
        }
    }
    
    // Display grooming violation snapshots in grid
    function displayGroomingSnapshots(snapshots) {
        const grid = document.getElementById('grooming-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üëî No Violations Detected</h3>
                    <p>No grooming standard violations detected yet.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Grooming Detection to monitor employee compliance.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snapshot => {
            const violationColor = snapshot.violation_type === 'prohibited_item' ? '#ef4444' : '#f59e0b';
            const violationIcon = snapshot.violation_type === 'prohibited_item' ? '‚õî' : '‚ö†Ô∏è';
            
            return `
                <div class="alert-gif-card">
                    <div class="gif-preview">
                        <img src="/static/grooming_snapshots/${snapshot.snapshot_filename}" alt="Grooming Violation" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">
                    </div>
                    <div class="gif-info">
                        <div class="gif-channel">
                            <strong>üìπ Channel:</strong> ${snapshot.channel_id}
                        </div>
                        <div class="gif-time">
                            <strong>üïê Time:</strong> ${new Date(snapshot.created_at).toLocaleString()}
                        </div>
                        <div class="gif-message" style="color: ${violationColor};">
                            <strong>${violationIcon} Violation:</strong> ${snapshot.alert_message}
                        </div>
                        <div class="gif-stats">
                            <span>üè∑Ô∏è Type: ${snapshot.violation_type.replace('_', ' ')}</span>
                            <span>üíæ ${(snapshot.file_size / 1024).toFixed(2)} KB</span>
                        </div>
                    </div>
                    <div class="gif-actions">
                        <button class="btn btn-sm" onclick="downloadGroomingSnapshot('${snapshot.snapshot_filename}')">üì• Download</button>
                        <button class="btn btn-sm btn-danger" onclick="deleteGroomingSnapshot(${snapshot.id})">üóëÔ∏è Delete</button>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    // Download grooming violation snapshot
    function downloadGroomingSnapshot(filename) {
        const link = document.createElement('a');
        link.href = `/static/grooming_snapshots/${filename}`;
        link.download = filename;
        link.click();
    }
    
    // Delete grooming violation snapshot
    async function deleteGroomingSnapshot(snapshotId) {
        if (!confirm('Are you sure you want to delete this violation snapshot?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_grooming_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadGroomingSnapshots();
            } else {
                alert('Error deleting snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting grooming snapshot:', error);
        }
    }
    
    // Clear old grooming violation snapshots
    async function clearOldGroomingSnapshots() {
        if (!confirm('Delete all grooming violation snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_grooming_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count} old violation snapshots`);
                loadGroomingSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old grooming snapshots:', error);
        }
    }
    
    // Save grooming detection settings
    async function saveGroomingSettings() {
        const requiredClasses = document.getElementById('gd-required-classes').value
            .split(',').map(s => s.trim()).filter(s => s);
        const prohibitedClasses = document.getElementById('gd-prohibited-classes').value
            .split(',').map(s => s.trim()).filter(s => s);
        
        const settings = {
            confidence_threshold: parseFloat(document.getElementById('gd-confidence').value),
            alert_cooldown: parseInt(document.getElementById('gd-alert-cooldown').value),
            required_classes: requiredClasses,
            prohibited_classes: prohibitedClasses,
            require_beard_net: document.getElementById('gd-require-beard-net').checked
        };
        
        const selector = document.getElementById('gd-channel-selector');
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please start grooming detection on a channel first');
            return;
        }
        
        try {
            const response = await fetch('/api/update_grooming_detection_config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId,
                    config: settings
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Settings saved successfully!');
            } else {
                alert('Error saving settings: ' + result.error);
            }
        } catch (error) {
            console.error('Error saving settings:', error);
            alert('Failed to save settings');
        }
    }

    // Listen for real-time cash detection alerts
    socket.on('cash_detected', (data) => {
        console.log('Cash detected:', data);
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification('üíµ Cash Detected!', {
                body: `${data.alert_message} on channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Refresh snapshots if on the cash detection tab
        const snapshotsTab = document.getElementById('CashDetectionSnapshots');
        if (snapshotsTab && snapshotsTab.classList.contains('active')) {
            loadCashSnapshots();
        }
    });

    // Listen for cash detection stats updates
    socket.on('cash_detection_update', (data) => {
        updateCashDetectionDisplay(data);
    });

    // Listen for table service status updates
    socket.on('table_service_update', (data) => {
        updateTableServiceDisplay(data);
    });

    // Listen for table service alerts
    socket.on('table_service_alert', (data) => {
        console.log('üçΩÔ∏è Table service violation detected:', data);
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification('üçΩÔ∏è Table Service Violation!', {
                body: `Table ${data.table_id}: Customer waiting ${data.waiting_time}s on channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Refresh violations if on the table service reports tab
        const reportsTab = document.getElementById('TableServiceMonitor-reports');
        if (reportsTab && reportsTab.classList.contains('active')) {
            loadTableServiceViolations();
        }
    });

    // Listen for table unclean alerts
    socket.on('material_theft_alert', (data) => {
        console.log('Material theft alert received:', data);
        const channelId = data.channel_id;
        const alertCountEl = document.getElementById(`mtm-alerts-${channelId}`);
        if (alertCountEl) {
            const current = parseInt(alertCountEl.textContent) || 0;
            alertCountEl.textContent = current + 1;
        }
        // Update total alerts
        updateMaterialTheftStats();
        // Reload alerts
        loadMaterialTheftAlerts();
    });
    
    socket.on('table_unclean_alert', (data) => {
        console.log('üßπ Unclean table detected:', data);
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification('üßπ Unclean Table Alert!', {
                body: `Table ${data.table_id} is unclean for ${data.unclean_duration}s on channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Refresh violations if on the table service reports tab
        const reportsTab = document.getElementById('TableServiceMonitor-reports');
        if (reportsTab && reportsTab.classList.contains('active')) {
            loadTableServiceViolations();
        }
    });

    // Listen for service discipline status updates
    socket.on('service_discipline_update', (data) => {
        updateServiceDisciplineDisplay(data);
    });

    // Listen for service discipline alerts
    socket.on('service_discipline_alert', (data) => {
        console.log('‚è±Ô∏è Service discipline violation detected:', data);
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification('‚è±Ô∏è Service Discipline Violation!', {
                body: `Table ${data.table_id}: Customer waiting ${data.wait_time}s on channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Refresh violations if on the service discipline reports tab
        const reportsTab = document.getElementById('ServiceDisciplineMonitor-reports');
        if (reportsTab && reportsTab.classList.contains('active')) {
            loadServiceDisciplineViolations();
        }
    });

    // Listen for dress code violation alerts
    socket.on('dresscode_violation', (data) => {
        console.log('üëî Dress code violation detected:', data);
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification('üëî Dress Code Violation!', {
                body: `${data.violations_text} on channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Always refresh alerts when violation is detected
        loadDressCodeAlerts();
    });

    // ============= Fall Detection Functions =============
    
    // Load fall detection snapshots
    async function loadFallSnapshots() {
        try {
            // Load all fall detection snapshots from all channels
            const url = '/api/get_fall_snapshots?limit=50';
            
            const response = await fetch(url);
            const result = await response.json();
            
            if (result.success) {
                displayFallSnapshots(result.snapshots);
            } else {
                console.error('Failed to load fall snapshots:', result.error);
            }
        } catch (error) {
            console.error('Error loading fall snapshots:', error);
        }
    }
    
    // Display fall snapshots in grid
    function displayFallSnapshots(snapshots) {
        const grid = document.getElementById('fall-snapshots-grid');
        
        if (!snapshots || snapshots.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>üö® No Falls Detected</h3>
                    <p>No person falls detected yet.</p>
                    <p style="margin-top: 20px; font-size: 14px;">Start Fall Detection to monitor for emergency situations.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = snapshots.map(snapshot => `
            <div class="alert-gif-card" style="border-left: 4px solid #ef4444;">
                <div class="gif-preview">
                    <img src="${snapshot.snapshot_url || `/static/fall_snapshots/${snapshot.snapshot_filename}`}" alt="Fall Detection" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onerror="this.src='/static/images/placeholder.png'; this.onerror=null;" onclick="openLightboxFromImage(this)">
                </div>
                <div class="gif-info">
                    <div class="gif-channel">
                        <strong>üìπ Channel:</strong> ${snapshot.channel_id}
                    </div>
                    <div class="gif-time">
                        <strong>üïê Time:</strong> ${new Date(snapshot.created_at).toLocaleString()}
                    </div>
                    <div class="gif-message" style="color: #ef4444;">
                        <strong>üö® Emergency:</strong> ${snapshot.alert_message}
                    </div>
                    <div class="gif-stats">
                        <span>‚è±Ô∏è Duration: ${snapshot.fall_duration?.toFixed(1)}s</span>
                        <span>üíæ ${(snapshot.file_size / 1024).toFixed(2)} KB</span>
                    </div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm" onclick="downloadFallSnapshot('${snapshot.snapshot_url || `/static/fall_snapshots/${snapshot.snapshot_filename}`}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteFallSnapshot(${snapshot.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Download fall snapshot
    function downloadFallSnapshot(urlOrFilename) {
        const link = document.createElement('a');
        // If it's already a full URL, use it; otherwise construct the path
        if (urlOrFilename.startsWith('/static/')) {
            link.href = urlOrFilename;
            // Extract filename from path for download attribute
            const pathParts = urlOrFilename.split('/');
            link.download = pathParts[pathParts.length - 1];
        } else {
            link.href = `/static/fall_snapshots/${urlOrFilename}`;
            link.download = urlOrFilename;
        }
        link.click();
    }
    
    // Delete fall snapshot
    async function deleteFallSnapshot(snapshotId) {
        if (!confirm('Are you sure you want to delete this fall detection snapshot?')) {
            return;
        }
        
        try {
            const response = await fetch(`/api/delete_fall_snapshot/${snapshotId}`, {
                method: 'DELETE'
            });
            
            const result = await response.json();
            if (result.success) {
                loadFallSnapshots();  // Reload the list
            } else {
                alert('Error deleting snapshot: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting snapshot:', error);
            alert('Failed to delete snapshot');
        }
    }
    
    // Clear old fall snapshots (7+ days)
    async function clearOldFallSnapshots() {
        if (!confirm('Delete all fall detection snapshots older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_fall_snapshots', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Deleted ${result.deleted_count} old snapshots`);
                loadFallSnapshots();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old fall snapshots:', error);
        }
    }
    
    // Save fall detection settings
    async function saveFallDetectionSettings() {
        const settings = {
            confidence_threshold: parseFloat(document.getElementById('fd-confidence').value),
            fall_duration_threshold: parseFloat(document.getElementById('fd-fall-duration').value),
            alert_cooldown: parseInt(document.getElementById('fd-alert-cooldown').value)
        };
        
        const selector = document.getElementById('fd-channel-selector');
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please start fall detection on a channel first');
            return;
        }
        
        try {
            const response = await fetch('/api/update_fall_detection_config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId,
                    config: settings
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Settings saved successfully!');
            } else {
                alert('Error saving settings: ' + result.error);
            }
        } catch (error) {
            console.error('Error saving settings:', error);
            alert('Failed to save settings');
        }
    }
    
    // Update fall detection display
    function updateFallDetectionDisplay(data) {
        const fallCountEl = document.getElementById(`fall-count-${data.channel_id}`);
        const fallAlertsEl = document.getElementById(`fall-alerts-${data.channel_id}`);
        
        if (fallCountEl) fallCountEl.textContent = data.current_falls || 0;
        if (fallAlertsEl) fallAlertsEl.textContent = data.total_alerts || 0;
    }
    
    function updateGroomingDetectionDisplay(data) {
        const violationsEl = document.getElementById(`grooming-violations-${data.channel_id}`);
        const checksEl = document.getElementById(`grooming-checks-${data.channel_id}`);
        
        if (violationsEl) violationsEl.textContent = data.violation_count || 0;
        if (checksEl) checksEl.textContent = data.total_checks || 0;
    }
    
    // Listen for fall detection alerts
    socket.on('fall_detected', (data) => {
        console.log('Fall detected:', data);
        
        // Show urgent notification
        if (Notification.permission === 'granted') {
            new Notification('üö® EMERGENCY: Person Fall Detected!', {
                body: `${data.alert_message} on channel ${data.channel_id}`,
                icon: '/static/icon.png',
                tag: 'fall-alert',
                requireInteraction: true  // Notification stays until dismissed
            });
        }
        
        // Show urgent visual alert on dashboard
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #dc2626;
            color: white;
            padding: 20px 25px;
            border-radius: 8px;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4);
            max-width: 350px;
            animation: shake 0.5s;
        `;
        alertDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <span style="font-size: 24px;">üö®</span>
                <strong style="font-size: 18px;">EMERGENCY: Person Fall!</strong>
            </div>
            Channel: ${data.channel_id}<br>
            Duration: ${data.fall_duration}s<br>
            Time: ${new Date(data.timestamp).toLocaleTimeString()}
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 20px; cursor: pointer; margin-top: -30px;">&times;</button>
        `;
        document.body.appendChild(alertDiv);
        
        // Auto-remove after 15 seconds
        setTimeout(() => alertDiv.remove(), 15000);
        
        // Refresh snapshots if on the fall detection tab
        const snapshotsTab = document.getElementById('FallDetectionSnapshots');
        if (snapshotsTab && snapshotsTab.classList.contains('active')) {
            loadFallSnapshots();
        }
    });
    
    // Listen for fall detection stats updates
    socket.on('fall_detection_update', (data) => {
        updateFallDetectionDisplay(data);
    });

    // Listen for grooming violation alerts
    socket.on('grooming_violation_detected', (data) => {
        console.log('Grooming violation detected:', data);
        
        // Determine alert style based on violation type
        const isProhibited = data.violation_type === 'prohibited_item';
        const bgColor = isProhibited ? '#dc2626' : '#ea580c';
        const icon = isProhibited ? '‚õî' : '‚ö†Ô∏è';
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification(`${icon} Grooming Standards Violation!`, {
                body: `${data.message} on channel ${data.channel_id}`,
                icon: '/static/icon.png',
                tag: 'grooming-violation'
            });
        }
        
        // Show visual alert on dashboard
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${bgColor};
            color: white;
            padding: 20px 25px;
            border-radius: 8px;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(220, 38, 38, 0.3);
            max-width: 350px;
            animation: slideIn 0.3s;
        `;
        alertDiv.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                <span style="font-size: 24px;">${icon}</span>
                <strong style="font-size: 16px;">Grooming Violation!</strong>
            </div>
            ${data.message}<br>
            Channel: ${data.channel_id}<br>
            Time: ${new Date(data.timestamp).toLocaleTimeString()}
            ${data.snapshot_filename ? `<br><img src="/static/grooming_snapshots/${data.snapshot_filename}" style="width: 100%; margin-top: 10px; border-radius: 4px;">` : ''}
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 20px; cursor: pointer; margin-top: -30px;">&times;</button>
        `;
        document.body.appendChild(alertDiv);
        
        // Auto-remove after 12 seconds
        setTimeout(() => alertDiv.remove(), 12000);
        
        // Refresh snapshots if on the grooming violation history tab
        const snapshotsTab = document.getElementById('GroomingViolationHistory');
        if (snapshotsTab && snapshotsTab.classList.contains('active')) {
            loadGroomingSnapshots();
        }
    });

    // Listen for bag detection alerts
    socket.on('bag_alert', (data) => {
        console.log('Bag alert received:', data);
        
        // Show browser notification
        if (Notification.permission === 'granted') {
            new Notification('üéí Unattended Bag Alert!', {
                body: `Bag detected unattended for ${data.duration}s on channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Show visual alert on dashboard
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 300px;
        `;
        alertDiv.innerHTML = `
            <strong>üéí Unattended Bag Alert!</strong><br>
            Channel: ${data.channel_id}<br>
            Duration: ${data.duration}s<br>
            Distance to nearest person: ${data.distance_to_person}px
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 18px; cursor: pointer; margin-top: -5px;">&times;</button>
        `;
        document.body.appendChild(alertDiv);
        
        // Auto-remove after 10 seconds
        setTimeout(() => alertDiv.remove(), 10000);
    });

    // Listen for fall detection alerts
    socket.on('fall_detected', (data) => {
        console.log('Fall detected:', data);
        
        // Show browser notification
        if (Notification.permission === 'granted') {
            new Notification('üö® FALL DETECTED - EMERGENCY!', {
                body: `Person fall detected on channel ${data.channel_id} - Duration: ${data.fall_duration}s`,
                icon: '/static/icon.png',
                requireInteraction: true  // Keep notification visible until user interacts
            });
        }
        
        // Show visual emergency alert on dashboard
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #dc2626;
            color: white;
            padding: 20px 25px;
            border-radius: 8px;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(220, 38, 38, 0.5);
            max-width: 350px;
            border: 3px solid #fca5a5;
            animation: pulse 2s infinite;
        `;
        alertDiv.innerHTML = `
            <strong style="font-size: 1.2em;">üö® EMERGENCY - FALL DETECTED!</strong><br><br>
            <strong>Channel:</strong> ${data.channel_id}<br>
            <strong>Duration:</strong> ${data.fall_duration}s<br>
            <strong>Time:</strong> ${new Date(data.timestamp).toLocaleTimeString()}<br>
            <img src="${data.snapshot_url}" style="width: 100%; margin-top: 10px; border-radius: 4px;" alt="Fall Detection">
            <button onclick="this.parentElement.remove()" style="float: right; background: white; color: #dc2626; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-top: 10px; font-weight: bold;">ACKNOWLEDGE</button>
        `;
        document.body.appendChild(alertDiv);
        
        // Refresh snapshots if on the fall detection tab
        const snapshotsTab = document.getElementById('FallDetectionSnapshots');
        if (snapshotsTab && snapshotsTab.classList.contains('active')) {
            loadFallSnapshots();
        }
        
        // Auto-remove after 30 seconds (longer for emergency)
        setTimeout(() => alertDiv.remove(), 30000);
    });

    // Listen for fall detection stats updates
    socket.on('fall_detection_update', (data) => {
        updateFallDetectionDisplay(data);
    });

    // Listen for real-time alert GIF creation
    socket.on('alert_gif_created', (data) => {
        console.log('New alert GIF created:', data);
        
        // Show notification
        if (Notification.permission === 'granted') {
            new Notification('Alert Recording Created', {
                body: `New alert GIF created for channel ${data.channel_id}`,
                icon: '/static/icon.png'
            });
        }
        
        // Refresh alert GIFs if on the alerts tab
        const alertsTab = document.getElementById('QueueMonitorReports');
        if (alertsTab && alertsTab.classList.contains('active')) {
            loadAlertGifs();
        }
    });

    // Unified function to start analysis modules
    async function startAnalysisModule(appName) {
        const selectorId = appName === 'PeopleCounter' ? 'pc-channel-selector' : 
                          appName === 'QueueMonitor' ? 'qm-channel-selector' :
                          appName === 'Heatmap' ? 'hm-channel-selector' :
                          appName === 'CashDetection' ? 'cd-channel-selector' :
                          appName === 'FallDetection' ? 'fd-channel-selector' :
                          appName === 'GroomingDetection' ? 'gd-channel-selector' :
                          'bd-channel-selector';
        const selector = document.getElementById(selectorId);
        const channelId = selector.value;
        
        if (!channelId) {
            alert('Please select a channel first');
            return;
        }

        // Get the selected option to determine source type and path
        const selectedOption = selector.options[selector.selectedIndex];
        const sourceType = selectedOption.dataset.type;
        const rtspUrl = selectedOption.dataset.rtspUrl;
        const videoPath = selectedOption.dataset.videoPath;

        try {
            const requestBody = {
                app_name: appName,
                channel_id: channelId
            };

            // Add appropriate source based on type
            if (sourceType === 'rtsp' && rtspUrl) {
                requestBody.rtsp_url = rtspUrl;
            } else if (sourceType === 'video' && videoPath) {
                requestBody.video_path = videoPath;
            } else {
                // Fallback for backward compatibility
                requestBody.video_path = `videos/${channelId}.mp4`;
            }

            const response = await fetch('/api/start_channel', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            });

            const result = await response.json();
            if (result.success) {
                // Check if this is a shared channel
                if (result.shared) {
                    sharedChannels[channelId] = result.active_modules || [];
                    showSharedChannelNotification(channelId, appName, result.active_modules);
                }
                
                // Check for duplicate before adding stream
                const streamBoxId = `stream-box-${appName}-${channelId}`;
                const existingStream = document.getElementById(streamBoxId);
                if (!existingStream) {
                    addVideoStream(appName, channelId, result.shared, result.active_modules);
                } else {
                    console.log(`‚è≠Ô∏è Stream already exists for ${appName}/${channelId}, skipping`);
                }
                activeChannels[appName][channelId] = { 
                    status: 'online', 
                    shared: result.shared,
                    active_modules: result.active_modules || [appName],
                    source_type: result.source_type || sourceType,
                    video_source: result.video_source || (rtspUrl || videoPath)
                };
                
                console.log(`Started ${appName} on ${sourceType} source:`, result.video_source);
                
                // Apply saved configurations after channel starts
                // Give it a moment for the video processing to initialize
                setTimeout(() => {
                    applySavedConfigurations(channelId, appName);
                }, 1000);
                
            } else {
                // Don't show alert for CashDetection if it actually starts (common timing issue)
                if (appName !== 'CashDetection') {
                    alert(`Failed to start ${appName}: ${result.error}`);
                } else {
                    console.warn(`CashDetection start response: ${result.error}, but will attempt to show video feed`);
                    // Try to add video stream anyway for CashDetection (with duplicate check)
                    const streamBoxId = `stream-box-${appName}-${channelId}`;
                    const existingStream = document.getElementById(streamBoxId);
                    if (!existingStream) {
                        addVideoStream(appName, channelId, false, [appName]);
                    } else {
                        console.log(`‚è≠Ô∏è Stream already exists for ${appName}/${channelId}, skipping CashDetection fallback`);
                    }
                }
            }
        } catch (error) {
            console.error(`Error starting ${appName}:`, error);
            // Don't show alert for CashDetection - just log it
            if (appName !== 'CashDetection') {
                alert(`Failed to start ${appName}`);
            } else {
                console.warn(`CashDetection error caught, attempting to show video feed anyway`);
                // Try to add video stream anyway for CashDetection (with duplicate check)
                const streamBoxId = `stream-box-${appName}-${channelId}`;
                const existingStream = document.getElementById(streamBoxId);
                if (!existingStream) {
                    addVideoStream(appName, channelId, false, [appName]);
                } else {
                    console.log(`‚è≠Ô∏è Stream already exists for ${appName}/${channelId}, skipping CashDetection error fallback`);
                }
            }
        }
    }

    // Unified function to stop analysis modules
    async function stopAnalysisModule(appName) {
        const selectorId = appName === 'PeopleCounter' ? 'pc-channel-selector' : 'qm-channel-selector';
        const selector = document.getElementById(selectorId);
        const channelId = selector.value;
        
        if (!channelId) return;

        try {
            const response = await fetch('/api/stop_channel', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    app_name: appName,
                    channel_id: channelId
                })
            });

            const result = await response.json();
            if (result.success) {
                removeVideoStream(appName, channelId);
                delete activeChannels[appName][channelId];
                
                // Update shared channel info
                if (channelId in sharedChannels) {
                    sharedChannels[channelId] = sharedChannels[channelId].filter(m => m !== appName);
                    if (sharedChannels[channelId].length === 0) {
                        delete sharedChannels[channelId];
                    }
                }
            }
        } catch (error) {
            console.error(`Error stopping ${appName}:`, error);
        }
    }

    // Show notification when channel is shared
    function showSharedChannelNotification(channelId, newModule, activeModules) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #238636;
            color: white;
            padding: 15px;
            border-radius: 6px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 300px;
        `;
        notification.innerHTML = `
            <strong>Shared Channel Active!</strong><br>
            Channel ${channelId} is now running:<br>
            ${activeModules.join(', ')}<br>
            <small>Multiple analyses on the same video feed</small>
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 18px; cursor: pointer;">&times;</button>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 8000);
    }

    // Video stream management with pagination
    function addVideoStream(appName, channelId, isShared = false, activeModules = []) {
        let gridId = appName === 'PeopleCounter' ? 'pc-video-grid' : 
                     appName === 'QueueMonitor' ? 'qm-video-grid' :
                     appName === 'Heatmap' ? 'hm-video-grid' :
                     appName === 'CashDetection' ? 'cd-video-grid' :
                     appName === 'FallDetection' ? 'fd-video-grid' :
                     appName === 'GroomingDetection' ? 'gd-video-grid' :
                     appName === 'DressCodeMonitoring' ? 'dcm-video-grid' :
                     appName === 'PPEMonitoring' ? 'ppe-video-grid' :
                     appName === 'MoppingDetection' ? 'mopping-video-grid' :
                     appName === 'SmokingDetection' ? 'smoking-video-grid' :
                     appName === 'CrowdDetection' ? 'crowd-video-grid' :
                     appName === 'PhoneUsageDetection' ? 'phone-video-grid' :
                     appName === 'RestrictedAreaMonitor' ? 'restricted-video-grid' :
                     appName === 'TableServiceMonitor' ? 'tsm-video-grid' :
                     appName === 'ServiceDisciplineMonitor' ? 'sdm-video-grid' :
                     appName === 'UnauthorizedEntryMonitor' ? 'uem-video-grid' :
                     appName === 'MaterialTheftMonitor' ? 'mtm-video-grid' :
                     'bd-video-grid';
        // Safety fallback in case mapping failed
        if (appName === 'UnauthorizedEntryMonitor' && gridId === 'bd-video-grid') {
            gridId = 'uem-video-grid';
        }
        if (appName === 'MaterialTheftMonitor' && gridId === 'bd-video-grid') {
            gridId = 'mtm-video-grid';
        }
        // Ensure pagination state exists for this app
        if (!videoPagination[appName]) {
            videoPagination[appName] = { currentPage: 1, streamsPerPage: 6, totalStreams: 0, allStreamBoxes: [] };
        }
        
        // Check if stream already exists (check multiple times to prevent race conditions)
        const streamBoxId = `stream-box-${appName}-${channelId}`;
        if (document.getElementById(streamBoxId)) {
            console.log(`‚è≠Ô∏è Stream ${streamBoxId} already exists in DOM, skipping addVideoStream`);
            return; // Already exists
        }
        
        // Double-check: also check if we're currently creating this stream
        if (window.streamsBeingCreated && window.streamsBeingCreated.has(streamBoxId)) {
            console.log(`‚è≠Ô∏è Stream ${streamBoxId} is currently being created, skipping duplicate call`);
            return;
        }
        
        // Mark this stream as being created
        if (!window.streamsBeingCreated) {
            window.streamsBeingCreated = new Set();
        }
        window.streamsBeingCreated.add(streamBoxId);
        
        const streamBox = document.createElement('div');
        streamBox.className = 'stream-box';
        streamBox.id = streamBoxId;
        streamBox.dataset.appName = appName;
        streamBox.dataset.channelId = channelId;
        
        const controls = appName === 'PeopleCounter' 
            ? `<button class="btn" onclick="openLineEditor('${appName}', '${channelId}')">Edit Counting Line</button>`
            : appName === 'QueueMonitor'
            ? `<button class="btn" onclick="openRoiEditor('${appName}', '${channelId}')">Configure Areas</button>`
            : appName === 'RestrictedAreaMonitor'
            ? `<button class="btn" onclick="openRoiEditor('${appName}', '${channelId}')">Configure Area</button>`
            : appName === 'Heatmap'
            ? `<button class="btn" onclick="captureHeatmapSnapshot()">üì∏ Capture Snapshot</button>`
            : ``; // BagDetection doesn't need manual configuration
        
        const sharedIndicator = isShared 
            ? `<span class="status-indicator" style="background: rgba(255, 165, 0, 0.2); color: orange; margin-left: 10px;">
                 Shared: ${activeModules.join(', ')}
               </span>`
            : '';
        
        streamBox.innerHTML = `
            <div class="stream-header">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        Channel ${channelId} - ${appName}
                        <span class="status-indicator status-online" id="status-${appName}-${channelId}">Connecting...</span>
                        ${sharedIndicator}
                    </div>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <span id="fps-${appName}-${channelId}">-- FPS</span>
                    </div>
                </div>
            </div>
            <div style="position: relative;">
                <!-- WebSocket-based streaming - no HTTP connection needed -->
                <img id="stream-img-${appName}-${channelId}" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==" alt="Video Feed" style="width: 100%; height: auto;">
                <canvas class="roi-canvas" id="roi-canvas-${channelId}"></canvas>
                <canvas class="line-canvas" id="line-canvas-${channelId}"></canvas>
            </div>
            <div class="stream-footer">
                ${appName === 'PeopleCounter' 
                    ? `IN: <span id="in-count-${channelId}">0</span> | OUT: <span id="out-count-${channelId}">0</span>`
                    : appName === 'QueueMonitor'
                    ? `Queue: <span id="queue-count-${channelId}">0</span> | Counter: <span id="counter-count-${channelId}">0</span>`
                    : appName === 'Heatmap'
                    ? `Activity Zones Detected: <span id="activity-zones-${channelId}">0</span>`
                    : appName === 'CashDetection'
                    ? `Cash Detected: <span id="cash-count-${channelId}">0</span> | Total Frames: <span id="cash-frames-${channelId}">0</span>`
                    : appName === 'FallDetection'
                    ? `Falls Detected: <span id="fall-count-${channelId}">0</span> | Total Alerts: <span id="fall-alerts-${channelId}">0</span>`
                    : appName === 'GroomingDetection'
                    ? `Violations: <span id="grooming-violations-${channelId}">0</span> | Total Checks: <span id="grooming-checks-${channelId}">0</span>`
                    : appName === 'MoppingDetection'
                    ? `Violations: <span id="mopping-violations-${channelId}">0</span> | Total Detections: <span id="mopping-detections-${channelId}">0</span>`
                    : appName === 'SmokingDetection'
                    ? `Smoking Detected: <span id="smoking-count-${channelId}">0</span> | Total Alerts: <span id="smoking-alerts-${channelId}">0</span>`
                    : appName === 'CrowdDetection'
                    ? `Crowd: <span id="crowd-count-${channelId}">0</span>`
                    : appName === 'PhoneUsageDetection'
                    ? `Phone Usage: <span id="phone-count-${channelId}">0</span> | Total Alerts: <span id="phone-alerts-${channelId}">0</span>`
                    : appName === 'RestrictedAreaMonitor'
                    ? `Violations: <span id="restricted-violations-${channelId}">0</span> | Unauthorized: <span id="restricted-unauthorized-${channelId}">0</span>`
                    : appName === 'TableServiceMonitor'
                    ? `Clean: <span id="clean-tables-${channelId}">0</span> | Unclean: <span id="unclean-tables-${channelId}">0</span> | Alerts: <span id="table-alerts-${channelId}">0</span>`
                    : appName === 'ServiceDisciplineMonitor'
                    ? `Waiting: <span id="waiting-tables-${channelId}">0</span> | Alerts: <span id="service-alerts-${channelId}">0</span>`
                    : appName === 'UnauthorizedEntryMonitor'
                    ? `Alerts: <span id="uem-alerts-${channelId}">0</span>`
                    : appName === 'MaterialTheftMonitor'
                    ? `Still Frames: <span id="mtm-still-${channelId}">0</span> | Alerts: <span id="mtm-alerts-${channelId}">0</span>`
                    : appName === 'DressCodeMonitoring'
                    ? `Violations: <span id="dcm-violations-${channelId}">0</span> | Alerts: <span id="dcm-alerts-${channelId}">0</span>`
                    : appName === 'PPEMonitoring'
                    ? `Violations: <span id="ppe-violations-${channelId}">0</span> | Alerts: <span id="ppe-alerts-${channelId}">0</span>`
                    : `Bags: <span id="bags-tracked-${channelId}">0</span> | Alerts: <span id="active-alerts-${channelId}">0</span>`
                }
            </div>
            <div style="padding: 10px; border-top: 1px solid var(--border-color);">
                ${controls}
                ${isShared ? `<button class="btn" onclick="showChannelStatus('${channelId}')" style="margin-left: 10px;">Show All Analytics</button>` : ''}
            </div>
        `;
        
        // Add to the list of all stream boxes for this app (check for duplicates first)
        const existingInList = videoPagination[appName].allStreamBoxes.find(
            box => box.id === streamBoxId
        );
        if (!existingInList) {
            videoPagination[appName].allStreamBoxes.push(streamBox);
            videoPagination[appName].totalStreams = videoPagination[appName].allStreamBoxes.length;
        } else {
            console.log(`‚è≠Ô∏è Stream ${streamBoxId} already in allStreamBoxes list, skipping duplicate add`);
            // Remove from tracking set since we're not adding it
            if (window.streamsBeingCreated) {
                window.streamsBeingCreated.delete(streamBoxId);
            }
            return; // Exit early to prevent duplicate
        }
        
        // Remove from tracking set once successfully added
        if (window.streamsBeingCreated) {
            window.streamsBeingCreated.delete(streamBoxId);
        }
        
        // Update pagination display
        updateVideoPagination(appName);
        
        // Load and display ROI/counting line after a short delay to ensure image is loaded
        setTimeout(() => {
            if (appName === 'PeopleCounter') {
                loadAndDrawCountingLine(appName, channelId);
            } else if (appName === 'QueueMonitor') {
                loadAndDrawROI(appName, channelId);
            }
        }, 1000);
        
        // Subscribe to WebSocket stream if this box is currently visible in the grid
        const grid = document.getElementById(getGridId(appName));
        if (grid && grid.contains(streamBox)) {
            subscribeToStreamInBox(streamBox);
        }
    }

    function removeVideoStream(appName, channelId) {
        // Remove from pagination array
        const pagination = videoPagination[appName];
        pagination.allStreamBoxes = pagination.allStreamBoxes.filter(box => 
            box.dataset.channelId !== channelId
        );
        pagination.totalStreams = pagination.allStreamBoxes.length;
        
        // Remove from DOM if currently displayed
        const streamBox = document.getElementById(`stream-box-${appName}-${channelId}`);
        if (streamBox) {
            streamBox.remove();
        }
        
        // Update pagination
        updateVideoPagination(appName);
    }
    
    // Load and draw counting line on video feed
    async function loadAndDrawCountingLine(appName, channelId) {
        try {
            const response = await fetch(`/api/get_counting_line/${appName}/${channelId}`);
            const result = await response.json();
            
            if (result.success && result.line_config) {
                const canvas = document.getElementById(`line-canvas-${channelId}`);
                const img = canvas?.previousElementSibling;
                
                if (!canvas || !img) {
                    console.log('Canvas or image not found for', channelId);
                    return;
                }
                
                // Store line config on canvas for future redraws
                canvas.lineConfig = result.line_config;
                canvas.dataset.lineLoaded = 'true';
                canvas.dataset.lineLoading = 'false';
                
                // Wait for image to load
                if (!img.complete || img.naturalWidth === 0) {
                    img.onload = () => drawLineOnCanvas(canvas, img, result.line_config);
                } else {
                    drawLineOnCanvas(canvas, img, result.line_config);
                }
            } else {
                const canvas = document.getElementById(`line-canvas-${channelId}`);
                if (canvas) {
                    canvas.dataset.lineLoading = 'false';
                }
            }
        } catch (error) {
            console.error('Error loading counting line:', error);
            const canvas = document.getElementById(`line-canvas-${channelId}`);
            if (canvas) {
                canvas.dataset.lineLoading = 'false';
            }
        }
    }
    
    // Draw counting line on canvas
    function drawLineOnCanvas(canvas, img, lineConfig) {
        canvas.width = img.width;
        canvas.height = img.height;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const startX = lineConfig.start.x * canvas.width;
        const startY = lineConfig.start.y * canvas.height;
        const endX = lineConfig.end.x * canvas.width;
        const endY = lineConfig.end.y * canvas.height;
        
        // Draw line
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Draw endpoints
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(startX, startY, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(endX, endY, 6, 0, Math.PI * 2);
        ctx.fill();
        
        console.log('‚úÖ Counting line drawn for', canvas.id);
    }
    
    // Load and draw ROI on video feed
    async function loadAndDrawROI(appName, channelId) {
        try {
            const response = await fetch(`/api/get_roi/${appName}/${channelId}`);
            const result = await response.json();
            
            if (result.success && result.roi_config) {
                const canvas = document.getElementById(`roi-canvas-${channelId}`);
                const img = canvas?.previousElementSibling;
                
                if (!canvas || !img) {
                    console.log('Canvas or image not found for', channelId);
                    return;
                }
                
                // Store ROI config on canvas for future redraws
                canvas.roiConfig = result.roi_config;
                canvas.dataset.roiLoaded = 'true';
                canvas.dataset.roiLoading = 'false';
                
                // Wait for image to load
                if (!img.complete || img.naturalWidth === 0) {
                    img.onload = () => drawROIOnCanvas(canvas, img, result.roi_config);
                } else {
                    drawROIOnCanvas(canvas, img, result.roi_config);
                }
            } else {
                const canvas = document.getElementById(`roi-canvas-${channelId}`);
                if (canvas) {
                    canvas.dataset.roiLoading = 'false';
                }
            }
        } catch (error) {
            console.error('Error loading ROI:', error);
            const canvas = document.getElementById(`roi-canvas-${channelId}`);
            if (canvas) {
                canvas.dataset.roiLoading = 'false';
            }
        }
    }
    
    // Draw ROI on canvas
    function drawROIOnCanvas(canvas, img, roiConfig) {
        canvas.width = img.width;
        canvas.height = img.height;
        
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw main ROI (queue area)
        if (roiConfig.main && roiConfig.main.length > 0) {
            ctx.strokeStyle = '#00ff00';
            ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            roiConfig.main.forEach((point, index) => {
                const x = point.x * canvas.width;
                const y = point.y * canvas.height;
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#00ff00';
            roiConfig.main.forEach(point => {
                const x = point.x * canvas.width;
                const y = point.y * canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // Draw secondary ROI (counter area)
        if (roiConfig.secondary && roiConfig.secondary.length > 0) {
            ctx.strokeStyle = '#ff9800';
            ctx.fillStyle = 'rgba(255, 152, 0, 0.1)';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            roiConfig.secondary.forEach((point, index) => {
                const x = point.x * canvas.width;
                const y = point.y * canvas.height;
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw points
            ctx.fillStyle = '#ff9800';
            roiConfig.secondary.forEach(point => {
                const x = point.x * canvas.width;
                const y = point.y * canvas.height;
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        console.log('‚úÖ ROI drawn for', canvas.id);
    }
    
    // Video pagination functions
    function updateVideoPagination(appName) {
        const pagination = videoPagination[appName];
        const grid = document.getElementById(getGridId(appName));
        const paginationDiv = document.getElementById(getPaginationId(appName));
        
        console.log(`üìä updateVideoPagination for ${appName}:`);
        console.log(`  Grid element (${getGridId(appName)}):`, grid ? 'FOUND' : 'NOT FOUND');
        console.log(`  Pagination div (${getPaginationId(appName)}):`, paginationDiv ? 'FOUND' : 'NOT FOUND');
        console.log(`  Total streams:`, pagination.totalStreams);
        console.log(`  Streams per page:`, pagination.streamsPerPage);
        
        if (!grid || !paginationDiv) {
            console.error(`‚ùå Missing elements for ${appName} - grid:`, grid, 'pagination:', paginationDiv);
            return;
        }
        
        // Clear current grid and unsubscribe from streams
        grid.querySelectorAll('img').forEach(img => {
            // Unsubscribe from WebSocket streams for hidden items
            const streamId = img.id;
            if (streamId && streamId.startsWith('stream-img-')) {
                const parts = streamId.replace('stream-img-', '').split('-');
                if (parts.length >= 2) {
                    const appName = parts[0];
                    const channelId = parts.slice(1).join('-');
                    socket.emit('unsubscribe_stream', { app_name: appName, channel_id: channelId });
                }
            }
        });
        
        // Clear grid and also clear the tracking set for streams that were in this grid
        const streamBoxesInGrid = grid.querySelectorAll('[id^="stream-box-"]');
        streamBoxesInGrid.forEach(box => {
            if (window.streamsBeingCreated) {
                window.streamsBeingCreated.delete(box.id);
            }
        });
        grid.innerHTML = '';
        
        // Show/hide pagination controls
        if (pagination.totalStreams <= pagination.streamsPerPage) {
            paginationDiv.style.display = 'none';
            // Show all streams and subscribe to them
            console.log(`  ‚ÑπÔ∏è Showing all ${pagination.allStreamBoxes.length} streams (no pagination needed)`);
            pagination.allStreamBoxes.forEach(box => {
                grid.appendChild(box);
                subscribeToStreamInBox(box);
            });
            return;
        }
        
        // Show pagination controls
        paginationDiv.style.display = 'flex';
        
        // Calculate pages
        const totalPages = Math.ceil(pagination.totalStreams / pagination.streamsPerPage);
        
        // Ensure current page is valid
        if (pagination.currentPage > totalPages) {
            pagination.currentPage = totalPages;
        }
        if (pagination.currentPage < 1) {
            pagination.currentPage = 1;
        }
        
        // Calculate start and end indices
        const startIndex = (pagination.currentPage - 1) * pagination.streamsPerPage;
        const endIndex = Math.min(startIndex + pagination.streamsPerPage, pagination.totalStreams);
        
        console.log(`  ‚ÑπÔ∏è Showing streams ${startIndex + 1} to ${endIndex} (page ${pagination.currentPage} of ${totalPages})`);
        
        // Show streams for current page and subscribe to them
        for (let i = startIndex; i < endIndex; i++) {
            if (pagination.allStreamBoxes[i]) {
                const box = pagination.allStreamBoxes[i];
                grid.appendChild(box);
                subscribeToStreamInBox(box);
            }
        }
        
        // Update pagination info
        const pageInfo = document.getElementById(getPageInfoId(appName));
        const showingCount = document.getElementById(getShowingCountId(appName));
        const totalCount = document.getElementById(getTotalCountId(appName));
        
        if (pageInfo) pageInfo.textContent = `Page ${pagination.currentPage} of ${totalPages}`;
        if (showingCount) showingCount.textContent = endIndex - startIndex;
        if (totalCount) totalCount.textContent = pagination.totalStreams;
        
        // Update button states
        const prevBtn = paginationDiv.querySelector('button:first-child');
        const nextBtn = paginationDiv.querySelector('button:last-child');
        
        if (prevBtn) prevBtn.disabled = pagination.currentPage <= 1;
        if (nextBtn) nextBtn.disabled = pagination.currentPage >= totalPages;
        
        console.log(`‚úÖ Pagination updated for ${appName}`);
    }
    
    function changeVideoPage(appName, direction) {
        const pagination = videoPagination[appName];
        pagination.currentPage += direction;
        updateVideoPagination(appName);
    }
    
    // Helper functions to get element IDs
    function getGridId(appName) {
        const prefixes = {
            'QueueMonitor': 'qm',
            'DressCodeMonitoring': 'dcm',
            'PPEMonitoring': 'ppe',
            'CashDetection': 'cd',
            'SmokingDetection': 'smoking',
            'CrowdDetection': 'crowd',
            'TableServiceMonitor': 'tsm',
            'ServiceDisciplineMonitor': 'sdm',
            'FallDetection': 'fd',
            'UnauthorizedEntryMonitor': 'uem',
            'MaterialTheftMonitor': 'mtm'
        };
        const prefix = prefixes[appName] || 'undefined';
        return `${prefix}-video-grid`;
    }
    
    function getPaginationId(appName) {
        const prefixes = {
            'QueueMonitor': 'qm',
            'DressCodeMonitoring': 'dcm',
            'PPEMonitoring': 'ppe',
            'CashDetection': 'cd',
            'SmokingDetection': 'smoking',
            'CrowdDetection': 'crowd',
            'TableServiceMonitor': 'tsm',
            'ServiceDisciplineMonitor': 'sdm',
            'FallDetection': 'fd',
            'UnauthorizedEntryMonitor': 'uem',
            'MaterialTheftMonitor': 'mtm'
        };
        const prefix = prefixes[appName] || 'undefined';
        return `${prefix}-video-pagination`;
    }
    
    function getPageInfoId(appName) {
        const prefixes = {
            'QueueMonitor': 'qm',
            'DressCodeMonitoring': 'dcm',
            'PPEMonitoring': 'ppe',
            'CashDetection': 'cd',
            'SmokingDetection': 'smoking',
            'CrowdDetection': 'crowd'
        };
        return `${prefixes[appName]}-page-info`;
    }
    
    function getShowingCountId(appName) {
        const prefixes = {
            'QueueMonitor': 'qm',
            'DressCodeMonitoring': 'dcm',
            'PPEMonitoring': 'ppe',
            'CashDetection': 'cd',
            'SmokingDetection': 'smoking',
            'CrowdDetection': 'crowd'
        };
        return `${prefixes[appName]}-showing-count`;
    }
    
    function getTotalCountId(appName) {
        const prefixes = {
            'QueueMonitor': 'qm',
            'DressCodeMonitoring': 'dcm',
            'PPEMonitoring': 'ppe',
            'CashDetection': 'cd',
            'SmokingDetection': 'smoking',
            'CrowdDetection': 'crowd'
        };
        return `${prefixes[appName]}-total-count`;
    }

    // WebSocket stream subscription helpers
    function subscribeToStreamInBox(streamBox) {
        const appName = streamBox.dataset.appName;
        const channelId = streamBox.dataset.channelId;
        
        if (appName && channelId) {
            console.log(`üì° Subscribing to ${appName}/${channelId}`);
            socket.emit('subscribe_stream', { app_name: appName, channel_id: channelId });
            
            // Update status to show connecting
            const status = document.getElementById(`status-${appName}-${channelId}`);
            if (status) {
                status.textContent = 'Connecting...';
                status.className = 'status-indicator status-online';
            }
            
            // Set a timeout to show error if no frames received after a grace period.
            // Some RTSP streams/modules take longer to deliver the first decodable frame than VLC.
            const streamBox = document.getElementById(`stream-box-${appName}-${channelId}`);
            if (streamBox) {
                // Clear any existing timeout
                if (streamBox.dataset.timeoutId) {
                    clearTimeout(parseInt(streamBox.dataset.timeoutId));
                }
                
                const timeoutId = setTimeout(() => {
                    const statusEl = document.getElementById(`status-${appName}-${channelId}`);
                    // Only mark as "No Signal" if we still haven't received any frames ("Live")
                    if (statusEl && statusEl.textContent !== 'Live') {
                        console.warn(`‚ö†Ô∏è No frames received for ${appName}/${channelId} after 30 seconds`);
                        statusEl.textContent = 'No Signal';
                        statusEl.className = 'status-indicator status-offline';
                    }
                }, 30000);
                
                streamBox.dataset.timeoutId = timeoutId.toString();
            }
        } else {
            console.error(`‚ùå Cannot subscribe: missing appName (${appName}) or channelId (${channelId})`);
        }
    }

    function unsubscribeFromStream(appName, channelId) {
        console.log(`Unsubscribing from ${appName}/${channelId}`);
        socket.emit('unsubscribe_stream', { app_name: appName, channel_id: channelId });
        
        // Update status
        const status = document.getElementById(`status-${appName}-${channelId}`);
        if (status) {
            status.textContent = 'Offline';
            status.className = 'status-indicator status-offline';
        }
    }

    // Show status of all modules on a shared channel
    async function showChannelStatus(channelId) {
        try {
            const response = await fetch(`/api/get_channel_status/${channelId}`);
            const status = await response.json();
            
            if (status.error) {
                alert(`Error: ${status.error}`);
                return;
            }
            
            let statusText = `Channel ${channelId} Status:\n\n`;
            statusText += `Active Modules: ${status.active_modules.join(', ')}\n`;
            statusText += `Processing: ${status.frames_processed} frames\n`;
            statusText += `Average FPS: ${status.average_fps.toFixed(2)}\n\n`;
            
            if (status.module_info) {
                for (const [moduleName, moduleData] of Object.entries(status.module_info)) {
                    statusText += `${moduleName}:\n`;
                    if (moduleName === 'PeopleCounter') {
                        statusText += `  IN: ${moduleData.in_count || 0}\n`;
                        statusText += `  OUT: ${moduleData.out_count || 0}\n`;
                        statusText += `  Net: ${moduleData.net_count || 0}\n`;
                    } else if (moduleName === 'QueueMonitor') {
                        statusText += `  Queue: ${moduleData.queue_count || 0}\n`;
                        statusText += `  Counter: ${moduleData.counter_count || 0}\n`;
                        statusText += `  ROI Configured: ${moduleData.roi_configured ? 'Yes' : 'No'}\n`;
                    }
                    statusText += '\n';
                }
            }
            
            alert(statusText);
            
        } catch (error) {
            console.error('Error getting channel status:', error);
            alert('Failed to get channel status');
        }
    }

    // Update displays
    function updatePeopleCountDisplay(data) {
        const inCountEl = document.getElementById(`in-count-${data.channel_id}`);
        const outCountEl = document.getElementById(`out-count-${data.channel_id}`);
        
        if (inCountEl) inCountEl.textContent = data.in_count;
        if (outCountEl) outCountEl.textContent = data.out_count;
    }

    function updateQueueDisplay(data) {
        const queueCountEl = document.getElementById(`queue-count-${data.channel_id}`);
        const counterCountEl = document.getElementById(`counter-count-${data.channel_id}`);
        
        if (queueCountEl) queueCountEl.textContent = data.queue_count;
        if (counterCountEl) counterCountEl.textContent = data.counter_count;
    }

    function updateCrowdDisplay(data) {
        const crowdCountEl = document.getElementById(`crowd-count-${data.channel_id}`);
        
        if (crowdCountEl) crowdCountEl.textContent = data.crowd_count || 0;
    }

    function showCrowdAlert(data) {
        // Show alert notification
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f87171;
            color: white;
            padding: 15px;
            border-radius: 6px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        alertDiv.innerHTML = `
            <strong>üë• Crowd Alert!</strong><br>
            ${data.message}
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 18px; cursor: pointer;">&times;</button>
        `;
        document.body.appendChild(alertDiv);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (alertDiv.parentElement) {
                alertDiv.remove();
            }
        }, 10000);
    }

    function updateBagDetectionDisplay(data) {
        const bagsTrackedEl = document.getElementById(`bags-tracked-${data.channel_id}`);
        const activeAlertsEl = document.getElementById(`active-alerts-${data.channel_id}`);
        
        if (bagsTrackedEl) bagsTrackedEl.textContent = data.bags_tracked || 0;
        if (activeAlertsEl) activeAlertsEl.textContent = data.active_alerts || 0;
    }

    function updateCashDetectionDisplay(data) {
        const cashCountEl = document.getElementById(`cash-count-${data.channel_id}`);
        const cashFramesEl = document.getElementById(`cash-frames-${data.channel_id}`);
        
        if (cashCountEl) cashCountEl.textContent = data.detection_count || 0;
        if (cashFramesEl) cashFramesEl.textContent = data.frame_count || 0;
    }

    function updateFallDetectionDisplay(data) {
        const fallCountEl = document.getElementById(`fall-count-${data.channel_id}`);
        const fallAlertsEl = document.getElementById(`fall-alerts-${data.channel_id}`);
        
        if (fallCountEl) fallCountEl.textContent = data.current_falls || 0;
        if (fallAlertsEl) fallAlertsEl.textContent = data.total_alerts || 0;
    }

    function updateTableServiceDisplay(data) {
        const cleanTablesEl = document.getElementById(`clean-tables-${data.channel_id}`);
        const uncleanTablesEl = document.getElementById(`unclean-tables-${data.channel_id}`);
        const tableAlertsEl = document.getElementById(`table-alerts-${data.channel_id}`);
        
        if (cleanTablesEl) cleanTablesEl.textContent = data.clean_tables || 0;
        if (uncleanTablesEl) uncleanTablesEl.textContent = data.unclean_tables || 0;
        if (tableAlertsEl) tableAlertsEl.textContent = data.total_alerts || 0;
    }

    function updateServiceDisciplineDisplay(data) {
        const waitingTablesEl = document.getElementById(`waiting-tables-${data.channel_id}`);
        const serviceAlertsEl = document.getElementById(`service-alerts-${data.channel_id}`);
        
        if (waitingTablesEl) waitingTablesEl.textContent = data.waiting_tables || 0;
        if (serviceAlertsEl) serviceAlertsEl.textContent = data.total_alerts || 0;
    }

    function showPPEAlert(data) {
        const violations = data.violations || [];
        const violationsText = Array.isArray(violations) ? violations.join(', ') : 'PPE violation';
        showNotification(`üõ°Ô∏è PPE Violation: ${violationsText}`, `Channel: ${data.channel_id}`, 'warning');
    }
    
    function showQueueAlert(data) {
        // Show alert notification
        const alertDiv = document.createElement('div');
        alertDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f87171;
            color: white;
            padding: 15px;
            border-radius: 6px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            max-width: 400px;
        `;
        alertDiv.innerHTML = `
            <strong>üö® Queue Alert!</strong><br>
            <div style="margin-top: 8px; font-size: 0.9em;">
                Channel: ${data.channel_id || 'Unknown'}<br>
                ${data.message || 'Queue violation detected'}
            </div>
            <button onclick="this.parentElement.remove()" style="float: right; background: none; border: none; color: white; font-size: 18px; cursor: pointer; margin-top: -5px;">&times;</button>
        `;
        
        document.body.appendChild(alertDiv);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (alertDiv.parentElement) {
                alertDiv.remove();
            }
        }, 10000);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (alertDiv.parentElement) {
                alertDiv.remove();
            }
        }, 10000);
    }

    // Tab functionality
    // Switch between main module tabs
    function switchModule(evt, moduleName) {
        // Hide all module contents
        const moduleContents = document.querySelectorAll('.module-content');
        moduleContents.forEach(content => content.classList.remove('active'));
        
        // Remove active class from all main module tab buttons
        const mainTabButtons = evt.currentTarget.parentElement.querySelectorAll('.tab-button');
        mainTabButtons.forEach(button => button.classList.remove('active'));
        
        // Show selected module content
        const targetModule = document.getElementById(moduleName + '-module');
        if (targetModule) {
            targetModule.classList.add('active');
        }
        
        // Activate the clicked tab button
        evt.currentTarget.classList.add('active');
    }

    // Switch between sub-tabs within a module
    function openTab(evt, tabName) {
        // Get the parent module container
        const moduleContainer = evt.currentTarget.closest('.module-content');
        
        if (moduleContainer) {
            // Only affect tabs within this module
            const tabContents = moduleContainer.querySelectorAll('.tab-content');
            const tabButtons = moduleContainer.querySelectorAll('.tab-nav:not(:first-child) .tab-button');
            
            tabContents.forEach(content => content.classList.remove('active'));
            tabButtons.forEach(button => button.classList.remove('active'));
        } else {
            // Fallback to global behavior if not within a module
            const tabContents = document.querySelectorAll('.tab-content');
            const tabButtons = document.querySelectorAll('.tab-button');
            
            tabContents.forEach(content => content.classList.remove('active'));
            tabButtons.forEach(button => button.classList.remove('active'));
        }
        
        document.getElementById(tabName).classList.add('active');
        evt.currentTarget.classList.add('active');
    }

    // ROI Editor functions
    function openRoiEditor(appName, channelId) {
        // ROI editing is only used for QueueMonitor in this phase.
        if (appName !== 'QueueMonitor') {
            console.warn('ROI editor is only available for Queue & Wait Time module.');
            return;
        }

        roiState.currentApp = appName;
        roiState.currentChannel = channelId;
        roiState.points = { main: [], secondary: [] };
        roiState.imageLoaded = false;
        roiState.isDragging = false;
        roiState.dragPointIndex = -1;
        roiState.isDrawing = false;
        
        const modal = document.getElementById('roiModal');
        const image = document.getElementById('roiImage');
        const canvas = document.getElementById('roiCanvas');
        
        roiState.canvas = canvas;
        roiState.ctx = canvas.getContext('2d');
        
        // Customize UI based on app type
        const modalHeader = modal.querySelector('.modal-header h2');
        const roiInstructions = document.getElementById('roiInstructions');
        const roiInfo = document.getElementById('roiInfo');
        const modeButtons = modal.querySelector('.btn-group');
        
        if (appName === 'RestrictedAreaMonitor') {
            // Single region mode for RestrictedAreaMonitor
            modalHeader.textContent = 'Configure Restricted Area';
            roiInstructions.innerHTML = `
                <strong>Drawing Restricted Area (Yellow):</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Click to add points and create polygon boundaries</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Area is shown as <strong>outline border only</strong> (no fill)</li>
                    <li>Need at least 3 points to form a complete area</li>
                    <li>Only <strong>uniform_black</strong> class is allowed inside this area</li>
                </ul>
            `;
            roiInfo.textContent = 'Restricted Area: 0 points';
            modeButtons.style.display = 'none'; // Hide mode toggle buttons
            roiState.currentMode = 'main'; // Force to main region only
        } else {
            // Queue Monitor mode with two regions
            modalHeader.textContent = 'Configure Queue Areas';
            roiInstructions.innerHTML = `
                <strong>Drawing Queue Area (Yellow):</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Click to add points and create polygon boundaries</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Areas are shown as <strong>outline borders only</strong> (no fill)</li>
                    <li>Need at least 3 points to form a complete area</li>
                </ul>
            `;
            roiInfo.textContent = 'Queue Area: 0 points | Counter Area: 0 points';
            modeButtons.style.display = ''; // Show mode toggle buttons
        }
        
        // Load existing ROI configuration
        loadExistingRoiConfig(appName, channelId);
        
        // Set up image load handler
        image.onload = function() {
            // Set canvas size to match image
            canvas.width = image.width;
            canvas.height = image.height;
            canvas.style.width = image.offsetWidth + 'px';
            canvas.style.height = image.offsetHeight + 'px';
            
            roiState.imageLoaded = true;
            drawRoi();
            setupRoiInteraction();
        };
        
        image.src = `/video_feed/${appName}/${channelId}?t=${Date.now()}`;
        modal.style.display = 'block';
    }

    async function loadExistingRoiConfig(appName, channelId) {
        try {
            // First try to get from running module
            const response = await fetch(`/api/get_roi/${appName}/${channelId}`);
            const result = await response.json();
            
            if (result.success && result.roi_config) {
                roiState.points = result.roi_config;
                console.log('‚úÖ Loaded ROI from running module:', result.roi_config);
            } else {
                // If not running, load from database
                const savedConfig = await loadConfigFromDatabase(channelId, appName, 'roi');
                if (savedConfig) {
                    roiState.points = savedConfig;
                    console.log('‚úÖ Loaded ROI from database:', savedConfig);
                } else {
                    roiState.points = { main: [], secondary: [] };
                    console.log('‚ÑπÔ∏è No saved ROI configuration found');
                }
            }
        } catch (error) {
            console.error('Error loading ROI configuration:', error);
            roiState.points = { main: [], secondary: [] };
        }
    }

    function setupRoiInteraction() {
        const canvas = roiState.canvas;
        
        // Mouse event handlers
        canvas.onmousedown = handleRoiMouseDown;
        canvas.onmousemove = handleRoiMouseMove;
        canvas.onmouseup = handleRoiMouseUp;
        canvas.onmouseleave = handleRoiMouseUp;
        canvas.ondblclick = handleRoiDoubleClick;
        
        // Touch event handlers for mobile
        canvas.ontouchstart = handleRoiTouchStart;
        canvas.ontouchmove = handleRoiTouchMove;
        canvas.ontouchend = handleRoiTouchEnd;
    }

    function getRoiCanvasCoordinates(event) {
        const canvas = roiState.canvas;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        let clientX, clientY;
        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }
        
        return {
            x: (clientX - rect.left) * scaleX / canvas.width,
            y: (clientY - rect.top) * scaleY / canvas.height
        };
    }

    function getDistanceToRoiPoint(mousePos, point) {
        const canvasPos = {
            x: point.x * roiState.canvas.width,
            y: point.y * roiState.canvas.height
        };
        const mouseCanvasPos = {
            x: mousePos.x * roiState.canvas.width,
            y: mousePos.y * roiState.canvas.height
        };
        
        return Math.sqrt(
            Math.pow(mouseCanvasPos.x - canvasPos.x, 2) + 
            Math.pow(mouseCanvasPos.y - canvasPos.y, 2)
        );
    }

    function handleRoiMouseDown(event) {
        event.preventDefault();
        const mousePos = getRoiCanvasCoordinates(event);
        
        // Check if clicking near existing points for dragging
        let foundPoint = false;
        ['main', 'secondary'].forEach(mode => {
            roiState.points[mode].forEach((point, index) => {
                if (getDistanceToRoiPoint(mousePos, point) < 15) {
                    roiState.isDragging = true;
                    roiState.dragPointIndex = index;
                    roiState.currentMode = mode;
                    roiState.canvas.style.cursor = 'grabbing';
                    foundPoint = true;
                    
                    // Update mode buttons
                    updateRoiModeButtons(mode);
                }
            });
        });
        
        // If not dragging existing point, start drawing new point
        if (!foundPoint) {
            const newPoint = {
                x: Math.max(0, Math.min(1, mousePos.x)),
                y: Math.max(0, Math.min(1, mousePos.y))
            };
            roiState.points[roiState.currentMode].push(newPoint);
            roiState.isDrawing = true;
            drawRoi();
            updateRoiInfo();
        }
    }

    function handleRoiMouseMove(event) {
        event.preventDefault();
        const mousePos = getRoiCanvasCoordinates(event);
        
        if (roiState.isDragging && roiState.dragPointIndex >= 0) {
            // Update dragged point position
            roiState.points[roiState.currentMode][roiState.dragPointIndex] = {
                x: Math.max(0, Math.min(1, mousePos.x)),
                y: Math.max(0, Math.min(1, mousePos.y))
            };
            drawRoi();
            updateRoiInfo();
        } else {
            // Update cursor based on hover position
            let cursor = 'crosshair';
            let hovering = false;
            
            ['main', 'secondary'].forEach(mode => {
                roiState.points[mode].forEach((point, index) => {
                    if (getDistanceToRoiPoint(mousePos, point) < 15) {
                        cursor = 'grab';
                        hovering = true;
                        roiState.hoverPointIndex = index;
                        roiState.hoverMode = mode;
                    }
                });
            });
            
            if (!hovering) {
                roiState.hoverPointIndex = -1;
                roiState.hoverMode = null;
            }
            
            roiState.canvas.style.cursor = cursor;
        }
    }

    function handleRoiMouseUp(event) {
        roiState.isDragging = false;
        roiState.dragPointIndex = -1;
        roiState.isDrawing = false;
        roiState.canvas.style.cursor = 'crosshair';
    }

    function handleRoiDoubleClick(event) {
        event.preventDefault();
        const mousePos = getRoiCanvasCoordinates(event);
        
        // Check if double-clicking on a point to delete it
        ['main', 'secondary'].forEach(mode => {
            roiState.points[mode].forEach((point, index) => {
                if (getDistanceToRoiPoint(mousePos, point) < 15) {
                    roiState.points[mode].splice(index, 1);
                    drawRoi();
                    updateRoiInfo();
                }
            });
        });
    }

    // Touch event handlers
    function handleRoiTouchStart(event) {
        event.preventDefault();
        handleRoiMouseDown(event);
    }

    function handleRoiTouchMove(event) {
        event.preventDefault();
        handleRoiMouseMove(event);
    }

    function handleRoiTouchEnd(event) {
        event.preventDefault();
        handleRoiMouseUp(event);
    }

    function updateRoiModeButtons(mode) {
        const buttons = document.querySelectorAll('#roiModal .btn-group .btn');
        buttons.forEach(btn => btn.classList.remove('selected'));
        if (mode === 'main') {
            buttons[0]?.classList.add('selected');
        } else {
            buttons[1]?.classList.add('selected');
        }
    }

    function drawRoi() {
        if (!roiState.imageLoaded || !roiState.ctx) return;
        
        const ctx = roiState.ctx;
        const canvas = roiState.canvas;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (roiState.currentApp === 'RestrictedAreaMonitor') {
            // Draw single ROI (Restricted Area) in yellow for RestrictedAreaMonitor
            if (roiState.points.main.length > 0) {
                drawRoiPolygon(ctx, roiState.points.main, '#ffff00', null, 'Restricted Area');
            }
        } else {
            // Draw dual ROIs for QueueMonitor
            // Draw main ROI (Queue Area) in yellow
            if (roiState.points.main.length > 0) {
                drawRoiPolygon(ctx, roiState.points.main, '#ffff00', null, 'Queue Area');
            }
            
            // Draw secondary ROI (Counter Area) in cyan
            if (roiState.points.secondary.length > 0) {
                drawRoiPolygon(ctx, roiState.points.secondary, '#00ffff', null, 'Counter Area');
            }
        }
        
        // Update ROI info
        updateRoiInfo();
    }

    function drawRoiPolygon(ctx, points, strokeColor, fillColor, label) {
        if (points.length === 0) return;
        
        const canvas = roiState.canvas;
        
        // Draw polygon outline only (no fill)
        if (points.length > 1) {
            ctx.beginPath();
            ctx.moveTo(points[0].x * canvas.width, points[0].y * canvas.height);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x * canvas.width, points[i].y * canvas.height);
            }
            if (points.length > 2) {
                ctx.closePath();
            }
            
            // Draw border with shadow for better visibility
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 5;
            ctx.stroke();
            
            // Draw main border
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // Draw points
        points.forEach((point, index) => {
            const x = point.x * canvas.width;
            const y = point.y * canvas.height;
            
            // Draw point circle with border only
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = strokeColor;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw inner circle
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            
            // Draw point number
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#000000';
            ctx.fillText((index + 1).toString(), x + 15, y - 8);
            ctx.fillStyle = '#ffffff';
            ctx.fillText((index + 1).toString(), x + 14, y - 9);
        });
        
        // Draw label if polygon is complete
        if (points.length > 2) {
            // Calculate center of polygon for label placement
            let centerX = 0, centerY = 0;
            points.forEach(point => {
                centerX += point.x * canvas.width;
                centerY += point.y * canvas.height;
            });
            centerX /= points.length;
            centerY /= points.length;
            
            // Draw label background
            ctx.font = 'bold 14px Arial';
            const textWidth = ctx.measureText(label).width;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(centerX - textWidth/2 - 8, centerY - 22, textWidth + 16, 28);
            
            // Draw label border
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(centerX - textWidth/2 - 8, centerY - 22, textWidth + 16, 28);
            
            // Draw label text
            ctx.fillStyle = '#ffffff';
            ctx.fillText(label, centerX - textWidth/2, centerY - 5);
        }
    }

    function updateRoiInfo() {
        // Update info display if element exists
        const infoElement = document.getElementById('roiInfo');
        if (infoElement) {
            const mainPoints = roiState.points.main.length;
            
            if (roiState.currentApp === 'RestrictedAreaMonitor') {
                // Single region display for RestrictedAreaMonitor
                infoElement.innerHTML = `
                    Restricted Area: ${mainPoints} points${mainPoints > 2 ? ' (Complete)' : ''}
                `;
            } else {
                // Dual region display for QueueMonitor
                const secondaryPoints = roiState.points.secondary.length;
                infoElement.innerHTML = `
                    Queue Area: ${mainPoints} points${mainPoints > 2 ? ' (Complete)' : ''} | 
                    Counter Area: ${secondaryPoints} points${secondaryPoints > 2 ? ' (Complete)' : ''}
                `;
            }
        }
    }

    function closeRoiModal() {
        document.getElementById('roiModal').style.display = 'none';
    }

    function setRoiMode(mode) {
        roiState.currentMode = mode;
        const buttons = document.querySelectorAll('#roiModal .btn-group .btn');
        buttons.forEach(btn => btn.classList.remove('selected'));
        event.target.classList.add('selected');
        
        // Update instructions based on mode
        updateRoiInstructions(mode);
    }

    function updateRoiInstructions(mode) {
        const instructionElement = document.getElementById('roiInstructions');
        if (instructionElement) {
            const modeText = mode === 'main' ? 'Queue Area (Yellow)' : 'Counter Area (Cyan)';
            instructionElement.innerHTML = `
                <strong>Drawing ${modeText}:</strong>
                <ul style="margin: 5px 0 0 20px; font-size: 0.9em;">
                    <li>Click to add points and create polygon boundaries</li>
                    <li>Drag existing points to adjust the area shape</li>
                    <li>Double-click on points to delete them</li>
                    <li>Need at least 3 points to form a complete area</li>
                </ul>
            `;
        }
    }

    function clearCurrentRoi() {
        roiState.points[roiState.currentMode] = [];
        if (roiState.imageLoaded) {
            drawRoi();
        }
    }

    async function clearAllRoi() {
        if (!confirm('Are you sure you want to clear all ROI points? This will be saved immediately.')) {
            return;
        }
        
        console.log('clearAllRoi called - currentApp:', roiState.currentApp);
        console.log('Before clear - points:', JSON.stringify(roiState.points));
        roiState.points = { main: [], secondary: [] };
        console.log('After clear - points:', JSON.stringify(roiState.points));
        
        // Redraw canvas
        if (roiState.imageLoaded) {
            console.log('Drawing ROI after clear');
            drawRoi();
        } else {
            console.log('No image loaded, skipping drawRoi');
        }
        
        // Auto-save the cleared ROI
        try {
            // Save to active module (runtime)
            const response = await fetch('/api/set_roi', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    app_name: roiState.currentApp,
                    channel_id: roiState.currentChannel,
                    roi_points: roiState.points
                })
            });

            const result = await response.json();
            if (result.success) {
                // Save to database for persistence
                await saveConfigToDatabase(roiState.currentChannel, roiState.currentApp, 'roi', roiState.points);
                
                // Reload the video stream to remove ROI overlay
                const videoElement = document.querySelector(`img[data-channel="${roiState.currentChannel}"][data-app="${roiState.currentApp}"]`);
                if (videoElement) {
                    const currentSrc = videoElement.src.split('?')[0];
                    videoElement.src = `${currentSrc}?t=${Date.now()}`;
                    console.log('‚úÖ Video stream reloaded - ROI cleared');
                }
                
                alert('All ROI points cleared successfully!');
            } else {
                alert(`Error clearing ROI: ${result.error}`);
            }
        } catch (error) {
            console.error('Error clearing ROI:', error);
            alert('Failed to clear ROI configuration');
        }
    }

    function createRectangleRoi() {
        // Create a rectangular ROI in the center
        const mode = roiState.currentMode;
        roiState.points[mode] = [
            {x: 0.3, y: 0.3},
            {x: 0.7, y: 0.3},
            {x: 0.7, y: 0.7},
            {x: 0.3, y: 0.7}
        ];
        if (roiState.imageLoaded) {
            drawRoi();
        }
    }

    function createCircleRoi() {
        // Create a circular ROI (approximated with many points)
        const mode = roiState.currentMode;
        const centerX = 0.5;
        const centerY = 0.5;
        const radius = 0.2;
        const numPoints = 12;
        
        roiState.points[mode] = [];
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * 2 * Math.PI;
            roiState.points[mode].push({
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            });
        }
        if (roiState.imageLoaded) {
            drawRoi();
        }
    }

    async function saveRoi() {
        try {
            // Log the ROI points being saved
            console.log('=================================');
            console.log('üíæ SAVING ROI CONFIGURATION');
            console.log('=================================');
            console.log('App:', roiState.currentApp);
            console.log('Channel:', roiState.currentChannel);
            console.log('ROI Points:', JSON.stringify(roiState.points, null, 2));
            console.log('Main ROI points count:', roiState.points.main ? roiState.points.main.length : 0);
            console.log('Secondary ROI points count:', roiState.points.secondary ? roiState.points.secondary.length : 0);
            console.log('=================================');
            
            // Save to active module (runtime)
            const response = await fetch('/api/set_roi', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    app_name: roiState.currentApp,
                    channel_id: roiState.currentChannel,
                    roi_points: roiState.points
                })
            });

            const result = await response.json();
            console.log('API Response:', result);
            if (result.success) {
                console.log('‚úÖ ROI saved to runtime module successfully');
                
                // Save to database for persistence
                console.log('üíæ Saving ROI to database for persistence...');
                await saveConfigToDatabase(roiState.currentChannel, roiState.currentApp, 'roi', roiState.points);
                console.log('‚úÖ ROI saved to database successfully');
                
                // Reload the video stream to show ROI overlay
                const videoElement = document.querySelector(`img[data-channel="${roiState.currentChannel}"][data-app="${roiState.currentApp}"]`);
                if (videoElement) {
                    const currentSrc = videoElement.src.split('?')[0];
                    videoElement.src = `${currentSrc}?t=${Date.now()}`;
                    console.log('‚úÖ Video stream reloaded to display ROI overlay');
                }
                
                console.log('=================================');
                console.log('‚úÖ ROI CONFIGURATION SAVED SUCCESSFULLY!');
                console.log('=================================');
                
                alert('ROI configuration saved successfully! ROI will now be displayed on the video feed.');
                closeRoiModal();
            } else {
                alert(`Error saving ROI: ${result.error}`);
            }
        } catch (error) {
            console.error('Error saving ROI:', error);
            alert('Failed to save ROI configuration');
        }
    }

    // Line Editor functions
    function openLineEditor(appName, channelId) {
        lineState.currentApp = appName;
        lineState.currentChannel = channelId;
        
        const modal = document.getElementById('lineModal');
        const image = document.getElementById('lineImage');
        const canvas = document.getElementById('lineCanvas');
        
        lineState.canvas = canvas;
        lineState.ctx = canvas.getContext('2d');
        lineState.imageLoaded = false;
        
        // Load existing line configuration
        loadExistingLineConfig(appName, channelId);
        
        // Set up image load handler
        image.onload = function() {
            // Set canvas size to match image
            canvas.width = image.width;
            canvas.height = image.height;
            canvas.style.width = image.offsetWidth + 'px';
            canvas.style.height = image.offsetHeight + 'px';
            
            lineState.imageLoaded = true;
            drawLine();
            setupLineInteraction();
        };
        
        image.src = `/video_feed/${appName}/${channelId}?t=${Date.now()}`;
        modal.style.display = 'block';
    }

    async function loadExistingLineConfig(appName, channelId) {
        try {
            // First try to get from running module
            const response = await fetch(`/api/get_counting_line/${appName}/${channelId}`);
            const result = await response.json();
            
            if (result.success && result.line_config) {
                const config = result.line_config;
                lineState.line = {
                    start: config.start,
                    end: config.end
                };
                lineState.orientation = config.orientation || 'vertical';
                
                // Update orientation buttons
                const buttons = document.querySelectorAll('#lineModal .btn-group .btn');
                buttons.forEach(btn => btn.classList.remove('selected'));
                if (lineState.orientation === 'vertical') {
                    buttons[0]?.classList.add('selected');
                } else if (lineState.orientation === 'horizontal') {
                    buttons[1]?.classList.add('selected');
                } else {
                    buttons[2]?.classList.add('selected');
                }
                
                console.log('‚úÖ Loaded line from running module:', config);
            } else {
                // If not running, load from database
                const savedConfig = await loadConfigFromDatabase(channelId, appName, 'counting_line');
                if (savedConfig) {
                    lineState.line = {
                        start: savedConfig.start,
                        end: savedConfig.end
                    };
                    lineState.orientation = savedConfig.orientation || 'vertical';
                    
                    // Update orientation buttons
                    const buttons = document.querySelectorAll('#lineModal .btn-group .btn');
                    buttons.forEach(btn => btn.classList.remove('selected'));
                    if (lineState.orientation === 'vertical') {
                        buttons[0]?.classList.add('selected');
                    } else if (lineState.orientation === 'horizontal') {
                        buttons[1]?.classList.add('selected');
                    } else {
                        buttons[2]?.classList.add('selected');
                    }
                    
                    console.log('‚úÖ Loaded line from database:', savedConfig);
                } else {
                    // Use default configuration
                    lineState.line = { start: {x: 0.5, y: 0.1}, end: {x: 0.5, y: 0.9} };
                    lineState.orientation = 'vertical';
                    console.log('‚ÑπÔ∏è No saved line configuration found, using default');
                }
            }
        } catch (error) {
            console.error('Error loading line configuration:', error);
            // Use default configuration if loading fails
            lineState.line = { start: {x: 0.5, y: 0.1}, end: {x: 0.5, y: 0.9} };
            lineState.orientation = 'vertical';
        }
    }

    function setupLineInteraction() {
        const canvas = lineState.canvas;
        
        // Mouse event handlers
        canvas.onmousedown = handleLineMouseDown;
        canvas.onmousemove = handleLineMouseMove;
        canvas.onmouseup = handleLineMouseUp;
        canvas.onmouseleave = handleLineMouseUp;
        
        // Touch event handlers for mobile
        canvas.ontouchstart = handleLineTouchStart;
        canvas.ontouchmove = handleLineTouchMove;
        canvas.ontouchend = handleLineTouchEnd;
    }

    function getCanvasCoordinates(event) {
        const canvas = lineState.canvas;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        let clientX, clientY;
        if (event.touches && event.touches.length > 0) {
            clientX = event.touches[0].clientX;
            clientY = event.touches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }
        
        return {
            x: (clientX - rect.left) * scaleX / canvas.width,
            y: (clientY - rect.top) * scaleY / canvas.height
        };
    }

    function getDistanceToPoint(mousePos, point) {
        const canvasPos = {
            x: point.x * lineState.canvas.width,
            y: point.y * lineState.canvas.height
        };
        const mouseCanvasPos = {
            x: mousePos.x * lineState.canvas.width,
            y: mousePos.y * lineState.canvas.height
        };
        
        return Math.sqrt(
            Math.pow(mouseCanvasPos.x - canvasPos.x, 2) + 
            Math.pow(mouseCanvasPos.y - canvasPos.y, 2)
        );
    }

    function getDistanceToLine(mousePos, line) {
        const start = {
            x: line.start.x * lineState.canvas.width,
            y: line.start.y * lineState.canvas.height
        };
        const end = {
            x: line.end.x * lineState.canvas.width,
            y: line.end.y * lineState.canvas.height
        };
        const mouse = {
            x: mousePos.x * lineState.canvas.width,
            y: mousePos.y * lineState.canvas.height
        };
        
        // Calculate distance from point to line segment
        const A = mouse.x - start.x;
        const B = mouse.y - start.y;
        const C = end.x - start.x;
        const D = end.y - start.y;
        
        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        
        if (lenSq === 0) return Math.sqrt(A * A + B * B); // start and end are the same point
        
        let param = dot / lenSq;
        
        let xx, yy;
        if (param < 0) {
            xx = start.x;
            yy = start.y;
        } else if (param > 1) {
            xx = end.x;
            yy = end.y;
        } else {
            xx = start.x + param * C;
            yy = start.y + param * D;
        }
        
        const dx = mouse.x - xx;
        const dy = mouse.y - yy;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function handleLineMouseDown(event) {
        event.preventDefault();
        const mousePos = getCanvasCoordinates(event);
        
        // Check if clicking near start point (within 20 pixels for easier grabbing)
        if (getDistanceToPoint(mousePos, lineState.line.start) < 20 / lineState.canvas.width) {
            lineState.isDragging = true;
            lineState.dragPoint = 'start';
            lineState.canvas.style.cursor = 'grabbing';
            return;
        }
        
        // Check if clicking near end point (within 20 pixels for easier grabbing)
        if (getDistanceToPoint(mousePos, lineState.line.end) < 20 / lineState.canvas.width) {
            lineState.isDragging = true;
            lineState.dragPoint = 'end';
            lineState.canvas.style.cursor = 'grabbing';
            return;
        }
        
        // Check if clicking near the line (within 15 pixels for easier grabbing)
        if (getDistanceToLine(mousePos, lineState.line) < 15) {
            lineState.isDragging = true;
            lineState.dragPoint = 'line';
            lineState.dragOffset = {
                x: mousePos.x - lineState.line.start.x,
                y: mousePos.y - lineState.line.start.y
            };
            lineState.canvas.style.cursor = 'grabbing';
            return;
        }
    }

    function handleLineMouseMove(event) {
        event.preventDefault();
        const mousePos = getCanvasCoordinates(event);
        
        if (lineState.isDragging) {
            if (lineState.dragPoint === 'start') {
                // Allow free movement of start point anywhere within canvas
                lineState.line.start = { 
                    x: Math.max(0, Math.min(1, mousePos.x)), 
                    y: Math.max(0, Math.min(1, mousePos.y)) 
                };
                // Update orientation based on line angle
                updateLineOrientation();
            } else if (lineState.dragPoint === 'end') {
                // Allow free movement of end point anywhere within canvas
                lineState.line.end = { 
                    x: Math.max(0, Math.min(1, mousePos.x)), 
                    y: Math.max(0, Math.min(1, mousePos.y)) 
                };
                // Update orientation based on line angle
                updateLineOrientation();
            } else if (lineState.dragPoint === 'line') {
                // Move entire line while maintaining length and angle
                const newStartX = mousePos.x - lineState.dragOffset.x;
                const newStartY = mousePos.y - lineState.dragOffset.y;
                const deltaX = lineState.line.end.x - lineState.line.start.x;
                const deltaY = lineState.line.end.y - lineState.line.start.y;
                
                // Calculate bounded positions to keep entire line within canvas
                let boundedStartX = Math.max(0, Math.min(1, newStartX));
                let boundedStartY = Math.max(0, Math.min(1, newStartY));
                
                // Check if end point would go out of bounds and adjust accordingly
                if (boundedStartX + deltaX > 1) boundedStartX = 1 - deltaX;
                if (boundedStartX + deltaX < 0) boundedStartX = -deltaX;
                if (boundedStartY + deltaY > 1) boundedStartY = 1 - deltaY;
                if (boundedStartY + deltaY < 0) boundedStartY = -deltaY;
                
                lineState.line.start = { x: boundedStartX, y: boundedStartY };
                lineState.line.end = { x: boundedStartX + deltaX, y: boundedStartY + deltaY };
            }
            drawLine();
            updateLineInfo();
        } else {
            // Update cursor based on hover position
            let cursor = 'crosshair';
            if (getDistanceToPoint(mousePos, lineState.line.start) < 20 / lineState.canvas.width ||
                getDistanceToPoint(mousePos, lineState.line.end) < 20 / lineState.canvas.width) {
                cursor = 'grab';
            } else if (getDistanceToLine(mousePos, lineState.line) < 15) {
                cursor = 'move';
            }
            lineState.canvas.style.cursor = cursor;
        }
    }

    function updateLineOrientation() {
        const deltaX = Math.abs(lineState.line.end.x - lineState.line.start.x);
        const deltaY = Math.abs(lineState.line.end.y - lineState.line.start.y);
        
        // Determine if line is more horizontal or vertical
        if (deltaX > deltaY) {
            lineState.orientation = 'horizontal';
        } else {
            lineState.orientation = 'vertical';
        }
        
        // Update button selection
        const buttons = document.querySelectorAll('#lineModal .btn-group .btn');
        buttons.forEach(btn => btn.classList.remove('selected'));
        if (lineState.orientation === 'vertical') {
            buttons[0]?.classList.add('selected');
        } else {
            buttons[1]?.classList.add('selected');
        }
    }

    function updateLineInfo() {
        // Calculate line length and angle for display
        const deltaX = lineState.line.end.x - lineState.line.start.x;
        const deltaY = lineState.line.end.y - lineState.line.start.y;
        const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
        
        // Update info display if element exists
        const infoElement = document.getElementById('lineInfo');
        if (infoElement) {
            infoElement.innerHTML = `
                Length: ${(length * 100).toFixed(1)}% | 
                Angle: ${angle.toFixed(1)}¬∞
            `;
        }
    }

    function handleLineMouseUp(event) {
        lineState.isDragging = false;
        lineState.dragPoint = null;
        lineState.canvas.style.cursor = 'crosshair';
    }

    // Touch event handlers
    function handleLineTouchStart(event) {
        event.preventDefault();
        handleLineMouseDown(event);
    }

    function handleLineTouchMove(event) {
        event.preventDefault();
        handleLineMouseMove(event);
    }

    function handleLineTouchEnd(event) {
        event.preventDefault();
        handleLineMouseUp(event);
    }

    function drawLine() {
        if (!lineState.imageLoaded || !lineState.ctx) return;
        
        const ctx = lineState.ctx;
        const canvas = lineState.canvas;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Calculate positions
        const startX = lineState.line.start.x * canvas.width;
        const startY = lineState.line.start.y * canvas.height;
        const endX = lineState.line.end.x * canvas.width;
        const endY = lineState.line.end.y * canvas.height;
        
        // Draw line shadow for better visibility
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 5;
        ctx.stroke();
        
        // Draw main line
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw line direction arrow in the middle
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;
        const angle = Math.atan2(endY - startY, endX - startX);
        
        // Arrow head
        const arrowLength = 15;
        const arrowAngle = Math.PI / 6;
        
        ctx.beginPath();
        ctx.moveTo(midX, midY);
        ctx.lineTo(
            midX - arrowLength * Math.cos(angle - arrowAngle),
            midY - arrowLength * Math.sin(angle - arrowAngle)
        );
        ctx.moveTo(midX, midY);
        ctx.lineTo(
            midX - arrowLength * Math.cos(angle + arrowAngle),
            midY - arrowLength * Math.sin(angle + arrowAngle)
        );
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw start point (larger for easier grabbing)
        ctx.beginPath();
        ctx.arc(startX, startY, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#ff0000';
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw inner circle for start point
        ctx.beginPath();
        ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        
        // Draw end point (larger for easier grabbing)
        ctx.beginPath();
        ctx.arc(endX, endY, 12, 0, 2 * Math.PI);
        ctx.fillStyle = '#0000ff';
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw inner circle for end point
        ctx.beginPath();
        ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        
        // Add enhanced labels with background
        ctx.font = 'bold 14px Arial';
        
        // Start label
        const startLabelX = startX + 18;
        const startLabelY = startY - 8;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(startLabelX - 2, startLabelY - 16, 48, 20);
        ctx.fillStyle = '#ffffff';
        ctx.fillText('START', startLabelX, startLabelY);
        
        // End label
        const endLabelX = endX + 18;
        const endLabelY = endY - 8;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(endLabelX - 2, endLabelY - 16, 35, 20);
        ctx.fillStyle = '#ffffff';
        ctx.fillText('END', endLabelX, endLabelY);
        
        // Draw grab indicators (small circles along the line for visual feedback)
        const numIndicators = 5;
        for (let i = 1; i < numIndicators; i++) {
            const t = i / numIndicators;
            const indicatorX = startX + t * (endX - startX);
            const indicatorY = startY + t * (endY - startY);
            
            ctx.beginPath();
            ctx.arc(indicatorX, indicatorY, 3, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // Update line info
        updateLineInfo();
    }

    function closeLineModal() {
        document.getElementById('lineModal').style.display = 'none';
    }

    function setLineOrientation(orientation) {
        lineState.orientation = orientation;
        const buttons = document.querySelectorAll('#lineModal .btn-group .btn');
        buttons.forEach(btn => btn.classList.remove('selected'));
        event.target.classList.add('selected');
        
        // Update line position based on orientation
        if (orientation === 'vertical') {
            lineState.line = { start: {x: 0.5, y: 0.1}, end: {x: 0.5, y: 0.9} };
        } else if (orientation === 'horizontal') {
            lineState.line = { start: {x: 0.1, y: 0.5}, end: {x: 0.9, y: 0.5} };
        }
        
        // Redraw the line
        if (lineState.imageLoaded) {
            drawLine();
        }
    }

    function resetLineToCenter() {
        if (lineState.orientation === 'vertical') {
            lineState.line = { start: {x: 0.5, y: 0.1}, end: {x: 0.5, y: 0.9} };
        } else {
            lineState.line = { start: {x: 0.1, y: 0.5}, end: {x: 0.9, y: 0.5} };
        }
        
        if (lineState.imageLoaded) {
            drawLine();
        }
    }

    function setLineDiagonal() {
        // Set diagonal line from top-left to bottom-right
        lineState.line = { start: {x: 0.2, y: 0.2}, end: {x: 0.8, y: 0.8} };
        lineState.orientation = 'diagonal';
        
        // Update button selection
        const buttons = document.querySelectorAll('#lineModal .btn-group .btn');
        buttons.forEach(btn => btn.classList.remove('selected'));
        buttons[2]?.classList.add('selected');
        
        if (lineState.imageLoaded) {
            drawLine();
        }
    }

    function flipLineDirection() {
        // Swap start and end points
        const temp = lineState.line.start;
        lineState.line.start = lineState.line.end;
        lineState.line.end = temp;
        
        if (lineState.imageLoaded) {
            drawLine();
        }
    }

    function extendLine() {
        // Extend line by 20% while keeping the center position
        const centerX = (lineState.line.start.x + lineState.line.end.x) / 2;
        const centerY = (lineState.line.start.y + lineState.line.end.y) / 2;
        const deltaX = lineState.line.end.x - lineState.line.start.x;
        const deltaY = lineState.line.end.y - lineState.line.start.y;
        
        // Extend by 20%
        const extendedDeltaX = deltaX * 1.2;
        const extendedDeltaY = deltaY * 1.2;
        
        // Calculate new positions
        const newStartX = Math.max(0, Math.min(1, centerX - extendedDeltaX / 2));
        const newStartY = Math.max(0, Math.min(1, centerY - extendedDeltaY / 2));
        const newEndX = Math.max(0, Math.min(1, centerX + extendedDeltaX / 2));
        const newEndY = Math.max(0, Math.min(1, centerY + extendedDeltaY / 2));
        
        lineState.line.start = {x: newStartX, y: newStartY};
        lineState.line.end = {x: newEndX, y: newEndY};
        
        if (lineState.imageLoaded) {
            drawLine();
        }
    }

    function shortenLine() {
        // Shorten line by 20% while keeping the center position
        const centerX = (lineState.line.start.x + lineState.line.end.x) / 2;
        const centerY = (lineState.line.start.y + lineState.line.end.y) / 2;
        const deltaX = lineState.line.end.x - lineState.line.start.x;
        const deltaY = lineState.line.end.y - lineState.line.start.y;
        
        // Shorten by 20%
        const shortenedDeltaX = deltaX * 0.8;
        const shortenedDeltaY = deltaY * 0.8;
        
        lineState.line.start = {
            x: centerX - shortenedDeltaX / 2,
            y: centerY - shortenedDeltaY / 2
        };
        lineState.line.end = {
            x: centerX + shortenedDeltaX / 2,
            y: centerY + shortenedDeltaY / 2
        };
        
        if (lineState.imageLoaded) {
            drawLine();
        }
    }

    async function saveLine() {
        try {
            const lineConfig = {
                start: lineState.line.start,
                end: lineState.line.end,
                orientation: lineState.orientation
            };
            
            // Save to active module (runtime)
            const response = await fetch('/api/set_counting_line', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    app_name: lineState.currentApp,
                    channel_id: lineState.currentChannel,
                    line_config: lineConfig
                })
            });

            const result = await response.json();
            if (result.success) {
                // Save to database for persistence
                await saveConfigToDatabase(lineState.currentChannel, lineState.currentApp, 'counting_line', lineConfig);
                alert('Counting line saved successfully!');
                closeLineModal();
            } else {
                alert(`Error saving line: ${result.error}`);
            }
        } catch (error) {
            console.error('Error saving line:', error);
            alert('Failed to save counting line');
        }
    }

    // ============= Configuration Persistence Functions =============
    
    /**
     * Save configuration to database for persistence across restarts
     */
    async function saveConfigToDatabase(channelId, appName, configType, configData) {
        try {
            console.log('üì§ Sending to database:', {
                channel_id: channelId,
                app_name: appName,
                config_type: configType,
                config_data: configData
            });
            
            const response = await fetch('/api/save_config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    channel_id: channelId,
                    app_name: appName,
                    config_type: configType,
                    config_data: configData
                })
            });
            
            const result = await response.json();
            if (result.success) {
                console.log(`‚úÖ ${configType} saved to database for ${appName}/${channelId}`);
                console.log('Database response:', result);
            } else {
                console.error(`‚ùå Failed to save ${configType} to database:`, result.error);
            }
        } catch (error) {
            console.error(`Error saving ${configType} to database:`, error);
        }
    }

    /**
     * Load saved configuration from database
     */
    async function loadConfigFromDatabase(channelId, appName, configType) {
        try {
            const response = await fetch(`/api/get_config/${channelId}/${appName}/${configType}`);
            const result = await response.json();
            
            if (result.success && result.config) {
                console.log(`‚úÖ Loaded ${configType} from database for ${appName}/${channelId}`);
                return result.config;
            } else {
                console.log(`‚ÑπÔ∏è No saved ${configType} found for ${appName}/${channelId}`);
                return null;
            }
        } catch (error) {
            console.error(`Error loading ${configType} from database:`, error);
            return null;
        }
    }

    /**
     * Load all configurations for a channel and app
     */
    async function loadAllConfigs(channelId, appName) {
        try {
            const response = await fetch(`/api/get_all_configs/${channelId}/${appName}`);
            const result = await response.json();
            
            if (result.success) {
                console.log(`‚úÖ Loaded all configs for ${appName}/${channelId}:`, result.configs);
                return result.configs;
            } else {
                console.log(`‚ÑπÔ∏è No saved configs found for ${appName}/${channelId}`);
                return { roi: null, counting_line: null };
            }
        } catch (error) {
            console.error(`Error loading configs from database:`, error);
            return { roi: null, counting_line: null };
        }
    }

    /**
     * Apply saved configurations when starting a channel
     */
    async function applySavedConfigurations(channelId, appName) {
        console.log(`üîÑ Loading saved configurations for ${appName}/${channelId}...`);
        
        const configs = await loadAllConfigs(channelId, appName);
        
        // Apply ROI configuration
        if (configs.roi) {
            try {
                const response = await fetch('/api/set_roi', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        app_name: appName,
                        channel_id: channelId,
                        roi_points: configs.roi
                    })
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`‚úÖ Applied saved ROI configuration`);
                } else {
                    console.warn(`‚ö†Ô∏è Failed to apply ROI:`, result.error);
                }
            } catch (error) {
                console.error(`Error applying saved ROI:`, error);
            }
        }
        
        // Apply counting line configuration
        if (configs.counting_line) {
            try {
                const response = await fetch('/api/set_counting_line', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        app_name: appName,
                        channel_id: channelId,
                        line_config: configs.counting_line
                    })
                });
                const result = await response.json();
                if (result.success) {
                    console.log(`‚úÖ Applied saved counting line configuration`);
                } else {
                    console.warn(`‚ö†Ô∏è Failed to apply counting line:`, result.error);
                }
            } catch (error) {
                console.error(`Error applying saved counting line:`, error);
            }
        }
        
        if (configs.roi || configs.counting_line) {
            console.log(`‚úÖ All saved configurations applied for ${appName}/${channelId}`);
        } else {
            console.log(`‚ÑπÔ∏è No saved configurations found for ${appName}/${channelId}`);
        }
    }
    
    // ============= Table Service Monitor Functions =============
    
    // Load table service violations
    async function loadTableServiceViolations() {
        console.log('üîÑ Loading table service violations (cleanliness & reset only)...');
        const grid = document.getElementById('table-service-violations-grid');
        if (!grid) {
            console.error('‚ùå Table service violations grid not found');
            return;
        }
        
        grid.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading violations...</p>';
        
        try {
            // Fetch cleanliness violations from dedicated table (unclean_table / slow_reset only)
            const response = await fetch('/api/get_table_cleanliness_violations?limit=100');
            const result = await response.json();
            
            console.log('üìä Table service violations response:', result);
            
            if (result.success) {
                const allViolations = result.violations || [];
                console.log(`üìä Total violations fetched: ${allViolations.length}`);

                const cleanlinessViolations = allViolations;
                console.log(`‚úÖ Found ${cleanlinessViolations.length} cleanliness violations`);
                if (allViolations.length > 0) {
                    console.log('üìä Sample violation:', JSON.stringify(allViolations[0], null, 2));
                }
                displayTableServiceViolations(cleanlinessViolations);
                updateTableServiceStats();
            } else {
                console.error('‚ùå Failed to load table service violations:', result.error);
                grid.innerHTML = `<p style="text-align: center; padding: 20px; color: #ef4444;">Error loading violations: ${result.error}</p>`;
            }
        } catch (error) {
            console.error('‚ùå Error loading table service violations:', error);
            grid.innerHTML = `<p style="text-align: center; padding: 20px; color: #ef4444;">Error: ${error.message}</p>`;
        }
    }
    
    // Display table service violations
    function displayTableServiceViolations(violations) {
        const grid = document.getElementById('table-service-violations-grid');
        
        if (!violations || violations.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>‚úÖ All Clear</h3>
                    <p>No table service violations detected.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = violations.map(violation => {
            const snapshotUrl = violation.snapshot_path 
                ? `/static/${violation.snapshot_path}` 
                : '/static/icon.png';
            
            const timestamp = violation.timestamp || violation.created_at || new Date().toISOString();
            
            // Parse alert_data to get violation type and details
            let violationType = 'Unknown';
            let violationDetails = '';
            let tableId = violation.table_id || 'Unknown';
            
            try {
                if (violation.alert_data) {
                    const alertData = typeof violation.alert_data === 'string' 
                        ? JSON.parse(violation.alert_data) 
                        : violation.alert_data;
                    violationType = alertData.violation_type || 'Unknown';
                    
                    if (violationType === 'unclean_table') {
                        violationDetails = `Unclean for ${alertData.unclean_duration?.toFixed(1) || 'N/A'}s`;
                    } else if (violationType === 'slow_reset') {
                        violationDetails = `Slow reset: ${alertData.reset_duration?.toFixed(1) || 'N/A'}s`;
                    } else if (violationType === 'wrong_uniform') {
                        violationDetails = `Wrong uniform: ${alertData.wrong_uniforms?.join(', ') || 'Unknown'}`;
                        tableId = 'N/A'; // Uniform violations are not table-specific
                    }
                }
            } catch (e) {
                console.error('Error parsing violation alert_data:', e);
            }
            
            // Only show waiting_time for service_discipline violations (which shouldn't appear here)
            // For cleanliness violations, show violation type and details instead
            const showWaitingTime = violation.waiting_time && violation.waiting_time > 0;
            
            return `
            <div class="alert-gif-card" style="border-left: 4px solid #f59e0b;">
                <div class="gif-preview">
                    <img src="${snapshotUrl}" alt="Table Service Violation" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)" onerror="this.src='/static/icon.png'; this.onerror=null;">
                </div>
                <div class="gif-info">
                    <div class="gif-channel"><strong>üìπ Channel:</strong> ${violation.channel_id}</div>
                    <div class="gif-time"><strong>üïê Time:</strong> ${new Date(timestamp).toLocaleString()}</div>
                    <div style="color: #f59e0b;"><strong>üçΩÔ∏è Table:</strong> ${tableId}</div>
                    ${violationType !== 'Unknown' ? `<div style="color: #ef4444;"><strong>‚ö†Ô∏è Violation:</strong> ${violationType.replace('_', ' ').toUpperCase()}</div>` : ''}
                    ${violationDetails ? `<div style="color: #ef4444; font-size: 0.9em; margin-top: 4px;">${violationDetails}</div>` : ''}
                    ${showWaitingTime ? `<div style="color: #ef4444; font-size: 0.9em; margin-top: 4px;"><strong>‚è±Ô∏è Waiting Time:</strong> ${violation.waiting_time.toFixed(1)}s</div>` : ''}
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm btn-primary" onclick="downloadTableServiceSnapshot(${violation.id}, '${violation.snapshot_path || snapshotUrl}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteTableServiceViolation(${violation.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `;
        }).join('');
    }
    
    // Update table service stats
    async function updateTableServiceStats() {
        try {
            const response = await fetch('/api/get_module_analytics/TableServiceMonitor');
            const data = await response.json();
            
            if (data.success && data.analytics) {
                const analytics = data.analytics;
                
                // Update total violations
                document.getElementById('tsm-total-violations').textContent = analytics.total_alerts_7days || 0;
                
                // Update average and max unclean time (convert seconds to minutes)
                const avgUnclean = (analytics.avg_unclean_time || 0) / 60;
                const maxUnclean = (analytics.max_unclean_time || 0) / 60;
                document.getElementById('tsm-avg-unclean-time').textContent = `${avgUnclean.toFixed(1)} min`;
                document.getElementById('tsm-max-unclean-time').textContent = `${maxUnclean.toFixed(1)} min`;
                
                // Update average and max reset time (convert seconds to minutes)
                const avgReset = (analytics.avg_reset_time || 0) / 60;
                const maxReset = (analytics.max_reset_time || 0) / 60;
                document.getElementById('tsm-avg-reset-time').textContent = `${avgReset.toFixed(1)} min`;
                document.getElementById('tsm-max-reset-time').textContent = `${maxReset.toFixed(1)} min`;
                
                // Update active channels
                document.getElementById('tsm-active-channels').textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating table service stats:', error);
        }
    }
    
    // Delete table service violation
    async function deleteTableServiceViolation(violationId) {
        if (!confirm('Are you sure you want to delete this violation?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/delete_table_cleanliness_violation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ violation_id: violationId })
            });
            
            const result = await response.json();
            if (result.success) {
                loadTableServiceViolations();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error deleting table service violation:', error);
            alert('Failed to delete violation');
        }
    }
    
    // Clear old table service violations
    async function clearOldTableServiceViolations() {
        if (!confirm('Are you sure you want to clear violations older than 7 days?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/clear_old_table_service_violations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ days: 7 })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Successfully deleted ${result.deleted_count || 0} old violations`);
                loadTableServiceViolations();
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old violations:', error);
            alert('Failed to clear old violations');
        }
    }
    
    // Download table service snapshot
    function downloadTableServiceSnapshot(violationId, snapshotPath) {
        const url = snapshotPath.startsWith('/') ? snapshotPath : `/static/${snapshotPath}`;
        const link = document.createElement('a');
        link.href = url;
        link.download = snapshotPath.split('/').pop() || 'table_service_violation.jpg';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    
    // ============= Dress Code Monitoring Functions =============
    
    // Load dress code violation alerts
    async function loadDressCodeAlerts() {
        console.log('üîÑ Loading dress code alerts...');
        const grid = document.getElementById('dresscode-alerts-grid');
        if (!grid) {
            console.error('‚ùå Dress code alerts grid not found');
            return;
        }
        
        // Show loading state
        grid.innerHTML = '<p style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading alerts...</p>';
        
        try {
            const response = await fetch('/api/get_dresscode_alerts?limit=50');
            const result = await response.json();
            
            console.log('üìä Dress code alerts response:', result);
            
            if (result.success) {
                console.log(`‚úÖ Found ${result.count || result.alerts?.length || 0} dress code alerts`);
                displayDressCodeAlerts(result.alerts || []);
                updateDressCodeStats();
            } else {
                console.error('‚ùå Failed to load dress code alerts:', result.error);
                grid.innerHTML = `<p style="text-align: center; padding: 20px; color: #ef4444;">Error loading alerts: ${result.error}</p>`;
            }
        } catch (error) {
            console.error('‚ùå Error loading dress code alerts:', error);
            grid.innerHTML = `<p style="text-align: center; padding: 20px; color: #ef4444;">Error: ${error.message}</p>`;
        }
    }
    
    // Display dress code alerts
    function displayDressCodeAlerts(alerts) {
        const grid = document.getElementById('dresscode-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>‚úÖ All Clear</h3>
                    <p>No dress code violations detected.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => {
            // Fix snapshot path - use snapshot_filename if available, otherwise extract from path
            const snapshotUrl = alert.snapshot_filename 
                ? `/static/dresscode_snapshots/${alert.snapshot_filename}` 
                : (alert.snapshot_path ? `/static/dresscode_snapshots/${alert.snapshot_path.split('/').pop()}` : '/static/icon.png');
            
            // Format timestamp
            const timestamp = alert.created_at || alert.timestamp || new Date().toISOString();
            
            return `
            <div class="alert-gif-card" style="border-left: 4px solid #ef4444;">
                <div class="gif-preview">
                    <img src="${snapshotUrl}" alt="Dress Code Violation" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)" onerror="this.src='/static/icon.png'; this.onerror=null;">
                </div>
                <div class="gif-info">
                    <div class="gif-channel"><strong>üìπ Channel:</strong> ${alert.channel_id}</div>
                    <div class="gif-time"><strong>üïê Time:</strong> ${new Date(timestamp).toLocaleString()}</div>
                    <div style="color: #f59e0b;"><strong>‚ö†Ô∏è Violation:</strong> ${alert.violations || 'Dress code violation'}</div>
                </div>
                <div class="gif-actions">
                    <button class="btn btn-sm btn-primary" onclick="downloadDressCodeSnapshot(${alert.id}, '${alert.snapshot_path || snapshotUrl}')">üì• Download</button>
                    <button class="btn btn-sm btn-danger" onclick="deleteDressCodeAlert(${alert.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `;
        }).join('');
    }
    
    // Download dress code snapshot
    async function downloadDressCodeSnapshot(alertId, snapshotPath) {
        try {
            // Extract filename from path
            const filename = snapshotPath.split('/').pop();
            
            // Fetch the image
            const response = await fetch(snapshotPath);
            if (!response.ok) throw new Error('Failed to fetch snapshot');
            
            // Get the blob
            const blob = await response.blob();
            
            // Create download link
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `dresscode_violation_${alertId}_${filename}`;
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        } catch (error) {
            console.error('Error downloading snapshot:', error);
            alert('Failed to download snapshot');
        }
    }
    
    // Delete dress code alert
    async function deleteDressCodeAlert(alertId) {
        if (!confirm('Delete this violation alert?')) return;
        
        try {
            const response = await fetch(`/api/delete_dresscode_alert/${alertId}`, {method: 'DELETE'});
            const result = await response.json();
            if (result.success) loadDressCodeAlerts();
            else alert('Error: ' + result.error);
        } catch (error) {
            console.error('Error deleting alert:', error);
        }
    }
    
    // Update stats
    async function updateDressCodeStats() {
        try {
            const response = await fetch('/api/get_dresscode_stats?days=7');
            const result = await response.json();
            
            if (result.success) {
                const stats = result.stats;
                document.getElementById('dcm-total-violations').textContent = stats.total_violations || 0;
                const rate = stats.total_violations > 0 ? Math.max(0, 100 - (stats.total_violations * 5)) : 100;
                document.getElementById('dcm-compliance-rate').textContent = rate.toFixed(1) + '%';
            }
        } catch (error) {
            console.error('Error updating stats:', error);
        }
    }
    
    // PPE Alert Management Functions
    // PPE Alert Management Functions
    async function loadPPEAlerts() {
        try {
            console.log('üõ°Ô∏è Loading PPE alerts...');
            const response = await fetch('/api/get_ppe_alerts?limit=50');
            const result = await response.json();
            
            console.log('üõ°Ô∏è PPE alerts response:', result);
            
            if (result.success) {
                console.log(`üõ°Ô∏è Found ${result.alerts?.length || 0} PPE alerts`);
                displayPPEAlerts(result.alerts || []);
                updatePPEStats();
            } else {
                console.error('Failed to load PPE alerts:', result.error);
            }
        } catch (error) {
            console.error('Error loading PPE alerts:', error);
        }
    }
    
    // Display PPE alerts
    function displayPPEAlerts(alerts) {
        const grid = document.getElementById('ppe-alerts-grid');
        
        if (!alerts || alerts.length === 0) {
            grid.innerHTML = `
                <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                    <h3>‚úÖ All Clear</h3>
                    <p>No PPE violations detected.</p>
                </div>
            `;
            return;
        }
        
        grid.innerHTML = alerts.map(alert => `
            <div class="alert-gif-card">
                ${alert.snapshot_path ? `
                    <div class="gif-preview">
                        <img src="${alert.snapshot_path}" alt="PPE Violation" loading="lazy" style="width: 100%; border-radius: 4px; cursor: pointer;" onclick="openLightboxFromImage(this)">
                    </div>
                ` : `
                    <div class="gif-preview" style="background: #1f2937; display: flex; align-items: center; justify-content: center; min-height: 150px;">
                        <span style="color: #9ca3af;">No snapshot available</span>
                    </div>
                `}
                <div class="gif-info">
                    <div class="gif-channel"><strong>üìπ</strong> ${alert.channel_id}</div>
                    <div class="gif-time"><strong>üïê</strong> ${new Date(alert.timestamp || alert.created_at).toLocaleString()}</div>
                    <div style="color: #f59e0b;"><strong>‚ö†Ô∏è</strong> ${alert.violations || 'PPE violation'}</div>
                </div>
                <div class="gif-actions">
                    ${alert.snapshot_path ? `
                        <button class="btn btn-sm btn-primary" onclick="downloadPPESnapshot(${alert.id}, '${alert.snapshot_path}')">üì• Download</button>
                    ` : ''}
                    <button class="btn btn-sm btn-danger" onclick="deletePPEAlert(${alert.id})">üóëÔ∏è Delete</button>
                </div>
            </div>
        `).join('');
    }
    
    // Download PPE snapshot
    async function downloadPPESnapshot(alertId, snapshotPath) {
        try {
            // Extract filename from path
            const filename = snapshotPath.split('/').pop();
            
            // Fetch the image
            const response = await fetch(snapshotPath);
            if (!response.ok) throw new Error('Failed to fetch snapshot');
            
            // Get the blob
            const blob = await response.blob();
            
            // Create download link
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ppe_violation_${alertId}_${filename}`;
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        } catch (error) {
            console.error('Error downloading snapshot:', error);
            alert('Failed to download snapshot');
        }
    }
    
    // Delete PPE alert
    async function deletePPEAlert(alertId) {
        if (!confirm('Delete this violation alert?')) return;
        
        try {
            const response = await fetch(`/api/delete_ppe_alert/${alertId}`, {method: 'DELETE'});
            const result = await response.json();
            if (result.success) loadPPEAlerts();
            else alert('Error: ' + result.error);
        } catch (error) {
            console.error('Error deleting alert:', error);
        }
    }
    
    async function clearOldPPEAlerts() {
        if (!confirm('Clear all PPE alerts older than 7 days?')) return;
        try {
            const response = await fetch('/api/clear_old_alerts?alert_type=ppe_alert&days=7', { method: 'DELETE' });
            const result = await response.json();
            if (result.success) {
                loadPPEAlerts();
                updatePPEStats();
                alert('Old PPE alerts cleared');
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            console.error('Error clearing old PPE alerts:', error);
        }
    }
    
    async function updatePPEStats() {
        try {
            const response = await fetch('/api/get_module_analytics/PPEMonitoring');
            const result = await response.json();
            
            if (result.success && result.analytics) {
                const analytics = result.analytics;
                const totalAlertsEl = document.getElementById('ppe-total-alerts');
                const todayAlertsEl = document.getElementById('ppe-today-alerts');
                const activeChannelsEl = document.getElementById('ppe-active-channels');
                
                if (totalAlertsEl) totalAlertsEl.textContent = analytics.total_alerts || 0;
                if (todayAlertsEl) todayAlertsEl.textContent = analytics.today_alerts || 0;
                if (activeChannelsEl) activeChannelsEl.textContent = analytics.active_channels || 0;
            }
        } catch (error) {
            console.error('Error updating PPE stats:', error);
        }
    }
    
    // Clear old alerts
    async function clearOldDressCodeAlerts() {
        if (!confirm('Delete all alerts older than 7 days?')) return;
        alert('Feature coming soon - manual deletion available');
    }

    // ============= Lightbox Functions =============
    let lightboxImages = [];
    let currentLightboxIndex = -1;

    function openLightbox(imageSrc, title = '', details = '', allImages = null) {
        const lightbox = document.getElementById('imageLightbox');
        const lightboxImg = document.getElementById('lightbox-image');
        const lightboxTitle = document.getElementById('lightbox-title');
        const lightboxDetails = document.getElementById('lightbox-details');
        
        if (!lightbox || !lightboxImg) {
            console.error('Lightbox elements not found');
            return;
        }
        
        // Store all images for navigation
        if (allImages && Array.isArray(allImages) && allImages.length > 0) {
            lightboxImages = allImages;
        } else {
            lightboxImages = [{ src: imageSrc, title, details }];
        }
        
        currentLightboxIndex = lightboxImages.findIndex(img => img.src === imageSrc || img.src.includes(imageSrc.split('/').pop()));
        if (currentLightboxIndex === -1) currentLightboxIndex = 0;
        
        lightboxImg.src = imageSrc;
        if (lightboxTitle) lightboxTitle.textContent = title || 'Alert Snapshot';
        if (lightboxDetails) lightboxDetails.innerHTML = details || '';
        
        lightbox.classList.add('active');
        document.body.style.overflow = 'hidden';
        
        // Update navigation buttons visibility
        const prevBtn = document.querySelector('.lightbox-prev');
        const nextBtn = document.querySelector('.lightbox-next');
        if (prevBtn) prevBtn.style.display = lightboxImages.length > 1 ? 'block' : 'none';
        if (nextBtn) nextBtn.style.display = lightboxImages.length > 1 ? 'block' : 'none';
    }

    function openLightboxFromImage(imgElement) {
        const card = imgElement.closest('.alert-gif-card') || imgElement.closest('.alert-card') || imgElement.closest('.alert-gif-item');
        if (!card) {
            // Fallback: just open the image
            openLightbox(imgElement.src, 'Alert Snapshot', '');
            return;
        }
        
        // Extract title and details from the clicked image's card (the correct one)
        const channel = card.querySelector('.gif-channel, .alert-channel')?.textContent || '';
        const time = card.querySelector('.gif-time, .alert-time')?.textContent || '';
        const message = card.querySelector('.gif-message, .alert-details, .alert-message')?.textContent || '';
        
        const title = channel || 'Alert Snapshot';
        const details = `${time}<br>${message}`;
        
        // Collect all images from the grid for navigation
        const grid = card.closest('.alert-gifs-grid') || card.closest('.alert-gifs-grid');
        let allImages = [];
        
        if (grid) {
            const images = Array.from(grid.querySelectorAll('img')).map(img => {
                const imgCard = img.closest('.alert-gif-card') || img.closest('.alert-card') || img.closest('.alert-gif-item');
                if (!imgCard) return null;
                
                // Try to extract title and details from card
                const imgChannel = imgCard.querySelector('.gif-channel, .alert-channel')?.textContent || '';
                const imgTime = imgCard.querySelector('.gif-time, .alert-time')?.textContent || '';
                const imgMessage = imgCard.querySelector('.gif-message, .alert-details, .alert-message')?.textContent || '';
                
                return {
                    src: img.src,
                    title: imgChannel || 'Alert Snapshot',
                    details: `${imgTime}<br>${imgMessage}`
                };
            }).filter(img => img !== null);
            
            allImages = images.length > 0 ? images : [{ src: imgElement.src, title: title, details: details }];
        } else {
            allImages = [{ src: imgElement.src, title: title, details: details }];
        }
        
        // Use the clicked image's card details, not the first one in the list
        openLightbox(imgElement.src, title, details, allImages);
    }

    function closeLightbox(event) {
        const lightbox = document.getElementById('imageLightbox');
        if (!lightbox) return;
        
        // Only close if clicking on backdrop or close button
        if (event && event.target !== lightbox && !event.target.classList.contains('lightbox-close')) {
            return;
        }
        
        lightbox.classList.remove('active');
        document.body.style.overflow = '';
    }

    function changeLightboxImage(direction) {
        if (lightboxImages.length <= 1) return;
        
        currentLightboxIndex += direction;
        if (currentLightboxIndex < 0) {
            currentLightboxIndex = lightboxImages.length - 1;
        } else if (currentLightboxIndex >= lightboxImages.length) {
            currentLightboxIndex = 0;
        }
        
        const img = lightboxImages[currentLightboxIndex];
        const lightboxImg = document.getElementById('lightbox-image');
        const lightboxTitle = document.getElementById('lightbox-title');
        const lightboxDetails = document.getElementById('lightbox-details');
        
        if (lightboxImg) lightboxImg.src = img.src;
        if (lightboxTitle) lightboxTitle.textContent = img.title || 'Alert Snapshot';
        if (lightboxDetails) lightboxDetails.innerHTML = img.details || '';
    }

    // Keyboard navigation for lightbox
    document.addEventListener('keydown', function(e) {
        const lightbox = document.getElementById('imageLightbox');
        if (!lightbox || !lightbox.classList.contains('active')) return;
        
        if (e.key === 'Escape') {
            closeLightbox();
        } else if (e.key === 'ArrowLeft') {
            changeLightboxImage(-1);
        } else if (e.key === 'ArrowRight') {
            changeLightboxImage(1);
        }
    });

</script>
<!-- Image Lightbox Modal -->
<div id="imageLightbox" class="lightbox-modal" onclick="closeLightbox(event)">
    <span class="lightbox-close" onclick="closeLightbox()">&times;</span>
    <span class="lightbox-prev" onclick="event.stopPropagation(); changeLightboxImage(-1)">&#10094;</span>
    <span class="lightbox-next" onclick="event.stopPropagation(); changeLightboxImage(1)">&#10095;</span>
    <div class="lightbox-content">
        <img id="lightbox-image" src="" alt="Full size image">
        <div class="lightbox-info">
            <div id="lightbox-title"></div>
            <div id="lightbox-details"></div>
        </div>
    </div>
</div>
</body>
</html>